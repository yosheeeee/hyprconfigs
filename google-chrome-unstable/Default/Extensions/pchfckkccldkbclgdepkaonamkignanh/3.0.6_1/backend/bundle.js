webpackJsonp([ 1, 3 ], [ function(module, exports, __webpack_require__) {
    "use strict";
    var errorBooster = __webpack_require__(25);
    self.addEventListener("error", function(e) {
        errorBooster.uncaught(e.message);
    });
    self.addEventListener("unhandledrejection", function(e) {
        errorBooster.uncaught(e.reason);
    });
    __webpack_require__(29).run();
}, , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var always = __webpack_require__(208);
    var runstate = __webpack_require__(344);
    var install = __webpack_require__(533);
    var upgrade = __webpack_require__(537);
    var normalStart = __webpack_require__(534);
    var bootstrap = __webpack_require__(2);
    var logger = __webpack_require__(5).create("Startup");
    var runCallback;
    var startExecuteTime;
    exports.run = function(callback) {
        startExecuteTime = Date.now();
        runCallback = callback || utils.noop;
        always.prepare();
        always.initCore(processRunstate);
    };
    function processRunstate() {
        runstate.detect(function() {
            var moduleToRun = getModuleToRun();
            moduleToRun.preInit(function() {
                always.initNormal();
                moduleToRun.run(finalize);
            });
        });
    }
    function getModuleToRun() {
        return runstate.isInstall() ? install : runstate.isUpgrade() ? upgrade : normalStart;
    }
    function finalize() {
        always.finalize(function() {
            logTimes();
            runCallback();
        });
    }
    function logTimes() {
        var runstateText = runstate.isInstall() ? "install" : runstate.isUpgrade() ? "upgrade" : "normal run";
        var now = Date.now();
        logger.info("Bundle times (%s): load (%i ms), execute (%i ms), total (%i ms)", runstateText, startExecuteTime - bootstrap.startTime, now - startExecuteTime, now - bootstrap.startTime);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = {
        noop: __webpack_require__(28),
        noargs: function(fn) {
            return function() {
                fn();
            };
        },
        misc: __webpack_require__(31),
        xhr: __webpack_require__(32),
        formatDate: __webpack_require__(4).format,
        object: __webpack_require__(90),
        versionCompare: __webpack_require__(31).versionCompare,
        xml: __webpack_require__(61),
        url: __webpack_require__(83),
        _: __webpack_require__(91),
        browserInfo: __webpack_require__(22),
        guid: __webpack_require__(31).guid,
        date: __webpack_require__(4),
        curly: __webpack_require__(207),
        logger: __webpack_require__(5)
    };
}, function(module, exports) {
    "use strict";
    module.exports = {
        versionCompare: function(v1, v2, options) {
            var lexicographical = options && options.lexicographical;
            var zeroExtend = options && options.zeroExtend;
            var v1parts = v1.split(".");
            var v2parts = v2.split(".");
            function isValidPart(x) {
                return (lexicographical ? /^\d+[A-Za-z]*$/ : /^\d+$/).test(x);
            }
            if (!v1parts.every(isValidPart) || !v2parts.every(isValidPart)) return NaN;
            if (zeroExtend) {
                while (v1parts.length < v2parts.length) v1parts.push("0");
                while (v2parts.length < v1parts.length) v2parts.push("0");
            }
            if (!lexicographical) {
                v1parts = v1parts.map(Number);
                v2parts = v2parts.map(Number);
            }
            for (var i = 0; i < v1parts.length; ++i) {
                if (v2parts.length === i) return 1;
                if (v1parts[i] === v2parts[i]) continue; else if (v1parts[i] > v2parts[i]) return 1; else return -1;
            }
            if (v1parts.length !== v2parts.length) return -1;
            return 0;
        },
        guid: function() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
                var r = 16 * Math.random() | 0;
                var v = "x" === c ? r : 3 & r | 8;
                return v.toString(16);
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var URI = __webpack_require__(33);
    var xhrUtils = __webpack_require__(38);
    var logger = __webpack_require__(5).create("XHR");
    var isPlainObject = __webpack_require__(39);
    var noop = __webpack_require__(57);
    var formatMessage = __webpack_require__(58);
    var DEFAULT_TIMEOUT = 15e3;
    var platformXhr = __webpack_require__(59);
    var PREDEFINED_PARSERS = __webpack_require__(60);
    var xhrRequest = module.exports = function(options, callback, ctx) {
        return new Request(options, callback, ctx).send();
    };
    [ "isError", "isNetworkError", "isServerError", "isServerError", "isClientError", "isRedirect", "isSuccess", "isInformal" ].forEach(function(name) {
        return xhrRequest[name] = xhrUtils[name];
    });
    function Request(options, callback, ctx) {
        this.options = options || {};
        this.callback = callback ? callback.bind(ctx) : noop;
    }
    Request.prototype.send = function() {
        if (!this._createXhr()) return this.xhr;
        this._setProps();
        this._setHeaders();
        this._addEventListeners();
        this._sendXhr();
        return this.xhr;
    };
    Request.prototype._createXhr = function() {
        try {
            this.xhr = platformXhr.create(this.options);
            var method = this.options.method || (this.options.body ? "POST" : "GET");
            this.xhr.open(method, this.options.url, true);
        } catch (err) {
            this._handleError(err.message);
            return false;
        }
        return true;
    };
    Request.prototype._setProps = function() {
        var options = this.options;
        var xhr = this.xhr;
        if (null !== options.timeout) xhr.timeout = options.timeout || DEFAULT_TIMEOUT;
        if (options.parse in PREDEFINED_PARSERS) options.parse = PREDEFINED_PARSERS[options.parse](xhr);
        if (options.responseType) try {
            xhr.responseType = options.responseType;
        } catch (err) {}
        if (options.withCredentials) try {
            xhr.withCredentials = true;
        } catch (ex) {}
    };
    Request.prototype._addEventListeners = function() {
        this.xhr.onload = this._handleResponse.bind(this);
        this.xhr.ontimeout = this._handleError.bind(this, "Aborted by timeout " + this.options.timeout + " ms");
        this.xhr.onabort = this._handleError.bind(this, "Aborted");
        this.xhr.onerror = this._handleError.bind(this, "Error");
    };
    Request.prototype._setHeaders = function() {
        var options = this.options;
        var headers = options.headers || {};
        if (options.bypassCache) headers["If-Modified-Since"] = "Sat, 1 Jan 2005 00:00:00 GMT";
        if ("string" === typeof options.body) {
            if (!headers["Content-Type"]) headers["Content-Type"] = "text/plain; charset=UTF-8";
        } else if (isPlainObject(options.body)) {
            options.body = URI.buildQuery(options.body);
            if (!headers["Content-Type"]) headers["Content-Type"] = "application/x-www-form-urlencoded; charset=UTF-8";
        }
        Object.keys(headers).forEach(function(name) {
            this.xhr.setRequestHeader(name, headers[name]);
        }, this);
    };
    Request.prototype._sendXhr = function() {
        this.xhr.send(this.options.body || null);
    };
    Request.prototype._handleError = function(text, evt) {
        var msg = evt ? this._getErrorMessage(text, evt) : text;
        if (this.options.logError) logger.error(msg);
        this.callback(new Error(msg), null, evt);
    };
    Request.prototype._handleResponse = function(evt) {
        var options = this.options;
        var isErrorStatus = xhrRequest.isError(evt.target.status);
        if (isErrorStatus) {
            this._handleError("", evt);
            return;
        }
        var parsed = evt.target.response;
        if (options.parse) try {
            parsed = options.parse(evt);
        } catch (e) {
            if (!options.ignoreParseError) {
                this._handleError(e.message, evt);
                return;
            }
        }
        this.callback(null, parsed, evt);
    };
    Request.prototype._getErrorMessage = function(text, evt) {
        var responseText = "";
        try {
            responseText = evt.target.responseText;
        } catch (e) {}
        return formatMessage("%i %s at %l \nError: %l ResponseText: %l", evt.target.status, evt.target.statusText, this.options.url, text, responseText);
    };
    __webpack_require__(71).override(Request);
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    !function(root, factory) {
        "use strict";
        if ("object" === typeof module && module.exports) module.exports = factory(__webpack_require__(34), __webpack_require__(36), __webpack_require__(37)); else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(34), __webpack_require__(36), __webpack_require__(37) ], 
        __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, 
        void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
    }(this, function(punycode, IPv6, SLD, root) {
        "use strict";
        var _URI = root && root.URI;
        function URI(url, base) {
            var _urlSupplied = arguments.length >= 1;
            var _baseSupplied = arguments.length >= 2;
            if (!(this instanceof URI)) {
                if (_urlSupplied) {
                    if (_baseSupplied) return new URI(url, base);
                    return new URI(url);
                }
                return new URI();
            }
            if (void 0 === url) {
                if (_urlSupplied) throw new TypeError("undefined is not a valid argument for URI");
                if ("undefined" !== typeof location) url = location.href + ""; else url = "";
            }
            if (null === url) if (_urlSupplied) throw new TypeError("null is not a valid argument for URI");
            this.href(url);
            if (void 0 !== base) return this.absoluteTo(base);
            return this;
        }
        function isInteger(value) {
            return /^[0-9]+$/.test(value);
        }
        URI.version = "1.18.12";
        var p = URI.prototype;
        var hasOwn = Object.prototype.hasOwnProperty;
        function escapeRegEx(string) {
            return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
        }
        function getType(value) {
            if (void 0 === value) return "Undefined";
            return String(Object.prototype.toString.call(value)).slice(8, -1);
        }
        function isArray(obj) {
            return "Array" === getType(obj);
        }
        function filterArrayValues(data, value) {
            var lookup = {};
            var i, length;
            if ("RegExp" === getType(value)) lookup = null; else if (isArray(value)) for (i = 0, 
            length = value.length; i < length; i++) lookup[value[i]] = true; else lookup[value] = true;
            for (i = 0, length = data.length; i < length; i++) {
                var _match = lookup && void 0 !== lookup[data[i]] || !lookup && value.test(data[i]);
                if (_match) {
                    data.splice(i, 1);
                    length--;
                    i--;
                }
            }
            return data;
        }
        function arrayContains(list, value) {
            var i, length;
            if (isArray(value)) {
                for (i = 0, length = value.length; i < length; i++) if (!arrayContains(list, value[i])) return false;
                return true;
            }
            var _type = getType(value);
            for (i = 0, length = list.length; i < length; i++) if ("RegExp" === _type) {
                if ("string" === typeof list[i] && list[i].match(value)) return true;
            } else if (list[i] === value) return true;
            return false;
        }
        function arraysEqual(one, two) {
            if (!isArray(one) || !isArray(two)) return false;
            if (one.length !== two.length) return false;
            one.sort();
            two.sort();
            for (var i = 0, l = one.length; i < l; i++) if (one[i] !== two[i]) return false;
            return true;
        }
        function trimSlashes(text) {
            var trim_expression = /^\/+|\/+$/g;
            return text.replace(trim_expression, "");
        }
        URI._parts = function() {
            return {
                protocol: null,
                username: null,
                password: null,
                hostname: null,
                urn: null,
                port: null,
                path: null,
                query: null,
                fragment: null,
                duplicateQueryParameters: URI.duplicateQueryParameters,
                escapeQuerySpace: URI.escapeQuerySpace
            };
        };
        URI.duplicateQueryParameters = false;
        URI.escapeQuerySpace = true;
        URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
        URI.idn_expression = /[^a-z0-9\._-]/i;
        URI.punycode_expression = /(xn--)/i;
        URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
        URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
        URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/gi;
        URI.findUri = {
            start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
            end: /[\s\r\n]|$/,
            trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
            parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
        };
        URI.defaultPorts = {
            http: "80",
            https: "443",
            ftp: "21",
            gopher: "70",
            ws: "80",
            wss: "443"
        };
        URI.hostProtocols = [ "http", "https" ];
        URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
        URI.domAttributes = {
            a: "href",
            blockquote: "cite",
            link: "href",
            base: "href",
            script: "src",
            form: "action",
            img: "src",
            area: "href",
            iframe: "src",
            embed: "src",
            source: "src",
            track: "src",
            input: "src",
            audio: "src",
            video: "src"
        };
        URI.getDomAttribute = function(node) {
            if (!node || !node.nodeName) return;
            var nodeName = node.nodeName.toLowerCase();
            if ("input" === nodeName && "image" !== node.type) return;
            return URI.domAttributes[nodeName];
        };
        function escapeForDumbFirefox36(value) {
            return escape(value);
        }
        function strictEncodeURIComponent(string) {
            return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
        }
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
        URI.iso8859 = function() {
            URI.encode = escape;
            URI.decode = unescape;
        };
        URI.unicode = function() {
            URI.encode = strictEncodeURIComponent;
            URI.decode = decodeURIComponent;
        };
        URI.characters = {
            pathname: {
                encode: {
                    expression: /%(24|26|2B|2C|3B|3D|3A|40)/gi,
                    map: {
                        "%24": "$",
                        "%26": "&",
                        "%2B": "+",
                        "%2C": ",",
                        "%3B": ";",
                        "%3D": "=",
                        "%3A": ":",
                        "%40": "@"
                    }
                },
                decode: {
                    expression: /[\/\?#]/g,
                    map: {
                        "/": "%2F",
                        "?": "%3F",
                        "#": "%23"
                    }
                }
            },
            reserved: {
                encode: {
                    expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/gi,
                    map: {
                        "%3A": ":",
                        "%2F": "/",
                        "%3F": "?",
                        "%23": "#",
                        "%5B": "[",
                        "%5D": "]",
                        "%40": "@",
                        "%21": "!",
                        "%24": "$",
                        "%26": "&",
                        "%27": "'",
                        "%28": "(",
                        "%29": ")",
                        "%2A": "*",
                        "%2B": "+",
                        "%2C": ",",
                        "%3B": ";",
                        "%3D": "="
                    }
                }
            },
            urnpath: {
                encode: {
                    expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/gi,
                    map: {
                        "%21": "!",
                        "%24": "$",
                        "%27": "'",
                        "%28": "(",
                        "%29": ")",
                        "%2A": "*",
                        "%2B": "+",
                        "%2C": ",",
                        "%3B": ";",
                        "%3D": "=",
                        "%40": "@"
                    }
                },
                decode: {
                    expression: /[\/\?#:]/g,
                    map: {
                        "/": "%2F",
                        "?": "%3F",
                        "#": "%23",
                        ":": "%3A"
                    }
                }
            }
        };
        URI.encodeQuery = function(string, escapeQuerySpace) {
            var escaped = URI.encode(string + "");
            if (void 0 === escapeQuerySpace) escapeQuerySpace = URI.escapeQuerySpace;
            return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
        };
        URI.decodeQuery = function(string, escapeQuerySpace) {
            string += "";
            if (void 0 === escapeQuerySpace) escapeQuerySpace = URI.escapeQuerySpace;
            try {
                return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
            } catch (e) {
                return string;
            }
        };
        var _parts = {
            encode: "encode",
            decode: "decode"
        };
        var _part;
        var generateAccessor = function(_group, _part) {
            return function(string) {
                try {
                    return URI[_part](string + "").replace(URI.characters[_group][_part].expression, function(c) {
                        return URI.characters[_group][_part].map[c];
                    });
                } catch (e) {
                    return string;
                }
            };
        };
        for (_part in _parts) {
            URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
            URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
        }
        var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
            return function(string) {
                var actualCodingFunc;
                if (!_innerCodingFuncName) actualCodingFunc = URI[_codingFuncName]; else actualCodingFunc = function(string) {
                    return URI[_codingFuncName](URI[_innerCodingFuncName](string));
                };
                var segments = (string + "").split(_sep);
                for (var i = 0, length = segments.length; i < length; i++) segments[i] = actualCodingFunc(segments[i]);
                return segments.join(_sep);
            };
        };
        URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
        URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
        URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
        URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
        URI.encodeReserved = generateAccessor("reserved", "encode");
        URI.parse = function(string, parts) {
            var pos;
            if (!parts) parts = {};
            pos = string.indexOf("#");
            if (pos > -1) {
                parts.fragment = string.substring(pos + 1) || null;
                string = string.substring(0, pos);
            }
            pos = string.indexOf("?");
            if (pos > -1) {
                parts.query = string.substring(pos + 1) || null;
                string = string.substring(0, pos);
            }
            if ("//" === string.substring(0, 2)) {
                parts.protocol = null;
                string = string.substring(2);
                string = URI.parseAuthority(string, parts);
            } else {
                pos = string.indexOf(":");
                if (pos > -1) {
                    parts.protocol = string.substring(0, pos) || null;
                    if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) parts.protocol = void 0; else if ("//" === string.substring(pos + 1, pos + 3)) {
                        string = string.substring(pos + 3);
                        string = URI.parseAuthority(string, parts);
                    } else {
                        string = string.substring(pos + 1);
                        parts.urn = true;
                    }
                }
            }
            parts.path = string;
            return parts;
        };
        URI.parseHost = function(string, parts) {
            string = string.replace(/\\/g, "/");
            var pos = string.indexOf("/");
            var bracketPos;
            var t;
            if (pos === -1) pos = string.length;
            if ("[" === string.charAt(0)) {
                bracketPos = string.indexOf("]");
                parts.hostname = string.substring(1, bracketPos) || null;
                parts.port = string.substring(bracketPos + 2, pos) || null;
                if ("/" === parts.port) parts.port = null;
            } else {
                var firstColon = string.indexOf(":");
                var firstSlash = string.indexOf("/");
                var nextColon = string.indexOf(":", firstColon + 1);
                if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
                    parts.hostname = string.substring(0, pos) || null;
                    parts.port = null;
                } else {
                    t = string.substring(0, pos).split(":");
                    parts.hostname = t[0] || null;
                    parts.port = t[1] || null;
                }
            }
            if (parts.hostname && "/" !== string.substring(pos).charAt(0)) {
                pos++;
                string = "/" + string;
            }
            URI.ensureValidHostname(parts.hostname, parts.protocol);
            if (parts.port) URI.ensureValidPort(parts.port);
            return string.substring(pos) || "/";
        };
        URI.parseAuthority = function(string, parts) {
            string = URI.parseUserinfo(string, parts);
            return URI.parseHost(string, parts);
        };
        URI.parseUserinfo = function(string, parts) {
            var firstSlash = string.indexOf("/");
            var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
            var t;
            if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
                t = string.substring(0, pos).split(":");
                parts.username = t[0] ? URI.decode(t[0]) : null;
                t.shift();
                parts.password = t[0] ? URI.decode(t.join(":")) : null;
                string = string.substring(pos + 1);
            } else {
                parts.username = null;
                parts.password = null;
            }
            return string;
        };
        URI.parseQuery = function(string, escapeQuerySpace) {
            if (!string) return {};
            string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
            if (!string) return {};
            var items = {};
            var splits = string.split("&");
            var length = splits.length;
            var v, name, value;
            for (var i = 0; i < length; i++) {
                v = splits[i].split("=");
                name = URI.decodeQuery(v.shift(), escapeQuerySpace);
                value = v.length ? URI.decodeQuery(v.join("="), escapeQuerySpace) : null;
                if (hasOwn.call(items, name)) {
                    if ("string" === typeof items[name] || null === items[name]) items[name] = [ items[name] ];
                    items[name].push(value);
                } else items[name] = value;
            }
            return items;
        };
        URI.build = function(parts) {
            var t = "";
            if (parts.protocol) t += parts.protocol + ":";
            if (!parts.urn && (t || parts.hostname)) t += "//";
            t += URI.buildAuthority(parts) || "";
            if ("string" === typeof parts.path) {
                if ("/" !== parts.path.charAt(0) && "string" === typeof parts.hostname) t += "/";
                t += parts.path;
            }
            if ("string" === typeof parts.query && parts.query) t += "?" + parts.query;
            if ("string" === typeof parts.fragment && parts.fragment) t += "#" + parts.fragment;
            return t;
        };
        URI.buildHost = function(parts) {
            var t = "";
            if (!parts.hostname) return ""; else if (URI.ip6_expression.test(parts.hostname)) t += "[" + parts.hostname + "]"; else t += parts.hostname;
            if (parts.port) t += ":" + parts.port;
            return t;
        };
        URI.buildAuthority = function(parts) {
            return URI.buildUserinfo(parts) + URI.buildHost(parts);
        };
        URI.buildUserinfo = function(parts) {
            var t = "";
            if (parts.username) t += URI.encode(parts.username);
            if (parts.password) t += ":" + URI.encode(parts.password);
            if (t) t += "@";
            return t;
        };
        URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
            var t = "";
            var unique, key, i, length;
            for (key in data) if (hasOwn.call(data, key) && key) if (isArray(data[key])) {
                unique = {};
                for (i = 0, length = data[key].length; i < length; i++) if (void 0 !== data[key][i] && void 0 === unique[data[key][i] + ""]) {
                    t += "&" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                    if (true !== duplicateQueryParameters) unique[data[key][i] + ""] = true;
                }
            } else if (void 0 !== data[key]) t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
            return t.substring(1);
        };
        URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
            return URI.encodeQuery(name, escapeQuerySpace) + (null !== value ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
        };
        URI.addQuery = function(data, name, value) {
            if ("object" === typeof name) {
                for (var key in name) if (hasOwn.call(name, key)) URI.addQuery(data, key, name[key]);
            } else if ("string" === typeof name) {
                if (void 0 === data[name]) {
                    data[name] = value;
                    return;
                } else if ("string" === typeof data[name]) data[name] = [ data[name] ];
                if (!isArray(value)) value = [ value ];
                data[name] = (data[name] || []).concat(value);
            } else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        };
        URI.removeQuery = function(data, name, value) {
            var i, length, key;
            if (isArray(name)) for (i = 0, length = name.length; i < length; i++) data[name[i]] = void 0; else if ("RegExp" === getType(name)) {
                for (key in data) if (name.test(key)) data[key] = void 0;
            } else if ("object" === typeof name) {
                for (key in name) if (hasOwn.call(name, key)) URI.removeQuery(data, key, name[key]);
            } else if ("string" === typeof name) if (void 0 !== value) {
                if ("RegExp" === getType(value)) if (!isArray(data[name]) && value.test(data[name])) data[name] = void 0; else data[name] = filterArrayValues(data[name], value); else if (data[name] === String(value) && (!isArray(value) || 1 === value.length)) data[name] = void 0; else if (isArray(data[name])) data[name] = filterArrayValues(data[name], value);
            } else data[name] = void 0; else throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
        };
        URI.hasQuery = function(data, name, value, withinArray) {
            switch (getType(name)) {
              case "String":
                break;

              case "RegExp":
                for (var key in data) if (hasOwn.call(data, key)) if (name.test(key) && (void 0 === value || URI.hasQuery(data, key, value))) return true;
                return false;

              case "Object":
                for (var _key in name) if (hasOwn.call(name, _key)) if (!URI.hasQuery(data, _key, name[_key])) return false;
                return true;

              default:
                throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
            }
            switch (getType(value)) {
              case "Undefined":
                return name in data;

              case "Boolean":
                var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
                return value === _booly;

              case "Function":
                return !!value(data[name], name, data);

              case "Array":
                if (!isArray(data[name])) return false;
                var op = withinArray ? arrayContains : arraysEqual;
                return op(data[name], value);

              case "RegExp":
                if (!isArray(data[name])) return Boolean(data[name] && data[name].match(value));
                if (!withinArray) return false;
                return arrayContains(data[name], value);

              case "Number":
                value = String(value);

              case "String":
                if (!isArray(data[name])) return data[name] === value;
                if (!withinArray) return false;
                return arrayContains(data[name], value);

              default:
                throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
            }
        };
        URI.joinPaths = function() {
            var input = [];
            var segments = [];
            var nonEmptySegments = 0;
            for (var i = 0; i < arguments.length; i++) {
                var url = new URI(arguments[i]);
                input.push(url);
                var _segments = url.segment();
                for (var s = 0; s < _segments.length; s++) {
                    if ("string" === typeof _segments[s]) segments.push(_segments[s]);
                    if (_segments[s]) nonEmptySegments++;
                }
            }
            if (!segments.length || !nonEmptySegments) return new URI("");
            var uri = new URI("").segment(segments);
            if ("" === input[0].path() || "/" === input[0].path().slice(0, 1)) uri.path("/" + uri.path());
            return uri.normalize();
        };
        URI.commonPath = function(one, two) {
            var length = Math.min(one.length, two.length);
            var pos;
            for (pos = 0; pos < length; pos++) if (one.charAt(pos) !== two.charAt(pos)) {
                pos--;
                break;
            }
            if (pos < 1) return one.charAt(0) === two.charAt(0) && "/" === one.charAt(0) ? "/" : "";
            if ("/" !== one.charAt(pos) || "/" !== two.charAt(pos)) pos = one.substring(0, pos).lastIndexOf("/");
            return one.substring(0, pos + 1);
        };
        URI.withinString = function(string, callback, options) {
            options || (options = {});
            var _start = options.start || URI.findUri.start;
            var _end = options.end || URI.findUri.end;
            var _trim = options.trim || URI.findUri.trim;
            var _parens = options.parens || URI.findUri.parens;
            var _attributeOpen = /[a-z0-9-]=["']?$/i;
            _start.lastIndex = 0;
            while (true) {
                var match = _start.exec(string);
                if (!match) break;
                var start = match.index;
                if (options.ignoreHtml) {
                    var attributeOpen = string.slice(Math.max(start - 3, 0), start);
                    if (attributeOpen && _attributeOpen.test(attributeOpen)) continue;
                }
                var end = start + string.slice(start).search(_end);
                var slice = string.slice(start, end);
                var parensEnd = -1;
                while (true) {
                    var parensMatch = _parens.exec(slice);
                    if (!parensMatch) break;
                    var parensMatchEnd = parensMatch.index + parensMatch[0].length;
                    parensEnd = Math.max(parensEnd, parensMatchEnd);
                }
                if (parensEnd > -1) slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, ""); else slice = slice.replace(_trim, "");
                if (slice.length <= match[0].length) continue;
                if (options.ignore && options.ignore.test(slice)) continue;
                end = start + slice.length;
                var result = callback(slice, start, end, string);
                if (void 0 === result) {
                    _start.lastIndex = end;
                    continue;
                }
                result = String(result);
                string = string.slice(0, start) + result + string.slice(end);
                _start.lastIndex = start + result.length;
            }
            _start.lastIndex = 0;
            return string;
        };
        URI.ensureValidHostname = function(v, protocol) {
            var hasHostname = !!v;
            var hasProtocol = !!protocol;
            var rejectEmptyHostname = false;
            if (hasProtocol) rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
            if (rejectEmptyHostname && !hasHostname) throw new TypeError("Hostname cannot be empty, if protocol is " + protocol); else if (v && v.match(URI.invalid_hostname_characters)) {
                if (!punycode) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
                if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
            }
        };
        URI.ensureValidPort = function(v) {
            if (!v) return;
            var port = Number(v);
            if (isInteger(port) && port > 0 && port < 65536) return;
            throw new TypeError('Port "' + v + '" is not a valid port');
        };
        URI.noConflict = function(removeAll) {
            if (removeAll) {
                var unconflicted = {
                    URI: this.noConflict()
                };
                if (root.URITemplate && "function" === typeof root.URITemplate.noConflict) unconflicted.URITemplate = root.URITemplate.noConflict();
                if (root.IPv6 && "function" === typeof root.IPv6.noConflict) unconflicted.IPv6 = root.IPv6.noConflict();
                if (root.SecondLevelDomains && "function" === typeof root.SecondLevelDomains.noConflict) unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
                return unconflicted;
            } else if (root.URI === this) root.URI = _URI;
            return this;
        };
        p.build = function(deferBuild) {
            if (true === deferBuild) this._deferred_build = true; else if (void 0 === deferBuild || this._deferred_build) {
                this._string = URI.build(this._parts);
                this._deferred_build = false;
            }
            return this;
        };
        p.clone = function() {
            return new URI(this);
        };
        p.valueOf = p.toString = function() {
            return this.build(false)._string;
        };
        function generateSimpleAccessor(_part) {
            return function(v, build) {
                if (void 0 === v) return this._parts[_part] || ""; else {
                    this._parts[_part] = v || null;
                    this.build(!build);
                    return this;
                }
            };
        }
        function generatePrefixAccessor(_part, _key) {
            return function(v, build) {
                if (void 0 === v) return this._parts[_part] || ""; else {
                    if (null !== v) {
                        v += "";
                        if (v.charAt(0) === _key) v = v.substring(1);
                    }
                    this._parts[_part] = v;
                    this.build(!build);
                    return this;
                }
            };
        }
        p.protocol = generateSimpleAccessor("protocol");
        p.username = generateSimpleAccessor("username");
        p.password = generateSimpleAccessor("password");
        p.hostname = generateSimpleAccessor("hostname");
        p.port = generateSimpleAccessor("port");
        p.query = generatePrefixAccessor("query", "?");
        p.fragment = generatePrefixAccessor("fragment", "#");
        p.search = function(v, build) {
            var t = this.query(v, build);
            return "string" === typeof t && t.length ? "?" + t : t;
        };
        p.hash = function(v, build) {
            var t = this.fragment(v, build);
            return "string" === typeof t && t.length ? "#" + t : t;
        };
        p.pathname = function(v, build) {
            if (void 0 === v || true === v) {
                var res = this._parts.path || (this._parts.hostname ? "/" : "");
                return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
            } else {
                if (this._parts.urn) this._parts.path = v ? URI.recodeUrnPath(v) : ""; else this._parts.path = v ? URI.recodePath(v) : "/";
                this.build(!build);
                return this;
            }
        };
        p.path = p.pathname;
        p.href = function(href, build) {
            var key;
            if (void 0 === href) return this.toString();
            this._string = "";
            this._parts = URI._parts();
            var _URI = href instanceof URI;
            var _object = "object" === typeof href && (href.hostname || href.path || href.pathname);
            if (href.nodeName) {
                var attribute = URI.getDomAttribute(href);
                href = href[attribute] || "";
                _object = false;
            }
            if (!_URI && _object && void 0 !== href.pathname) href = href.toString();
            if ("string" === typeof href || href instanceof String) this._parts = URI.parse(String(href), this._parts); else if (_URI || _object) {
                var src = _URI ? href._parts : href;
                for (key in src) if (hasOwn.call(this._parts, key)) this._parts[key] = src[key];
            } else throw new TypeError("invalid input");
            this.build(!build);
            return this;
        };
        p.is = function(what) {
            var ip = false;
            var ip4 = false;
            var ip6 = false;
            var name = false;
            var sld = false;
            var idn = false;
            var punycode = false;
            var relative = !this._parts.urn;
            if (this._parts.hostname) {
                relative = false;
                ip4 = URI.ip4_expression.test(this._parts.hostname);
                ip6 = URI.ip6_expression.test(this._parts.hostname);
                ip = ip4 || ip6;
                name = !ip;
                sld = name && SLD && SLD.has(this._parts.hostname);
                idn = name && URI.idn_expression.test(this._parts.hostname);
                punycode = name && URI.punycode_expression.test(this._parts.hostname);
            }
            switch (what.toLowerCase()) {
              case "relative":
                return relative;

              case "absolute":
                return !relative;

              case "domain":
              case "name":
                return name;

              case "sld":
                return sld;

              case "ip":
                return ip;

              case "ip4":
              case "ipv4":
              case "inet4":
                return ip4;

              case "ip6":
              case "ipv6":
              case "inet6":
                return ip6;

              case "idn":
                return idn;

              case "url":
                return !this._parts.urn;

              case "urn":
                return !!this._parts.urn;

              case "punycode":
                return punycode;
            }
            return null;
        };
        var _protocol = p.protocol;
        var _port = p.port;
        var _hostname = p.hostname;
        p.protocol = function(v, build) {
            if (void 0 !== v) if (v) {
                v = v.replace(/:(\/\/)?$/, "");
                if (!v.match(URI.protocol_expression)) throw new TypeError('Protocol "' + v + "\" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]");
            }
            return _protocol.call(this, v, build);
        };
        p.scheme = p.protocol;
        p.port = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 !== v) {
                if (0 === v) v = null;
                if (v) {
                    v += "";
                    if (":" === v.charAt(0)) v = v.substring(1);
                    URI.ensureValidPort(v);
                }
            }
            return _port.call(this, v, build);
        };
        p.hostname = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 !== v) {
                var x = {};
                var res = URI.parseHost(v, x);
                if ("/" !== res) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                v = x.hostname;
                URI.ensureValidHostname(v, this._parts.protocol);
            }
            return _hostname.call(this, v, build);
        };
        p.origin = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 === v) {
                var protocol = this.protocol();
                var authority = this.authority();
                if (!authority) return "";
                return (protocol ? protocol + "://" : "") + this.authority();
            } else {
                var origin = URI(v);
                this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
                return this;
            }
        };
        p.host = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 === v) return this._parts.hostname ? URI.buildHost(this._parts) : ""; else {
                var res = URI.parseHost(v, this._parts);
                if ("/" !== res) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                this.build(!build);
                return this;
            }
        };
        p.authority = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 === v) return this._parts.hostname ? URI.buildAuthority(this._parts) : ""; else {
                var res = URI.parseAuthority(v, this._parts);
                if ("/" !== res) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                this.build(!build);
                return this;
            }
        };
        p.userinfo = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 === v) {
                var t = URI.buildUserinfo(this._parts);
                return t ? t.substring(0, t.length - 1) : t;
            } else {
                if ("@" !== v[v.length - 1]) v += "@";
                URI.parseUserinfo(v, this._parts);
                this.build(!build);
                return this;
            }
        };
        p.resource = function(v, build) {
            var parts;
            if (void 0 === v) return this.path() + this.search() + this.hash();
            parts = URI.parse(v);
            this._parts.path = parts.path;
            this._parts.query = parts.query;
            this._parts.fragment = parts.fragment;
            this.build(!build);
            return this;
        };
        p.subdomain = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 === v) {
                if (!this._parts.hostname || this.is("IP")) return "";
                var end = this._parts.hostname.length - this.domain().length - 1;
                return this._parts.hostname.substring(0, end) || "";
            } else {
                var e = this._parts.hostname.length - this.domain().length;
                var sub = this._parts.hostname.substring(0, e);
                var replace = new RegExp("^" + escapeRegEx(sub));
                if (v && "." !== v.charAt(v.length - 1)) v += ".";
                if (v.indexOf(":") !== -1) throw new TypeError("Domains cannot contain colons");
                if (v) URI.ensureValidHostname(v, this._parts.protocol);
                this._parts.hostname = this._parts.hostname.replace(replace, v);
                this.build(!build);
                return this;
            }
        };
        p.domain = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if ("boolean" === typeof v) {
                build = v;
                v = void 0;
            }
            if (void 0 === v) {
                if (!this._parts.hostname || this.is("IP")) return "";
                var t = this._parts.hostname.match(/\./g);
                if (t && t.length < 2) return this._parts.hostname;
                var end = this._parts.hostname.length - this.tld(build).length - 1;
                end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
                return this._parts.hostname.substring(end) || "";
            } else {
                if (!v) throw new TypeError("cannot set domain empty");
                if (v.indexOf(":") !== -1) throw new TypeError("Domains cannot contain colons");
                URI.ensureValidHostname(v, this._parts.protocol);
                if (!this._parts.hostname || this.is("IP")) this._parts.hostname = v; else {
                    var replace = new RegExp(escapeRegEx(this.domain()) + "$");
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                }
                this.build(!build);
                return this;
            }
        };
        p.tld = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if ("boolean" === typeof v) {
                build = v;
                v = void 0;
            }
            if (void 0 === v) {
                if (!this._parts.hostname || this.is("IP")) return "";
                var pos = this._parts.hostname.lastIndexOf(".");
                var tld = this._parts.hostname.substring(pos + 1);
                if (true !== build && SLD && SLD.list[tld.toLowerCase()]) return SLD.get(this._parts.hostname) || tld;
                return tld;
            } else {
                var replace;
                if (!v) throw new TypeError("cannot set TLD empty"); else if (v.match(/[^a-zA-Z0-9-]/)) if (SLD && SLD.is(v)) {
                    replace = new RegExp(escapeRegEx(this.tld()) + "$");
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                } else throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]'); else if (!this._parts.hostname || this.is("IP")) throw new ReferenceError("cannot set TLD on non-domain host"); else {
                    replace = new RegExp(escapeRegEx(this.tld()) + "$");
                    this._parts.hostname = this._parts.hostname.replace(replace, v);
                }
                this.build(!build);
                return this;
            }
        };
        p.directory = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 === v || true === v) {
                if (!this._parts.path && !this._parts.hostname) return "";
                if ("/" === this._parts.path) return "/";
                var end = this._parts.path.length - this.filename().length - 1;
                var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
                return v ? URI.decodePath(res) : res;
            } else {
                var e = this._parts.path.length - this.filename().length;
                var directory = this._parts.path.substring(0, e);
                var replace = new RegExp("^" + escapeRegEx(directory));
                if (!this.is("relative")) {
                    if (!v) v = "/";
                    if ("/" !== v.charAt(0)) v = "/" + v;
                }
                if (v && "/" !== v.charAt(v.length - 1)) v += "/";
                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);
                this.build(!build);
                return this;
            }
        };
        p.filename = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if ("string" !== typeof v) {
                if (!this._parts.path || "/" === this._parts.path) return "";
                var pos = this._parts.path.lastIndexOf("/");
                var res = this._parts.path.substring(pos + 1);
                return v ? URI.decodePathSegment(res) : res;
            } else {
                var mutatedDirectory = false;
                if ("/" === v.charAt(0)) v = v.substring(1);
                if (v.match(/\.?\//)) mutatedDirectory = true;
                var replace = new RegExp(escapeRegEx(this.filename()) + "$");
                v = URI.recodePath(v);
                this._parts.path = this._parts.path.replace(replace, v);
                if (mutatedDirectory) this.normalizePath(build); else this.build(!build);
                return this;
            }
        };
        p.suffix = function(v, build) {
            if (this._parts.urn) return void 0 === v ? "" : this;
            if (void 0 === v || true === v) {
                if (!this._parts.path || "/" === this._parts.path) return "";
                var filename = this.filename();
                var pos = filename.lastIndexOf(".");
                var s, res;
                if (pos === -1) return "";
                s = filename.substring(pos + 1);
                res = /^[a-z0-9%]+$/i.test(s) ? s : "";
                return v ? URI.decodePathSegment(res) : res;
            } else {
                if ("." === v.charAt(0)) v = v.substring(1);
                var suffix = this.suffix();
                var replace;
                if (!suffix) {
                    if (!v) return this;
                    this._parts.path += "." + URI.recodePath(v);
                } else if (!v) replace = new RegExp(escapeRegEx("." + suffix) + "$"); else replace = new RegExp(escapeRegEx(suffix) + "$");
                if (replace) {
                    v = URI.recodePath(v);
                    this._parts.path = this._parts.path.replace(replace, v);
                }
                this.build(!build);
                return this;
            }
        };
        p.segment = function(segment, v, build) {
            var separator = this._parts.urn ? ":" : "/";
            var path = this.path();
            var absolute = "/" === path.substring(0, 1);
            var segments = path.split(separator);
            if (void 0 !== segment && "number" !== typeof segment) {
                build = v;
                v = segment;
                segment = void 0;
            }
            if (void 0 !== segment && "number" !== typeof segment) throw new Error('Bad segment "' + segment + '", must be 0-based integer');
            if (absolute) segments.shift();
            if (segment < 0) segment = Math.max(segments.length + segment, 0);
            if (void 0 === v) return void 0 === segment ? segments : segments[segment]; else if (null === segment || void 0 === segments[segment]) {
                if (isArray(v)) {
                    segments = [];
                    for (var i = 0, l = v.length; i < l; i++) {
                        if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) continue;
                        if (segments.length && !segments[segments.length - 1].length) segments.pop();
                        segments.push(trimSlashes(v[i]));
                    }
                } else if (v || "string" === typeof v) {
                    v = trimSlashes(v);
                    if ("" === segments[segments.length - 1]) segments[segments.length - 1] = v; else segments.push(v);
                }
            } else if (v) segments[segment] = trimSlashes(v); else segments.splice(segment, 1);
            if (absolute) segments.unshift("");
            return this.path(segments.join(separator), build);
        };
        p.segmentCoded = function(segment, v, build) {
            var segments, i, l;
            if ("number" !== typeof segment) {
                build = v;
                v = segment;
                segment = void 0;
            }
            if (void 0 === v) {
                segments = this.segment(segment, v, build);
                if (!isArray(segments)) segments = void 0 !== segments ? URI.decode(segments) : void 0; else for (i = 0, 
                l = segments.length; i < l; i++) segments[i] = URI.decode(segments[i]);
                return segments;
            }
            if (!isArray(v)) v = "string" === typeof v || v instanceof String ? URI.encode(v) : v; else for (i = 0, 
            l = v.length; i < l; i++) v[i] = URI.encode(v[i]);
            return this.segment(segment, v, build);
        };
        var q = p.query;
        p.query = function(v, build) {
            if (true === v) return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace); else if ("function" === typeof v) {
                var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                var result = v.call(this, data);
                this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
                this.build(!build);
                return this;
            } else if (void 0 !== v && "string" !== typeof v) {
                this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
                this.build(!build);
                return this;
            } else return q.call(this, v, build);
        };
        p.setQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            if ("string" === typeof name || name instanceof String) data[name] = void 0 !== value ? value : null; else if ("object" === typeof name) {
                for (var key in name) if (hasOwn.call(name, key)) data[key] = name[key];
            } else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if ("string" !== typeof name) build = value;
            this.build(!build);
            return this;
        };
        p.addQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            URI.addQuery(data, name, void 0 === value ? null : value);
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if ("string" !== typeof name) build = value;
            this.build(!build);
            return this;
        };
        p.removeQuery = function(name, value, build) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            URI.removeQuery(data, name, value);
            this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            if ("string" !== typeof name) build = value;
            this.build(!build);
            return this;
        };
        p.hasQuery = function(name, value, withinArray) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return URI.hasQuery(data, name, value, withinArray);
        };
        p.setSearch = p.setQuery;
        p.addSearch = p.addQuery;
        p.removeSearch = p.removeQuery;
        p.hasSearch = p.hasQuery;
        p.normalize = function() {
            if (this._parts.urn) return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
            return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        };
        p.normalizeProtocol = function(build) {
            if ("string" === typeof this._parts.protocol) {
                this._parts.protocol = this._parts.protocol.toLowerCase();
                this.build(!build);
            }
            return this;
        };
        p.normalizeHostname = function(build) {
            if (this._parts.hostname) {
                if (this.is("IDN") && punycode) this._parts.hostname = punycode.toASCII(this._parts.hostname); else if (this.is("IPv6") && IPv6) this._parts.hostname = IPv6.best(this._parts.hostname);
                this._parts.hostname = this._parts.hostname.toLowerCase();
                this.build(!build);
            }
            return this;
        };
        p.normalizePort = function(build) {
            if ("string" === typeof this._parts.protocol && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
                this._parts.port = null;
                this.build(!build);
            }
            return this;
        };
        p.normalizePath = function(build) {
            var _path = this._parts.path;
            if (!_path) return this;
            if (this._parts.urn) {
                this._parts.path = URI.recodeUrnPath(this._parts.path);
                this.build(!build);
                return this;
            }
            if ("/" === this._parts.path) return this;
            _path = URI.recodePath(_path);
            var _was_relative;
            var _leadingParents = "";
            var _parent, _pos;
            if ("/" !== _path.charAt(0)) {
                _was_relative = true;
                _path = "/" + _path;
            }
            if ("/.." === _path.slice(-3) || "/." === _path.slice(-2)) _path += "/";
            _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
            if (_was_relative) {
                _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
                if (_leadingParents) _leadingParents = _leadingParents[0];
            }
            while (true) {
                _parent = _path.search(/\/\.\.(\/|$)/);
                if (_parent === -1) break; else if (0 === _parent) {
                    _path = _path.substring(3);
                    continue;
                }
                _pos = _path.substring(0, _parent).lastIndexOf("/");
                if (_pos === -1) _pos = _parent;
                _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
            }
            if (_was_relative && this.is("relative")) _path = _leadingParents + _path.substring(1);
            this._parts.path = _path;
            this.build(!build);
            return this;
        };
        p.normalizePathname = p.normalizePath;
        p.normalizeQuery = function(build) {
            if ("string" === typeof this._parts.query) {
                if (!this._parts.query.length) this._parts.query = null; else this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
                this.build(!build);
            }
            return this;
        };
        p.normalizeFragment = function(build) {
            if (!this._parts.fragment) {
                this._parts.fragment = null;
                this.build(!build);
            }
            return this;
        };
        p.normalizeSearch = p.normalizeQuery;
        p.normalizeHash = p.normalizeFragment;
        p.iso8859 = function() {
            var e = URI.encode;
            var d = URI.decode;
            URI.encode = escape;
            URI.decode = decodeURIComponent;
            try {
                this.normalize();
            } finally {
                URI.encode = e;
                URI.decode = d;
            }
            return this;
        };
        p.unicode = function() {
            var e = URI.encode;
            var d = URI.decode;
            URI.encode = strictEncodeURIComponent;
            URI.decode = unescape;
            try {
                this.normalize();
            } finally {
                URI.encode = e;
                URI.decode = d;
            }
            return this;
        };
        p.readable = function() {
            var uri = this.clone();
            uri.username("").password("").normalize();
            var t = "";
            if (uri._parts.protocol) t += uri._parts.protocol + "://";
            if (uri._parts.hostname) if (uri.is("punycode") && punycode) {
                t += punycode.toUnicode(uri._parts.hostname);
                if (uri._parts.port) t += ":" + uri._parts.port;
            } else t += uri.host();
            if (uri._parts.hostname && uri._parts.path && "/" !== uri._parts.path.charAt(0)) t += "/";
            t += uri.path(true);
            if (uri._parts.query) {
                var q = "";
                for (var i = 0, qp = uri._parts.query.split("&"), l = qp.length; i < l; i++) {
                    var kv = (qp[i] || "").split("=");
                    q += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
                    if (void 0 !== kv[1]) q += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
                }
                t += "?" + q.substring(1);
            }
            t += URI.decodeQuery(uri.hash(), true);
            return t;
        };
        p.absoluteTo = function(base) {
            var resolved = this.clone();
            var properties = [ "protocol", "username", "password", "hostname", "port" ];
            var basedir, i, p;
            if (this._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
            if (!(base instanceof URI)) base = new URI(base);
            if (resolved._parts.protocol) return resolved; else resolved._parts.protocol = base._parts.protocol;
            if (this._parts.hostname) return resolved;
            for (i = 0; p = properties[i]; i++) resolved._parts[p] = base._parts[p];
            if (!resolved._parts.path) {
                resolved._parts.path = base._parts.path;
                if (!resolved._parts.query) resolved._parts.query = base._parts.query;
            } else {
                if (".." === resolved._parts.path.substring(-2)) resolved._parts.path += "/";
                if ("/" !== resolved.path().charAt(0)) {
                    basedir = base.directory();
                    basedir = basedir ? basedir : 0 === base.path().indexOf("/") ? "/" : "";
                    resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
                    resolved.normalizePath();
                }
            }
            resolved.build();
            return resolved;
        };
        p.relativeTo = function(base) {
            var relative = this.clone().normalize();
            var relativeParts, baseParts, common, relativePath, basePath;
            if (relative._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
            base = new URI(base).normalize();
            relativeParts = relative._parts;
            baseParts = base._parts;
            relativePath = relative.path();
            basePath = base.path();
            if ("/" !== relativePath.charAt(0)) throw new Error("URI is already relative");
            if ("/" !== basePath.charAt(0)) throw new Error("Cannot calculate a URI relative to another relative URI");
            if (relativeParts.protocol === baseParts.protocol) relativeParts.protocol = null;
            if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) return relative.build();
            if (null !== relativeParts.protocol || null !== relativeParts.username || null !== relativeParts.password) return relative.build();
            if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
                relativeParts.hostname = null;
                relativeParts.port = null;
            } else return relative.build();
            if (relativePath === basePath) {
                relativeParts.path = "";
                return relative.build();
            }
            common = URI.commonPath(relativePath, basePath);
            if (!common) return relative.build();
            var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
            relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
            return relative.build();
        };
        p.equals = function(uri) {
            var one = this.clone();
            var two = new URI(uri);
            var one_map = {};
            var two_map = {};
            var checked = {};
            var one_query, two_query, key;
            one.normalize();
            two.normalize();
            if (one.toString() === two.toString()) return true;
            one_query = one.query();
            two_query = two.query();
            one.query("");
            two.query("");
            if (one.toString() !== two.toString()) return false;
            if (one_query.length !== two_query.length) return false;
            one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
            two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
            for (key in one_map) if (hasOwn.call(one_map, key)) {
                if (!isArray(one_map[key])) {
                    if (one_map[key] !== two_map[key]) return false;
                } else if (!arraysEqual(one_map[key], two_map[key])) return false;
                checked[key] = true;
            }
            for (key in two_map) if (hasOwn.call(two_map, key)) if (!checked[key]) return false;
            return true;
        };
        p.duplicateQueryParameters = function(v) {
            this._parts.duplicateQueryParameters = !!v;
            return this;
        };
        p.escapeQuerySpace = function(v) {
            this._parts.escapeQuerySpace = !!v;
            return this;
        };
        return URI;
    });
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    (function(module, global) {
        !function(root) {
            var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports;
            var freeModule = "object" == typeof module && module && !module.nodeType && module;
            var freeGlobal = "object" == typeof global && global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) root = freeGlobal;
            var punycode, key, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode;
            function error(type) {
                throw new RangeError(errors[type]);
            }
            function map(array, fn) {
                var length = array.length;
                var result = [];
                while (length--) result[length] = fn(array[length]);
                return result;
            }
            function mapDomain(string, fn) {
                var parts = string.split("@");
                var result = "";
                if (parts.length > 1) {
                    result = parts[0] + "@";
                    string = parts[1];
                }
                string = string.replace(regexSeparators, ".");
                var labels = string.split(".");
                var encoded = map(labels, fn).join(".");
                return result + encoded;
            }
            function ucs2decode(string) {
                var value, extra, output = [], counter = 0, length = string.length;
                while (counter < length) {
                    value = string.charCodeAt(counter++);
                    if (value >= 55296 && value <= 56319 && counter < length) {
                        extra = string.charCodeAt(counter++);
                        if (56320 == (64512 & extra)) output.push(((1023 & value) << 10) + (1023 & extra) + 65536); else {
                            output.push(value);
                            counter--;
                        }
                    } else output.push(value);
                }
                return output;
            }
            function ucs2encode(array) {
                return map(array, function(value) {
                    var output = "";
                    if (value > 65535) {
                        value -= 65536;
                        output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                        value = 56320 | 1023 & value;
                    }
                    output += stringFromCharCode(value);
                    return output;
                }).join("");
            }
            function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) return codePoint - 22;
                if (codePoint - 65 < 26) return codePoint - 65;
                if (codePoint - 97 < 26) return codePoint - 97;
                return base;
            }
            function digitToBasic(digit, flag) {
                return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
            }
            function adapt(delta, numPoints, firstTime) {
                var k = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for (;delta > baseMinusTMin * tMax >> 1; k += base) delta = floor(delta / baseMinusTMin);
                return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }
            function decode(input) {
                var out, basic, j, index, oldi, w, k, digit, t, baseMinusT, output = [], inputLength = input.length, i = 0, n = initialN, bias = initialBias;
                basic = input.lastIndexOf(delimiter);
                if (basic < 0) basic = 0;
                for (j = 0; j < basic; ++j) {
                    if (input.charCodeAt(j) >= 128) error("not-basic");
                    output.push(input.charCodeAt(j));
                }
                for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                    for (oldi = i, w = 1, k = base; ;k += base) {
                        if (index >= inputLength) error("invalid-input");
                        digit = basicToDigit(input.charCodeAt(index++));
                        if (digit >= base || digit > floor((maxInt - i) / w)) error("overflow");
                        i += digit * w;
                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (digit < t) break;
                        baseMinusT = base - t;
                        if (w > floor(maxInt / baseMinusT)) error("overflow");
                        w *= baseMinusT;
                    }
                    out = output.length + 1;
                    bias = adapt(i - oldi, out, 0 == oldi);
                    if (floor(i / out) > maxInt - n) error("overflow");
                    n += floor(i / out);
                    i %= out;
                    output.splice(i++, 0, n);
                }
                return ucs2encode(output);
            }
            function encode(input) {
                var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, inputLength, handledCPCountPlusOne, baseMinusT, qMinusT, output = [];
                input = ucs2decode(input);
                inputLength = input.length;
                n = initialN;
                delta = 0;
                bias = initialBias;
                for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < 128) output.push(stringFromCharCode(currentValue));
                }
                handledCPCount = basicLength = output.length;
                if (basicLength) output.push(delimiter);
                while (handledCPCount < inputLength) {
                    for (m = maxInt, j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue >= n && currentValue < m) m = currentValue;
                    }
                    handledCPCountPlusOne = handledCPCount + 1;
                    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) error("overflow");
                    delta += (m - n) * handledCPCountPlusOne;
                    n = m;
                    for (j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue < n && ++delta > maxInt) error("overflow");
                        if (currentValue == n) {
                            for (q = delta, k = base; ;k += base) {
                                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                if (q < t) break;
                                qMinusT = q - t;
                                baseMinusT = base - t;
                                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                q = floor(qMinusT / baseMinusT);
                            }
                            output.push(stringFromCharCode(digitToBasic(q, 0)));
                            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                            delta = 0;
                            ++handledCPCount;
                        }
                    }
                    ++delta;
                    ++n;
                }
                return output.join("");
            }
            function toUnicode(input) {
                return mapDomain(input, function(string) {
                    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                });
            }
            function toASCII(input) {
                return mapDomain(input, function(string) {
                    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                });
            }
            punycode = {
                version: "1.3.2",
                ucs2: {
                    decode: ucs2decode,
                    encode: ucs2encode
                },
                decode: decode,
                encode: encode,
                toASCII: toASCII,
                toUnicode: toUnicode
            };
            if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return punycode;
            }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (freeExports && freeModule) if (module.exports == freeExports) freeModule.exports = punycode; else for (key in punycode) punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]); else root.punycode = punycode;
        }(this);
    }).call(exports, __webpack_require__(35)(module), function() {
        return this;
    }());
}, function(module, exports) {
    module.exports = function(module) {
        if (!module.webpackPolyfill) {
            module.deprecate = function() {};
            module.paths = [];
            module.children = [];
            module.webpackPolyfill = 1;
        }
        return module;
    };
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
    !function(root, factory) {
        "use strict";
        if ("object" === typeof module && module.exports) module.exports = factory(); else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = factory, 
        __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, 
        void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else root.IPv6 = factory(root);
    }(this, function(root) {
        "use strict";
        var _IPv6 = root && root.IPv6;
        function bestPresentation(address) {
            var _address = address.toLowerCase();
            var segments = _address.split(":");
            var length = segments.length;
            var total = 8;
            if ("" === segments[0] && "" === segments[1] && "" === segments[2]) {
                segments.shift();
                segments.shift();
            } else if ("" === segments[0] && "" === segments[1]) segments.shift(); else if ("" === segments[length - 1] && "" === segments[length - 2]) segments.pop();
            length = segments.length;
            if (segments[length - 1].indexOf(".") !== -1) total = 7;
            var pos;
            for (pos = 0; pos < length; pos++) if ("" === segments[pos]) break;
            if (pos < total) {
                segments.splice(pos, 1, "0000");
                while (segments.length < total) segments.splice(pos, 0, "0000");
            }
            var _segments;
            for (var i = 0; i < total; i++) {
                _segments = segments[i].split("");
                for (var j = 0; j < 3; j++) if ("0" === _segments[0] && _segments.length > 1) _segments.splice(0, 1); else break;
                segments[i] = _segments.join("");
            }
            var best = -1;
            var _best = 0;
            var _current = 0;
            var current = -1;
            var inzeroes = false;
            for (i = 0; i < total; i++) if (inzeroes) if ("0" === segments[i]) _current += 1; else {
                inzeroes = false;
                if (_current > _best) {
                    best = current;
                    _best = _current;
                }
            } else if ("0" === segments[i]) {
                inzeroes = true;
                current = i;
                _current = 1;
            }
            if (_current > _best) {
                best = current;
                _best = _current;
            }
            if (_best > 1) segments.splice(best, _best, "");
            length = segments.length;
            var result = "";
            if ("" === segments[0]) result = ":";
            for (i = 0; i < length; i++) {
                result += segments[i];
                if (i === length - 1) break;
                result += ":";
            }
            if ("" === segments[length - 1]) result += ":";
            return result;
        }
        function noConflict() {
            if (root.IPv6 === this) root.IPv6 = _IPv6;
            return this;
        }
        return {
            best: bestPresentation,
            noConflict: noConflict
        };
    });
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
    !function(root, factory) {
        "use strict";
        if ("object" === typeof module && module.exports) module.exports = factory(); else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = factory, 
        __WEBPACK_AMD_DEFINE_RESULT__ = "function" === typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module) : __WEBPACK_AMD_DEFINE_FACTORY__, 
        void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else root.SecondLevelDomains = factory(root);
    }(this, function(root) {
        "use strict";
        var _SecondLevelDomains = root && root.SecondLevelDomains;
        var SLD = {
            list: {
                ac: " com gov mil net org ",
                ae: " ac co gov mil name net org pro sch ",
                af: " com edu gov net org ",
                al: " com edu gov mil net org ",
                ao: " co ed gv it og pb ",
                ar: " com edu gob gov int mil net org tur ",
                at: " ac co gv or ",
                au: " asn com csiro edu gov id net org ",
                ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ",
                bb: " biz co com edu gov info net org store tv ",
                bh: " biz cc com edu gov info net org ",
                bn: " com edu gov net org ",
                bo: " com edu gob gov int mil net org tv ",
                br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
                bs: " com edu gov net org ",
                bz: " du et om ov rg ",
                ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
                ck: " biz co edu gen gov info net org ",
                cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
                co: " com edu gov mil net nom org ",
                cr: " ac c co ed fi go or sa ",
                cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ",
                do: " art com edu gob gov mil net org sld web ",
                dz: " art asso com edu gov net org pol ",
                ec: " com edu fin gov info med mil net org pro ",
                eg: " com edu eun gov mil name net org sci ",
                er: " com edu gov ind mil net org rochest w ",
                es: " com edu gob nom org ",
                et: " biz com edu gov info name net org ",
                fj: " ac biz com info mil name net org pro ",
                fk: " ac co gov net nom org ",
                fr: " asso com f gouv nom prd presse tm ",
                gg: " co net org ",
                gh: " com edu gov mil org ",
                gn: " ac com gov net org ",
                gr: " com edu gov mil net org ",
                gt: " com edu gob ind mil net org ",
                gu: " com edu gov net org ",
                hk: " com edu gov idv net org ",
                hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
                id: " ac co go mil net or sch web ",
                il: " ac co gov idf k12 muni net org ",
                in: " ac co edu ernet firm gen gov i ind mil net nic org res ",
                iq: " com edu gov i mil net org ",
                ir: " ac co dnssec gov i id net org sch ",
                it: " edu gov ",
                je: " co net org ",
                jo: " com edu gov mil name net org sch ",
                jp: " ac ad co ed go gr lg ne or ",
                ke: " ac co go info me mobi ne or sc ",
                kh: " com edu gov mil net org per ",
                ki: " biz com de edu gov info mob net org tel ",
                km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
                kn: " edu gov net org ",
                kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
                kw: " com edu gov net org ",
                ky: " com edu gov net org ",
                kz: " com edu gov mil net org ",
                lb: " com edu gov net org ",
                lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
                lr: " com edu gov net org ",
                lv: " asn com conf edu gov id mil net org ",
                ly: " com edu gov id med net org plc sch ",
                ma: " ac co gov m net org press ",
                mc: " asso tm ",
                me: " ac co edu gov its net org priv ",
                mg: " com edu gov mil nom org prd tm ",
                mk: " com edu gov inf name net org pro ",
                ml: " com edu gov net org presse ",
                mn: " edu gov org ",
                mo: " com edu gov net org ",
                mt: " com edu gov net org ",
                mv: " aero biz com coop edu gov info int mil museum name net org pro ",
                mw: " ac co com coop edu gov int museum net org ",
                mx: " com edu gob net org ",
                my: " com edu gov mil name net org sch ",
                nf: " arts com firm info net other per rec store web ",
                ng: " biz com edu gov mil mobi name net org sch ",
                ni: " ac co com edu gob mil net nom org ",
                np: " com edu gov mil net org ",
                nr: " biz com edu gov info net org ",
                om: " ac biz co com edu gov med mil museum net org pro sch ",
                pe: " com edu gob mil net nom org sld ",
                ph: " com edu gov i mil net ngo org ",
                pk: " biz com edu fam gob gok gon gop gos gov net org web ",
                pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
                pr: " ac biz com edu est gov info isla name net org pro prof ",
                ps: " com edu gov net org plo sec ",
                pw: " belau co ed go ne or ",
                ro: " arts com firm info nom nt org rec store tm www ",
                rs: " ac co edu gov in org ",
                sb: " com edu gov net org ",
                sc: " com edu gov net org ",
                sh: " co com edu gov net nom org ",
                sl: " com edu gov net org ",
                st: " co com consulado edu embaixada gov mil net org principe saotome store ",
                sv: " com edu gob org red ",
                sz: " ac co org ",
                tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
                tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
                tw: " club com ebiz edu game gov idv mil net org ",
                mu: " ac co com gov net or org ",
                mz: " ac co edu gov org ",
                na: " co com ",
                nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ",
                pa: " abo ac com edu gob ing med net nom org sld ",
                pt: " com edu gov int net nome org publ ",
                py: " com edu gov mil net org ",
                qa: " com edu gov mil net org ",
                re: " asso com nom ",
                ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
                rw: " ac co com edu gouv gov int mil net ",
                sa: " com edu gov med net org pub sch ",
                sd: " com edu gov info med net org tv ",
                se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
                sg: " com edu gov idn net org per ",
                sn: " art com edu gouv org perso univ ",
                sy: " com edu gov mil net news org ",
                th: " ac co go in mi net or ",
                tj: " ac biz co com edu go gov info int mil name net nic org test web ",
                tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
                tz: " ac co go ne or ",
                ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
                ug: " ac co go ne or org sc ",
                uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
                us: " dni fed isa kids nsn ",
                uy: " com edu gub mil net org ",
                ve: " co com edu gob info mil net org web ",
                vi: " co com k12 net org ",
                vn: " ac biz com edu gov health info int name net org pro ",
                ye: " co com gov ltd me net org plc ",
                yu: " ac co edu gov org ",
                za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
                zm: " ac co com edu gov net org sch ",
                com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
                net: "gb jp se uk ",
                org: "ae",
                de: "com "
            },
            has: function(domain) {
                var tldOffset = domain.lastIndexOf(".");
                if (tldOffset <= 0 || tldOffset >= domain.length - 1) return false;
                var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
                if (sldOffset <= 0 || sldOffset >= tldOffset - 1) return false;
                var sldList = SLD.list[domain.slice(tldOffset + 1)];
                if (!sldList) return false;
                return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
            },
            is: function(domain) {
                var tldOffset = domain.lastIndexOf(".");
                if (tldOffset <= 0 || tldOffset >= domain.length - 1) return false;
                var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
                if (sldOffset >= 0) return false;
                var sldList = SLD.list[domain.slice(tldOffset + 1)];
                if (!sldList) return false;
                return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
            },
            get: function(domain) {
                var tldOffset = domain.lastIndexOf(".");
                if (tldOffset <= 0 || tldOffset >= domain.length - 1) return null;
                var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
                if (sldOffset <= 0 || sldOffset >= tldOffset - 1) return null;
                var sldList = SLD.list[domain.slice(tldOffset + 1)];
                if (!sldList) return null;
                if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) return null;
                return domain.slice(sldOffset + 1);
            },
            noConflict: function() {
                if (root.SecondLevelDomains === this) root.SecondLevelDomains = _SecondLevelDomains;
                return this;
            }
        };
        return SLD;
    });
}, function(module, exports) {
    "use strict";
    var xhrUtils = {};
    xhrUtils.isInformal = function(code) {
        return code >= 100 && code < 200;
    };
    xhrUtils.isSuccess = function(code) {
        return code >= 200 && code < 300;
    };
    xhrUtils.isRedirect = function(code) {
        return code >= 300 && code < 400;
    };
    xhrUtils.isClientError = function(code) {
        return code >= 400 && code < 500;
    };
    xhrUtils.isServerError = function(code) {
        return code >= 500 && code < 600;
    };
    xhrUtils.isNetworkError = function(code) {
        return 0 === code;
    };
    xhrUtils.isError = function(code) {
        return this.isServerError(code) || this.isClientError(code) || this.isNetworkError(code);
    };
    module.exports = xhrUtils;
}, function(module, exports, __webpack_require__) {
    var baseForIn = __webpack_require__(40), isArguments = __webpack_require__(46), isObjectLike = __webpack_require__(51);
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objToString = objectProto.toString;
    function isPlainObject(value) {
        var Ctor;
        if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || !hasOwnProperty.call(value, "constructor") && (Ctor = value.constructor, 
        "function" == typeof Ctor && !(Ctor instanceof Ctor))) return false;
        var result;
        baseForIn(value, function(subValue, key) {
            result = key;
        });
        return void 0 === result || hasOwnProperty.call(value, result);
    }
    module.exports = isPlainObject;
}, function(module, exports, __webpack_require__) {
    var baseFor = __webpack_require__(41), keysIn = __webpack_require__(45);
    function baseForIn(object, iteratee) {
        return baseFor(object, iteratee, keysIn);
    }
    module.exports = baseForIn;
}, function(module, exports, __webpack_require__) {
    var createBaseFor = __webpack_require__(42);
    var baseFor = createBaseFor();
    module.exports = baseFor;
}, function(module, exports, __webpack_require__) {
    var toObject = __webpack_require__(43);
    function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
            var iterable = toObject(object), props = keysFunc(object), length = props.length, index = fromRight ? length : -1;
            while (fromRight ? index-- : ++index < length) {
                var key = props[index];
                if (false === iteratee(iterable[key], key, iterable)) break;
            }
            return object;
        };
    }
    module.exports = createBaseFor;
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(44);
    function toObject(value) {
        return isObject(value) ? value : Object(value);
    }
    module.exports = toObject;
}, function(module, exports) {
    function isObject(value) {
        var type = typeof value;
        return !!value && ("object" == type || "function" == type);
    }
    module.exports = isObject;
}, function(module, exports, __webpack_require__) {
    var isArguments = __webpack_require__(46), isArray = __webpack_require__(52), isIndex = __webpack_require__(56), isLength = __webpack_require__(50), isObject = __webpack_require__(44);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function keysIn(object) {
        if (null == object) return [];
        if (!isObject(object)) object = Object(object);
        var length = object.length;
        length = length && isLength(length) && (isArray(object) || isArguments(object)) && length || 0;
        var Ctor = object.constructor, index = -1, isProto = "function" == typeof Ctor && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0;
        while (++index < length) result[index] = index + "";
        for (var key in object) if (!(skipIndexes && isIndex(key, length)) && !("constructor" == key && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
        return result;
    }
    module.exports = keysIn;
}, function(module, exports, __webpack_require__) {
    var isArrayLike = __webpack_require__(47), isObjectLike = __webpack_require__(51);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    function isArguments(value) {
        return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    }
    module.exports = isArguments;
}, function(module, exports, __webpack_require__) {
    var getLength = __webpack_require__(48), isLength = __webpack_require__(50);
    function isArrayLike(value) {
        return null != value && isLength(getLength(value));
    }
    module.exports = isArrayLike;
}, function(module, exports, __webpack_require__) {
    var baseProperty = __webpack_require__(49);
    var getLength = baseProperty("length");
    module.exports = getLength;
}, function(module, exports) {
    function baseProperty(key) {
        return function(object) {
            return null == object ? void 0 : object[key];
        };
    }
    module.exports = baseProperty;
}, function(module, exports) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
        return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
}, function(module, exports) {
    function isObjectLike(value) {
        return !!value && "object" == typeof value;
    }
    module.exports = isObjectLike;
}, function(module, exports, __webpack_require__) {
    var getNative = __webpack_require__(53), isLength = __webpack_require__(50), isObjectLike = __webpack_require__(51);
    var arrayTag = "[object Array]";
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    var nativeIsArray = getNative(Array, "isArray");
    var isArray = nativeIsArray || function(value) {
        return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };
    module.exports = isArray;
}, function(module, exports, __webpack_require__) {
    var isNative = __webpack_require__(54);
    function getNative(object, key) {
        var value = null == object ? void 0 : object[key];
        return isNative(value) ? value : void 0;
    }
    module.exports = getNative;
}, function(module, exports, __webpack_require__) {
    var isFunction = __webpack_require__(55), isObjectLike = __webpack_require__(51);
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var objectProto = Object.prototype;
    var fnToString = Function.prototype.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp("^" + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function isNative(value) {
        if (null == value) return false;
        if (isFunction(value)) return reIsNative.test(fnToString.call(value));
        return isObjectLike(value) && reIsHostCtor.test(value);
    }
    module.exports = isNative;
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(44);
    var funcTag = "[object Function]";
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    function isFunction(value) {
        return isObject(value) && objToString.call(value) == funcTag;
    }
    module.exports = isFunction;
}, function(module, exports) {
    var reIsUint = /^\d+$/;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isIndex(value, length) {
        value = "number" == typeof value || reIsUint.test(value) ? +value : -1;
        length = null == length ? MAX_SAFE_INTEGER : length;
        return value > -1 && value % 1 == 0 && value < length;
    }
    module.exports = isIndex;
}, function(module, exports) {
    function noop() {}
    module.exports = noop;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logModule = __webpack_require__(6);
    var replacer = new logModule.Replacer();
    module.exports = function() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) args[i] = arguments[i];
        if ("string" !== typeof args[0]) return toString(args);
        return replacer.replace(args[0], args.slice(1));
    };
    function toString(args) {
        if (0 === args.length) return "undefined";
        return args.map(function(item) {
            if (void 0 === item) return "undefined";
            try {
                return JSON.stringify(item);
            } catch (e) {
                return String(item);
            }
        }).join(" ");
    }
}, function(module, exports) {
    "use strict";
    exports.create = function() {
        return new XMLHttpRequest();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _xml = __webpack_require__(61);
    module.exports = {
        text: function() {
            return function(evt) {
                return evt.target.responseText;
            };
        },
        json: function() {
            return function(evt) {
                return JSON.parse(evt.target.responseText);
            };
        },
        xml: function() {
            return function(evt) {
                return evt.target.responseXML || _xml.fromString(evt.target.responseText);
            };
        },
        blob: function(xhr) {
            xhr.responseType = "blob";
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var toArray = __webpack_require__(62);
    var rxEscape = /&|  |<|>|\r\n|\n|'/g;
    var rxUnescape = /&amp;|&nbsp;|&lt;|&gt;|<(br|BR)\s*\/?>|&quot;/g;
    var mapEscape = {
        "&": "&amp;",
        "  ": "&nbsp; ",
        "<": "&lt;",
        ">": "&gt;",
        "\n": "<br />",
        "\r\n": "<br />",
        '"': "&quot;"
    };
    var mapUnescape = {
        "&amp;": "&",
        "&nbsp;": " ",
        "&lt;": "<",
        "&gt;": ">",
        "<br />": "\n",
        "<br/>": "\n",
        "<br>": "\n",
        "&quot;": '"'
    };
    var funcReplaceEscape = function(str) {
        return mapEscape[str];
    };
    var funcReplaceUnescape = function(str) {
        return mapUnescape[str.toLowerCase()];
    };
    var xml = {
        mapEscape: mapEscape,
        mapUnescape: mapUnescape,
        escape: function(str) {
            return str ? String(str).replace(rxEscape, funcReplaceEscape) : "";
        },
        unescape: function(str) {
            return str ? String(str).replace(rxUnescape, funcReplaceUnescape) : "";
        },
        fromString: "function" === typeof DOMParser ? function(string) {
            return new DOMParser().parseFromString(string, "text/xml");
        } : function(string) {
            var xmlDocument = new ActiveXObject("Microsoft.XMLDOM");
            xmlDocument.async = false;
            xmlDocument.loadXML(string);
            return xmlDocument;
        },
        select: "function" === typeof Sizzle ? function(selector, parent) {
            return Sizzle(selector, parent || window.document)[0] || null;
        } : function(selector, parent) {
            return (parent || window.document).querySelector(selector);
        },
        selectAll: "function" === typeof Sizzle ? function(selector, parent) {
            return Sizzle(selector, parent || window.document);
        } : function(selector, parent) {
            return toArray((parent || window.document).querySelectorAll(selector));
        },
        getText: function(elem, selector) {
            if (elem && selector) elem = xml.select(selector, elem);
            return elem ? elem.textContent || elem.innerText || elem.firstChild && elem.firstChild.data || elem.text || "" : "";
        },
        setText: function(elem, text) {
            if (elem) {
                elem.textContent = text;
                elem.innerText = text;
            }
        },
        getAttr: function(elem, selector, attr) {
            if (2 === arguments.length) {
                attr = selector;
                selector = null;
            }
            if (elem && selector) elem = xml.select(selector, elem);
            return elem && elem.getAttribute(attr) || "";
        },
        getAttrs: function(node) {
            return toArray(node.attributes).reduce(function(memo, attr) {
                memo[attr.name] = attr.value;
                return memo;
            }, Object.create(null));
        }
    };
    module.exports = xml;
    __webpack_require__(68).override(xml);
}, function(module, exports, __webpack_require__) {
    var arrayCopy = __webpack_require__(63), getLength = __webpack_require__(48), isLength = __webpack_require__(50), values = __webpack_require__(64);
    function toArray(value) {
        var length = value ? getLength(value) : 0;
        if (!isLength(length)) return values(value);
        if (!length) return [];
        return arrayCopy(value);
    }
    module.exports = toArray;
}, function(module, exports) {
    function arrayCopy(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) array[index] = source[index];
        return array;
    }
    module.exports = arrayCopy;
}, function(module, exports, __webpack_require__) {
    var baseValues = __webpack_require__(65), keys = __webpack_require__(66);
    function values(object) {
        return baseValues(object, keys(object));
    }
    module.exports = values;
}, function(module, exports) {
    function baseValues(object, props) {
        var index = -1, length = props.length, result = Array(length);
        while (++index < length) result[index] = object[props[index]];
        return result;
    }
    module.exports = baseValues;
}, function(module, exports, __webpack_require__) {
    var getNative = __webpack_require__(53), isArrayLike = __webpack_require__(47), isObject = __webpack_require__(44), shimKeys = __webpack_require__(67);
    var nativeKeys = getNative(Object, "keys");
    var keys = !nativeKeys ? shimKeys : function(object) {
        var Ctor = null == object ? void 0 : object.constructor;
        if ("function" == typeof Ctor && Ctor.prototype === object || "function" != typeof object && isArrayLike(object)) return shimKeys(object);
        return isObject(object) ? nativeKeys(object) : [];
    };
    module.exports = keys;
}, function(module, exports, __webpack_require__) {
    var isArguments = __webpack_require__(46), isArray = __webpack_require__(52), isIndex = __webpack_require__(56), isLength = __webpack_require__(50), keysIn = __webpack_require__(45);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function shimKeys(object) {
        var props = keysIn(object), propsLength = props.length, length = propsLength && object.length;
        var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
        var index = -1, result = [];
        while (++index < propsLength) {
            var key = props[index];
            if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) result.push(key);
        }
        return result;
    }
    module.exports = shimKeys;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var events = __webpack_require__(69);
    var offscreenManager = __webpack_require__(70);
    exports.override = function(xml) {
        if ("object" !== ("undefined" === typeof xml ? "undefined" : _typeof(xml))) return;
        xml.fromStringOriginal = xml.fromString.bind({});
        xml.getAttrOriginal = xml.getAttr.bind({});
        xml.getTextOriginal = xml.getText.bind({});
        xml.selectAllOriginal = xml.selectAll.bind({});
        xml.fromString = function(string) {
            return string;
        };
        xml.getAttr = function(xmlString, selector, attr) {
            var callback = function(message) {
                var errObj = message.errObj, attr = message.attr;
                if (errObj) throw new Error(errObj.message); else return attr;
            };
            var msgBody = {
                type: events.backend.XML_GET_ATTR,
                data: {
                    xmlString: xmlString,
                    selector: selector,
                    attr: attr
                }
            };
            return offscreenManager.sendMessage(msgBody, "XML getAttr timed out", callback);
        };
        xml.getText = function(xmlString, selector) {
            var callback = function(message) {
                var errObj = message.errObj, text = message.text;
                if (errObj) throw new Error(errObj.message); else return text;
            };
            var msgBody = {
                type: events.backend.XML_GET_TEXT,
                data: {
                    xmlString: xmlString,
                    selector: selector
                }
            };
            return offscreenManager.sendMessage(msgBody, "XML getText timed out", callback);
        };
        xml.selectAll = function(selector, parent) {
            var callback = function(message) {
                var errObj = message.errObj, selection = message.selection;
                if (errObj) throw new Error(errObj.message); else return selection;
            };
            var msgBody = {
                type: events.backend.XML_SELECT_ALL,
                data: {
                    selector: selector,
                    parent: parent
                }
            };
            return offscreenManager.sendMessage(msgBody, "XML selectAll timed out", callback);
        };
    };
}, function(module, exports) {
    "use strict";
    module.exports = {
        offscreen: {
            COLORS_DOMINANT_COLOR_BY_URL: "Colors.calculateDominantColorByUrl.response",
            COLORS_FONT_COLOR_BY_URL: "Colors.calculateFontColorByUrl.response",
            FILER_CD: "Filer.cd.response",
            FILER_CP: "Filer.cp.response",
            FILER_CREATE: "Filer.create.response",
            FILER_DF: "Filer.df.response",
            FILER_GET_ENTRY: "Filer.getEntry.response",
            FILER_INIT: "Filer.init.response",
            FILER_LS: "Filer.ls.response",
            FILER_MKDIR: "Filer.mkdir.response",
            FILER_MV: "Filer.mv.response",
            FILER_OPEN: "Filer.open.response",
            FILER_PATH_TO_FILESYSTEM_URL: "Filer.pathToFilesystemUrl.response",
            FILER_RM: "Filer.rm.response",
            FILER_WRITE: "Filer.write.response",
            SPEECHKIT_DATA: "Speechkit.data.response",
            SPEECHKIT_ERROR: "Speechkit.error.response",
            SPEECHKIT_INIT: "Speechkit.init.response",
            SPEECHKIT_STOP: "Speechkit.stop.response",
            XML_FROM_STRING: "Filer.fromString.response",
            XML_GET_ATTR: "Filer.getAttr.response",
            XML_GET_TEXT: "Filer.getText.response",
            XML_SELECT_ALL: "Filer.selectAll.response"
        },
        backend: {
            COLORS_DOMINANT_COLOR_BY_URL: "Colors.calculateDominantColorByUrl.request",
            COLORS_FONT_COLOR_BY_URL: "Colors.calculateFontColorByUrl.request",
            FILER_CD: "Filer.cd.request",
            FILER_CP: "Filer.cp.request",
            FILER_CREATE: "Filer.create.request",
            FILER_DF: "Filer.df.request",
            FILER_GET_ENTRY: "Filer.getEntry.request",
            FILER_INIT: "Filer.init.request",
            FILER_LS: "Filer.ls.request",
            FILER_MKDIR: "Filer.mkdir.request",
            FILER_MV: "Filer.mv.request",
            FILER_OPEN: "Filer.open.request",
            FILER_PATH_TO_FILESYSTEM_URL: "Filer.pathToFilesystemUrl.request",
            FILER_RM: "Filer.rm.request",
            FILER_WRITE: "Filer.write.request",
            SPEECHKIT_STOP: "Speechkit.stop.request",
            SPEECHKIT_INIT: "Speechkit.init.request",
            XML_FROM_STRING: "Filer.fromString.request",
            XML_GET_ATTR: "Filer.getAttr.request",
            XML_GET_TEXT: "Filer.getText.request",
            XML_SELECT_ALL: "Filer.selectAll.request"
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var errorBooster = __webpack_require__(25);
    var creationCount = 0;
    var OffscreenManager = function() {
        function OffscreenManager() {
            _classCallCheck(this, OffscreenManager);
            this.maybeCloseOffscreen = this.maybeCloseOffscreen.bind(this);
            this.messages = new Map();
        }
        _createClass(OffscreenManager, [ {
            key: "_getMessageId",
            value: function() {
                var uniqueId = void 0;
                do uniqueId = Math.random().toString(36).substr(2, 9); while (this.messages.has(uniqueId));
                return uniqueId;
            }
        }, {
            key: "_isTabsLeft",
            value: function() {
                return chrome.tabs.query({}).then(function(tabs) {
                    return 0 !== tabs.length;
                });
            }
        }, {
            key: "_closeOffscreen",
            value: function() {
                var _this = this;
                return OffscreenManager.hasOffscreen().then(function(hasDocument) {
                    if (hasDocument) return chrome.offscreen.closeDocument();
                }).finally(function() {
                    _this.isCreatingOffscreenDocument = null;
                    chrome.tabs.onRemoved.removeListener(_this.maybeCloseOffscreen);
                });
            }
        }, {
            key: "_createOffscreen",
            value: function() {
                var _this2 = this;
                return OffscreenManager.hasOffscreen().then(function(hasDocument) {
                    if (!hasDocument) return chrome.offscreen.createDocument({
                        url: "backend/offscreen.html",
                        reasons: Object.keys(justifications),
                        justification: Object.values(justifications).join("; ")
                    }, function() {
                        if (chrome.runtime.lastError) {
                            _this2.isCreatingOffscreenDocument = null;
                            errorBooster.uncaught(chrome.runtime.lastError, {
                                creationCount: creationCount
                            });
                        } else {
                            creationCount += 1;
                            errorBooster.info("Offscreen is created", {
                                creationCount: creationCount
                            });
                        }
                    });
                }).finally(function() {
                    _this2.isClosingOffscreenDocument = null;
                    chrome.tabs.onRemoved.addListener(_this2.maybeCloseOffscreen);
                });
            }
        }, {
            key: "_connectPort",
            value: function() {
                var _this3 = this;
                this.port = chrome.runtime.connect({
                    name: "offscreen"
                });
                this.port.onDisconnect.addListener(function() {
                    _this3.port = null;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                        for (var _step, _iterator = _this3.messages.values()[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var entry = _step.value;
                            if ("object" === ("undefined" === typeof entry ? "undefined" : _typeof(entry)) && entry.reject) entry.reject(new Error("Port was disconnected"));
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
                        } finally {
                            if (_didIteratorError) throw _iteratorError;
                        }
                    }
                    _this3.messages.clear();
                });
                this.port.onMessage.addListener(function(message) {
                    var entry = _this3.messages.get(message.id);
                    if (entry) {
                        entry.resolve(message);
                        _this3.messages.delete(message.id);
                    }
                });
                return Promise.resolve();
            }
        }, {
            key: "_ensurePortConnected",
            value: function() {
                var _this4 = this;
                if (this.port) return Promise.resolve();
                this.maybeCreateOffscreen();
                return this.isCreatingOffscreenDocument.then(function() {
                    return _this4._connectPort();
                });
            }
        }, {
            key: "addOffscreenListener",
            value: function(callback) {
                if (this.port) this.port.onMessage.addListener(callback);
            }
        }, {
            key: "removeOffscreenListener",
            value: function(callback) {
                if (this.port) this.port.onMessage.removeListener(callback);
            }
        }, {
            key: "maybeCloseOffscreen",
            value: function() {
                if (!this.isClosingOffscreenDocument) this.isClosingOffscreenDocument = this._closeOffscreen();
            }
        }, {
            key: "maybeCreateOffscreen",
            value: function() {
                if (!this.isCreatingOffscreenDocument) this.isCreatingOffscreenDocument = this._createOffscreen();
            }
        }, {
            key: "sendMessage",
            value: function(msgBody, _rejectMessage, callback, opt_errorHandler) {
                var _this5 = this;
                msgBody.id = this._getMessageId();
                return this._ensurePortConnected().then(function() {
                    return new Promise(function(resolve, reject) {
                        _this5.messages.set(msgBody.id, {
                            resolve: resolve,
                            reject: reject
                        });
                        _this5.port.postMessage(msgBody);
                    });
                }).then(function(message) {
                    if (callback) return callback(message);
                }).catch(function(error) {
                    if (opt_errorHandler) opt_errorHandler(error);
                    if (error && error.message) errorBooster.uncaught(error.message);
                });
            }
        } ], [ {
            key: "hasOffscreen",
            value: function() {
                if ("getContexts" in chrome.runtime) return chrome.runtime.getContexts({
                    contextTypes: [ "OFFSCREEN_DOCUMENT" ]
                }).then(function(contexts) {
                    return !!contexts.length;
                }); else return clients.matchAll().then(function(matchedClients) {
                    return matchedClients.some(function(client) {
                        return client.url.includes(chrome.runtime.id);
                    });
                });
            }
        } ]);
        return OffscreenManager;
    }();
    module.exports = new OffscreenManager();
}, function(module, exports, __webpack_require__) {
    "use strict";
    var URI = __webpack_require__(33);
    var isPlainObject = __webpack_require__(39);
    var fetch = __webpack_require__(72);
    exports.override = function(Request) {
        if ("function" !== typeof Request) return;
        Request.prototype.send = function() {
            var _this = this;
            this.options = this._transformToFetchOptions(this.options);
            if (this.options && this.options.body) this.options.method = "POST";
            var evt = {
                target: {
                    status: "pending",
                    url: this.options.url
                }
            };
            var request = fetch(this.options.url, this.options).then(function(data) {
                evt.target.status = "fullfilled";
                _this.callback(null, data, Object.assign(evt, {
                    target: request
                }));
            }).catch(function(err) {
                evt.target.status = "rejected";
                _this.callback(err, null, Object.assign(evt, {
                    target: request
                }));
            });
            return request;
        };
        Request.prototype._transformToFetchOptions = function(options) {
            return Object.assign(options, {
                responseType: options.parse || "text",
                headers: this._getFetchHeaders(options)
            });
        };
        Request.prototype._getFetchHeaders = function() {
            var options = this.options;
            var headers = options.headers || {};
            if (options.bypassCache) headers["If-Modified-Since"] = "Sat, 1 Jan 2005 00:00:00 GMT";
            if ("string" === typeof options.body) {
                if (!headers["Content-Type"]) headers["Content-Type"] = "text/plain; charset=UTF-8";
            } else if (isPlainObject(options.body)) {
                options.body = URI.buildQuery(options.body);
                if (!headers["Content-Type"]) headers["Content-Type"] = "application/x-www-form-urlencoded; charset=UTF-8";
            }
            return headers;
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var xml = __webpack_require__(61);
    var xhrUtils = __webpack_require__(38);
    var logger = __webpack_require__(5).create("Utils/fetch");
    var isEmpty = __webpack_require__(73);
    var isString = __webpack_require__(74);
    var isObject = __webpack_require__(44);
    var pick = __webpack_require__(75);
    var urlUtils = __webpack_require__(83);
    var CONTENT_TYPE = "content-type";
    var APPLICATION_JSON = "application/json";
    var OPTIONS = [ "params", "body", "method", "headers", "mode", "credentials", "cache", "redirect", "referrer", "integrity" ];
    var POSTPROCESSOR_OPTIONS = [ "responseType", "logError", "timeout" ];
    var interceptors = [];
    var DEFAULT_OPTIONS = {
        credentials: "include"
    };
    module.exports = fetchWrapper;
    function fetchWrapper(url) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var _parseOptions = parseOptions(options), _parseOptions2 = _slicedToArray(_parseOptions, 2), fetchOptions = _parseOptions2[0], postprocessorOptions = _parseOptions2[1];
        fetchOptions = Object.assign({}, DEFAULT_OPTIONS, fetchOptions);
        return new Fetch(url, fetchOptions, postprocessorOptions).promise;
    }
    shortcutFactory("post", postArgsProvider, fetchWrapper);
    shortcutFactory("json", jsonArgsProvider, fetchWrapper);
    shortcutFactory("json", jsonArgsProvider, fetchWrapper.post);
    shortcutFactory("blob", blobArgsProvider, fetchWrapper);
    shortcutFactory("blob", blobArgsProvider, fetchWrapper.post);
    fetchWrapper.addInterceptor = function(interceptor) {
        interceptors.push(interceptor);
    };
    fetchWrapper.removeAllInterceptors = function() {
        interceptors.length = 0;
    };
    function Fetch(url) {
        var _this = this;
        var init = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var postprocessorOptions = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        this.postprocessorOptions = postprocessorOptions;
        this.rejectedByTimeout = false;
        init.headers = init.headers || {};
        url = urlUtils.setQuery(url, init.params);
        this._prepareBody(init);
        var request = new Request(url, init);
        this._executeInterceptors(request);
        this.promise = new Promise(function(resolve, reject) {
            fetch(request).then(function(response) {
                return _this._processRawResponse(response);
            }).then(function(response) {
                return _this._transformToResponseType(response);
            }).catch(function(response) {
                return _this._processError(response);
            }).then(resolve).catch(reject);
            if (postprocessorOptions.timeout) _this._setTimeout(reject);
        });
    }
    Fetch.prototype._executeInterceptors = function(request) {
        interceptors.forEach(function(interceptor) {
            return interceptor(request);
        });
    };
    Fetch.prototype._prepareBody = function(init) {
        var body = init.body;
        if (null === body || void 0 === body) return;
        if (shouldBeBodyStringifiedAsJson(body)) try {
            init.body = JSON.stringify(body);
            init.headers[CONTENT_TYPE] = APPLICATION_JSON;
        } catch (e) {}
    };
    Fetch.prototype._setTimeout = function(reject) {
        var _this2 = this;
        var timeout = this.postprocessorOptions.timeout;
        this.timeoutHandler = setTimeout(function() {
            _this2.rejectedByTimeout = true;
            reject(_this2._logError("Aborted by timeout " + timeout + " ms"));
        }, timeout);
    };
    Fetch.prototype._processRawResponse = function(response) {
        if (this.rejectedByTimeout) return Promise.reject();
        clearTimeout(this.timeoutHandler);
        return this._checkStatus(response);
    };
    Fetch.prototype._processError = function(response) {
        clearTimeout(this.timeoutHandler);
        if (response instanceof Response) return this._parseError(response).then(function(msg) {
            return Promise.reject(msg);
        }); else return Promise.reject(response);
    };
    Fetch.prototype._parseError = function(response) {
        if (isContentType(response.headers, APPLICATION_JSON)) return response.json(); else return response.text();
    };
    Fetch.prototype._logError = function(msg) {
        if (this.postprocessorOptions.logError) logger.error(msg);
        return msg;
    };
    Fetch.prototype._checkStatus = function(response) {
        if (xhrUtils.isError(response.status)) return Promise.reject(response);
        return Promise.resolve(response);
    };
    Fetch.prototype._transformToResponseType = function(response) {
        var responseType = this.postprocessorOptions.responseType;
        if (isEmpty(responseType)) return response.text();
        switch (responseType.toLocaleLowerCase()) {
          case "raw":
            return response;

          case "blob":
            return response.blob();

          case "json":
            return response.json();

          case "arraybuffer":
            return response.arrayBuffer();

          case "xml":
            return response.text().then(function(result) {
                return xml.fromString(result);
            });

          default:
            return response.text();
        }
    };
    function isContentType(headers, type) {
        var contentType = headers.get(CONTENT_TYPE);
        return contentType === type;
    }
    function parseOptions(options) {
        var fetchOptions = pick(options, OPTIONS);
        var postprocessorOptions = pick(options, POSTPROCESSOR_OPTIONS);
        return [ fetchOptions, postprocessorOptions ];
    }
    function shouldBeBodyStringifiedAsJson(obj) {
        if (isString(obj)) return false;
        if (obj instanceof Blob) return false;
        if (obj instanceof FormData) return false;
        return isObject(obj);
    }
    function shortcutFactory(name, argsProvider, func) {
        func[name] = function() {
            var args = argsProvider.apply(null, arguments);
            return func.apply(null, args);
        };
    }
    function blobArgsProvider(url) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return [ url, Object.assign({}, options, {
            responseType: "blob"
        }) ];
    }
    function jsonArgsProvider(url) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return [ url, Object.assign({}, options, {
            responseType: "json"
        }) ];
    }
    function postArgsProvider(url) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return [ url, Object.assign({}, options, {
            method: "post"
        }) ];
    }
}, function(module, exports, __webpack_require__) {
    var isArguments = __webpack_require__(46), isArray = __webpack_require__(52), isArrayLike = __webpack_require__(47), isFunction = __webpack_require__(55), isObjectLike = __webpack_require__(51), isString = __webpack_require__(74), keys = __webpack_require__(66);
    function isEmpty(value) {
        if (null == value) return true;
        if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice))) return !value.length;
        return !keys(value).length;
    }
    module.exports = isEmpty;
}, function(module, exports, __webpack_require__) {
    var isObjectLike = __webpack_require__(51);
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    function isString(value) {
        return "string" == typeof value || isObjectLike(value) && objToString.call(value) == stringTag;
    }
    module.exports = isString;
}, function(module, exports, __webpack_require__) {
    var baseFlatten = __webpack_require__(76), bindCallback = __webpack_require__(78), pickByArray = __webpack_require__(80), pickByCallback = __webpack_require__(81), restParam = __webpack_require__(82);
    var pick = restParam(function(object, props) {
        if (null == object) return {};
        return "function" == typeof props[0] ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
    });
    module.exports = pick;
}, function(module, exports, __webpack_require__) {
    var arrayPush = __webpack_require__(77), isArguments = __webpack_require__(46), isArray = __webpack_require__(52), isArrayLike = __webpack_require__(47), isObjectLike = __webpack_require__(51);
    function baseFlatten(array, isDeep, isStrict, result) {
        result || (result = []);
        var index = -1, length = array.length;
        while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) if (isDeep) baseFlatten(value, isDeep, isStrict, result); else arrayPush(result, value); else if (!isStrict) result[result.length] = value;
        }
        return result;
    }
    module.exports = baseFlatten;
}, function(module, exports) {
    function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) array[offset + index] = values[index];
        return array;
    }
    module.exports = arrayPush;
}, function(module, exports, __webpack_require__) {
    var identity = __webpack_require__(79);
    function bindCallback(func, thisArg, argCount) {
        if ("function" != typeof func) return identity;
        if (void 0 === thisArg) return func;
        switch (argCount) {
          case 1:
            return function(value) {
                return func.call(thisArg, value);
            };

          case 3:
            return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
            };

          case 4:
            return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
            };

          case 5:
            return function(value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
            };
        }
        return function() {
            return func.apply(thisArg, arguments);
        };
    }
    module.exports = bindCallback;
}, function(module, exports) {
    function identity(value) {
        return value;
    }
    module.exports = identity;
}, function(module, exports, __webpack_require__) {
    var toObject = __webpack_require__(43);
    function pickByArray(object, props) {
        object = toObject(object);
        var index = -1, length = props.length, result = {};
        while (++index < length) {
            var key = props[index];
            if (key in object) result[key] = object[key];
        }
        return result;
    }
    module.exports = pickByArray;
}, function(module, exports, __webpack_require__) {
    var baseForIn = __webpack_require__(40);
    function pickByCallback(object, predicate) {
        var result = {};
        baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) result[key] = value;
        });
        return result;
    }
    module.exports = pickByCallback;
}, function(module, exports) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    function restParam(func, start) {
        if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
        start = nativeMax(void 0 === start ? func.length - 1 : +start || 0, 0);
        return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), rest = Array(length);
            while (++index < length) rest[index] = args[start + index];
            switch (start) {
              case 0:
                return func.call(this, rest);

              case 1:
                return func.call(this, args[0], rest);

              case 2:
                return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) otherArgs[index] = args[index];
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
        };
    }
    module.exports = restParam;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var URI = __webpack_require__(33);
    var GenericModule = __webpack_require__(84);
    var urlImpl = __webpack_require__(86);
    var urnImpl = __webpack_require__(89);
    var URL_TYPE = "url";
    var URN_TYPE = "urn";
    function createURI(string) {
        try {
            return URI(string);
        } catch (e) {
            return null;
        }
    }
    function typeChecker() {
        if (0 === arguments.length) return null;
        var uri = createURI(arguments[0]);
        if (!uri) return null;
        if (uri.is(URL_TYPE)) return URL_TYPE;
        if (uri.is(URN_TYPE)) return URN_TYPE;
        return null;
    }
    var urlGeneric = new GenericModule(typeChecker);
    urlGeneric.addImplementation(URL_TYPE, urlImpl);
    urlGeneric.addImplementation(URN_TYPE, urnImpl);
    urlGeneric.setDefaultType(URL_TYPE);
    module.exports = urlGeneric;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var MethodsTable = __webpack_require__(85);
    function GenericModule(typeChecker) {
        this._getType = typeChecker;
        this._methodsTable = new MethodsTable();
    }
    GenericModule.prototype.addImplementation = function(type, module) {
        Object.keys(module).forEach(function(methodName) {
            this._methodsTable.add(type, methodName, module[methodName]);
            if (!this[methodName]) this[methodName] = createGenericMethod(methodName, this._methodsTable, this._getType);
        }.bind(this));
    };
    GenericModule.prototype.setDefaultType = function(type) {
        this._methodsTable.setDefaultType(type);
    };
    function createGenericMethod(methodName, methodsTable, getType) {
        return function() {
            var type = getType.apply(null, arguments);
            var method = methodsTable.get(type, methodName);
            if (method) return method.apply(null, arguments);
            return;
        };
    }
    module.exports = GenericModule;
}, function(module, exports) {
    "use strict";
    function MethodsTable() {
        this._defaultType = null;
        this._table = Object.create(null);
    }
    MethodsTable.prototype = {
        setDefaultType: function(type) {
            this._defaultType = type;
        },
        add: function(type, name, implementation) {
            if (!this._table[name]) this._table[name] = {};
            this._table[name][type] = implementation;
        },
        get: function(type, name) {
            if (this._table[name]) return this._table[name][type] || this._table[name][this._defaultType];
            return;
        }
    };
    module.exports = MethodsTable;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var URI = __webpack_require__(33);
    var createURI = __webpack_require__(87);
    var buildInfo = __webpack_require__(20);
    var about = __webpack_require__(23);
    var YANDEX_DOMAINS = __webpack_require__(88);
    var PROTOCOL_NORMALIZATION_MAP = {
        https: "http",
        ftps: "ftp"
    };
    var REMOTE_PROTOCOLS = {
        http: true,
        https: true,
        ftp: true,
        ftps: true
    };
    var ALLOWED_FOR_DOWNLOAD_PROTOCOLS = {
        http: true,
        https: true,
        file: true,
        ftp: true,
        ftps: true
    };
    var TECHNICAL_PARAM = "nugt";
    exports.createURI = createURI;
    function createReadableURI(url) {
        try {
            var readableUrl = createURI(url).readable();
            return createURI(readableUrl);
        } catch (e) {
            return null;
        }
    }
    exports.getNormalUrl = function(url, params) {
        params = params || {};
        var shouldNormalizeProtocol = true === params.protocol ? true : false;
        var shouldNormalizeWWW = true === params.www ? true : false;
        try {
            var urlObject = createURI(url).normalize();
            if (shouldNormalizeProtocol) {
                var protocol = urlObject.protocol();
                urlObject.protocol(PROTOCOL_NORMALIZATION_MAP[protocol] || protocol);
            }
            if (shouldNormalizeWWW) urlObject.hostname(normalizeHostname(urlObject));
            return urlObject.toString();
        } catch (e) {
            return url;
        }
    };
    exports.getReadableUrl = function(url) {
        var uri = createReadableURI(url);
        if (uri) return uri.toString();
        return url;
    };
    exports.getNormalDomain = function(url) {
        try {
            return normalizeHostname(createURI(url).normalize());
        } catch (e) {
            return "";
        }
    };
    exports.getReadableDomain = function(url) {
        try {
            return normalizeHostname(createReadableURI(url));
        } catch (e) {
            return "";
        }
    };
    function normalizeHostname(uri) {
        var subdomain = uri.subdomain();
        if (subdomain) {
            subdomain = subdomain.replace(/^www(\.|$)/, "");
            return (subdomain ? subdomain + "." : "") + uri.domain();
        }
        return uri.hostname();
    }
    var LAST_SLASH_REG_EXP = /\/$/;
    exports.getNormalPath = function(url) {
        try {
            return createURI(url).normalize().path().replace(LAST_SLASH_REG_EXP, "");
        } catch (e) {
            return "";
        }
    };
    exports.getIndexPart = function(url) {
        try {
            var uri = createURI(url).normalize();
            return uri.protocol() + "://" + uri.hostname() + "/";
        } catch (error) {
            return "";
        }
    };
    exports.getQueryObject = function(url) {
        try {
            return createURI(url).search(true);
        } catch (e) {
            return {};
        }
    };
    exports.addRandomParam = function(url) {
        if (!/^data:/.test(url)) try {
            var randomValue = (Date.now() + Math.random()).toString(36);
            return createURI(url).setQuery("rnd", randomValue).toString();
        } catch (error) {}
        return url;
    };
    exports.isIndexPage = function(url) {
        try {
            var uri = createURI(url).normalize();
            return exports.isYandexHost(url) ? isYandexIndexPage(uri) : isCommonIndexPage(uri);
        } catch (e) {
            return false;
        }
    };
    function isYandexIndexPage(uri) {
        return "/" === uri.path() && isYandexIndexQuery(uri);
    }
    var YANDEX_INDEX_QUERIES = [ "clid", "from" ];
    function isYandexIndexQuery(uri) {
        var queryObject = uri.search(true);
        return Object.keys(queryObject).every(function(name) {
            return YANDEX_INDEX_QUERIES.indexOf(name) !== -1;
        });
    }
    function isCommonIndexPage(uri) {
        return "/" === uri.path() && "" === uri.query();
    }
    exports.isRemote = function(url) {
        try {
            return createURI(url).normalize().protocol() in REMOTE_PROTOCOLS;
        } catch (error) {
            return false;
        }
    };
    exports.isAllowedForDownload = function(url) {
        try {
            return createURI(url).normalize().protocol() in ALLOWED_FOR_DOWNLOAD_PROTOCOLS;
        } catch (error) {
            return false;
        }
    };
    exports.isEqualUrls = function(url1, url2) {
        if (isEqualStrings(url1, url2)) return true;
        var uri1 = createURI(url1);
        var uri2 = createURI(url2);
        return isEqualUris(uri1, uri2);
    };
    exports.isUrlInList = function(url, urlList) {
        if (!Array.isArray(urlList)) return false;
        if (!url) return false;
        return urlList.some(function(listUrl) {
            return exports.isEqualUrls(listUrl, url);
        });
    };
    function isEqualStrings(url1, url2) {
        var url1Lower = "string" === typeof url1 ? url1.toLowerCase() : url1;
        var url2Lower = "string" === typeof url2 ? url2.toLowerCase() : url2;
        return url1Lower === url2Lower;
    }
    function isEqualUris(uri1, uri2) {
        try {
            return uri1.equals(uri2);
        } catch (e) {
            return false;
        }
    }
    exports.isYandexHost = function(url) {
        try {
            return createURI(url).normalize().domain() in YANDEX_DOMAINS;
        } catch (error) {
            return false;
        }
    };
    exports.isDataUri = function() {
        return false;
    };
    exports.isSpecialUrl = function() {
        return false;
    };
    exports.addTechnicalParam = function(url) {
        if (!exports.isYandexHost(url)) return url;
        try {
            return createURI(url).setQuery(TECHNICAL_PARAM, createTechnicalParam()).toString();
        } catch (error) {
            return url;
        }
    };
    function createTechnicalParam() {
        return about.yasoft + "-" + buildInfo.getVersion();
    }
    exports.deleteTechnicalParam = function(url) {
        if (!exports.isYandexHost(url)) return url;
        try {
            return createURI(url).removeQuery(TECHNICAL_PARAM).toString();
        } catch (error) {
            return url;
        }
    };
    exports.resolve = function(siteUrl, baseUrl, relativeUrl) {
        try {
            var siteURI = new URI(siteUrl);
            var relativeURI = new URI(relativeUrl);
            if (!siteURI.is("url") || !siteURI.is("absolute") || !siteURI.protocol() || !relativeURI.is("url")) return null;
            var baseURI = baseUrl ? new URI(baseUrl).absoluteTo(siteURI) : siteURI;
            return relativeURI.absoluteTo(baseURI).toString();
        } catch (e) {
            return null;
        }
    };
    exports.setQuery = function(url, params) {
        try {
            return createURI(url).setQuery(params).toString();
        } catch (error) {
            return url;
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var URI = __webpack_require__(33);
    var logger = __webpack_require__(5).create("utils/uri-creator");
    var DEFAULT_PROTOCOL = "http";
    module.exports = function(urlOrDomain) {
        if (!urlOrDomain) return null;
        try {
            return createURIObject(urlOrDomain);
        } catch (e) {
            logger.error("Can not create URI for %s %s", urlOrDomain, e.message);
            return null;
        }
    };
    function createURIObject(urlOrDomain) {
        urlOrDomain = convertWin1251ToUnicode(urlOrDomain);
        var uri = new URI(urlOrDomain);
        if (!uri.protocol()) uri = new URI(uri.protocol(DEFAULT_PROTOCOL).toString());
        return uri;
    }
    function convertWin1251ToUnicode(url) {
        try {
            decodeURIComponent(url);
        } catch (e) {
            if (/%[A-F0-9]{2}/.test(url)) {
                var WIN1251_UNICODE_CHAR_SHIFT = 1040 - 192;
                url = url.replace(/%([A-F0-9]{2})/g, function(match, charCode) {
                    var charString = String.fromCharCode(parseInt("0x" + charCode, 16) + WIN1251_UNICODE_CHAR_SHIFT);
                    return encodeURIComponent(charString);
                });
            }
        }
        return url;
    }
}, function(module, exports) {
    "use strict";
    module.exports = {
        "yandex.ru": true,
        "yandex.ua": true,
        "yandex.by": true,
        "yandex.kz": true,
        "yandex.net": true,
        "yandex.com": true,
        "yandex.com.tr": true,
        "ya.ru": true,
        "kinopoisk.ru": true,
        "auto.ru": true
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var createURI = __webpack_require__(87);
    var DATA_URI_REG_EXP = /^data:/;
    var PROTOCOL_SLASHES_REG_EXP = /:\/\//;
    exports.createURI = createURI;
    exports.getNormalDomain = function(url) {
        try {
            var normalUri = createURI(url).normalize();
            return normalUri.protocol() + ":" + normalUri.path();
        } catch (e) {
            return "";
        }
    };
    exports.getReadableUrl = function(url) {
        try {
            return createURI(url).readable().replace(PROTOCOL_SLASHES_REG_EXP, ":");
        } catch (e) {
            return url;
        }
    };
    exports.getReadableDomain = exports.getNormalDomain;
    exports.getNormalPath = function(url) {
        try {
            return createURI(url).normalize().path();
        } catch (e) {
            return "";
        }
    };
    exports.getIndexPart = function() {
        return "";
    };
    exports.isSpecialUrl = function() {
        return true;
    };
    exports.isRemote = function() {
        return false;
    };
    exports.isAllowedForDownload = function() {
        return false;
    };
    exports.isDataUri = function(url) {
        return DATA_URI_REG_EXP.test(url);
    };
    exports.isIndexPage = function(url) {
        try {
            var uri = createURI(url).normalize();
            return "" === uri.query();
        } catch (e) {
            return false;
        }
    };
}, function(module, exports) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    module.exports = {
        copyOwnProperties: function copyOwnProperties(from, to, deep) {
            if ("object" !== ("undefined" === typeof from ? "undefined" : _typeof(from)) || "object" !== ("undefined" === typeof to ? "undefined" : _typeof(to))) throw new TypeError("Not an object");
            for (var prop in from) if (from.hasOwnProperty(prop)) if (deep && "object" === _typeof(from[prop]) && null !== from[prop]) {
                to[prop] = {};
                copyOwnProperties(from[prop], to[prop]);
            } else to[prop] = from[prop];
            return to;
        },
        extendModule: function(module, additionalData) {
            return Object.keys(module).reduce(function(newModule, fieldName) {
                if (!newModule[fieldName]) newModule[fieldName] = module[fieldName];
                return newModule;
            }, additionalData);
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = {
        defaults: __webpack_require__(92),
        groupBy: __webpack_require__(101),
        difference: __webpack_require__(128),
        each: __webpack_require__(136),
        map: __webpack_require__(140),
        max: __webpack_require__(143),
        debounce: __webpack_require__(149),
        create: __webpack_require__(151),
        attempt: __webpack_require__(153),
        throttle: __webpack_require__(155),
        values: __webpack_require__(64),
        pluck: __webpack_require__(156),
        merge: __webpack_require__(157),
        cloneDeep: __webpack_require__(161),
        ary: __webpack_require__(167),
        endsWith: __webpack_require__(190),
        repeat: __webpack_require__(191),
        extend: __webpack_require__(192),
        get: __webpack_require__(193),
        noop: __webpack_require__(57),
        findKey: __webpack_require__(194),
        assign: __webpack_require__(93),
        find: __webpack_require__(197),
        uniq: __webpack_require__(200),
        isNumber: __webpack_require__(203),
        filter: __webpack_require__(204)
    };
}, function(module, exports, __webpack_require__) {
    var assign = __webpack_require__(93), assignDefaults = __webpack_require__(99), createDefaults = __webpack_require__(100);
    var defaults = createDefaults(assign, assignDefaults);
    module.exports = defaults;
}, function(module, exports, __webpack_require__) {
    var assignWith = __webpack_require__(94), baseAssign = __webpack_require__(95), createAssigner = __webpack_require__(97);
    var assign = createAssigner(function(object, source, customizer) {
        return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
    });
    module.exports = assign;
}, function(module, exports, __webpack_require__) {
    var keys = __webpack_require__(66);
    function assignWith(object, source, customizer) {
        var index = -1, props = keys(source), length = props.length;
        while (++index < length) {
            var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
            if ((result === result ? result !== value : value === value) || void 0 === value && !(key in object)) object[key] = result;
        }
        return object;
    }
    module.exports = assignWith;
}, function(module, exports, __webpack_require__) {
    var baseCopy = __webpack_require__(96), keys = __webpack_require__(66);
    function baseAssign(object, source) {
        return null == source ? object : baseCopy(source, keys(source), object);
    }
    module.exports = baseAssign;
}, function(module, exports) {
    function baseCopy(source, props, object) {
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
            var key = props[index];
            object[key] = source[key];
        }
        return object;
    }
    module.exports = baseCopy;
}, function(module, exports, __webpack_require__) {
    var bindCallback = __webpack_require__(78), isIterateeCall = __webpack_require__(98), restParam = __webpack_require__(82);
    function createAssigner(assigner) {
        return restParam(function(object, sources) {
            var index = -1, length = null == object ? 0 : sources.length, customizer = length > 2 ? sources[length - 2] : void 0, guard = length > 2 ? sources[2] : void 0, thisArg = length > 1 ? sources[length - 1] : void 0;
            if ("function" == typeof customizer) {
                customizer = bindCallback(customizer, thisArg, 5);
                length -= 2;
            } else {
                customizer = "function" == typeof thisArg ? thisArg : void 0;
                length -= customizer ? 1 : 0;
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? void 0 : customizer;
                length = 1;
            }
            while (++index < length) {
                var source = sources[index];
                if (source) assigner(object, source, customizer);
            }
            return object;
        });
    }
    module.exports = createAssigner;
}, function(module, exports, __webpack_require__) {
    var isArrayLike = __webpack_require__(47), isIndex = __webpack_require__(56), isObject = __webpack_require__(44);
    function isIterateeCall(value, index, object) {
        if (!isObject(object)) return false;
        var type = typeof index;
        if ("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) {
            var other = object[index];
            return value === value ? value === other : other !== other;
        }
        return false;
    }
    module.exports = isIterateeCall;
}, function(module, exports) {
    function assignDefaults(objectValue, sourceValue) {
        return void 0 === objectValue ? sourceValue : objectValue;
    }
    module.exports = assignDefaults;
}, function(module, exports, __webpack_require__) {
    var restParam = __webpack_require__(82);
    function createDefaults(assigner, customizer) {
        return restParam(function(args) {
            var object = args[0];
            if (null == object) return object;
            args.push(customizer);
            return assigner.apply(void 0, args);
        });
    }
    module.exports = createDefaults;
}, function(module, exports, __webpack_require__) {
    var createAggregator = __webpack_require__(102);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var groupBy = createAggregator(function(result, value, key) {
        if (hasOwnProperty.call(result, key)) result[key].push(value); else result[key] = [ value ];
    });
    module.exports = groupBy;
}, function(module, exports, __webpack_require__) {
    var baseCallback = __webpack_require__(103), baseEach = __webpack_require__(125), isArray = __webpack_require__(52);
    function createAggregator(setter, initializer) {
        return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = baseCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    setter(result, value, iteratee(value, index, collection), collection);
                }
            } else baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
            });
            return result;
        };
    }
    module.exports = createAggregator;
}, function(module, exports, __webpack_require__) {
    var baseMatches = __webpack_require__(104), baseMatchesProperty = __webpack_require__(116), bindCallback = __webpack_require__(78), identity = __webpack_require__(79), property = __webpack_require__(123);
    function baseCallback(func, thisArg, argCount) {
        var type = typeof func;
        if ("function" == type) return void 0 === thisArg ? func : bindCallback(func, thisArg, argCount);
        if (null == func) return identity;
        if ("object" == type) return baseMatches(func);
        return void 0 === thisArg ? property(func) : baseMatchesProperty(func, thisArg);
    }
    module.exports = baseCallback;
}, function(module, exports, __webpack_require__) {
    var baseIsMatch = __webpack_require__(105), getMatchData = __webpack_require__(113), toObject = __webpack_require__(43);
    function baseMatches(source) {
        var matchData = getMatchData(source);
        if (1 == matchData.length && matchData[0][2]) {
            var key = matchData[0][0], value = matchData[0][1];
            return function(object) {
                if (null == object) return false;
                return object[key] === value && (void 0 !== value || key in toObject(object));
            };
        }
        return function(object) {
            return baseIsMatch(object, matchData);
        };
    }
    module.exports = baseMatches;
}, function(module, exports, __webpack_require__) {
    var baseIsEqual = __webpack_require__(106), toObject = __webpack_require__(43);
    function baseIsMatch(object, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (null == object) return !length;
        object = toObject(object);
        while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
        }
        while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
                if (void 0 === objValue && !(key in object)) return false;
            } else {
                var result = customizer ? customizer(objValue, srcValue, key) : void 0;
                if (!(void 0 === result ? baseIsEqual(srcValue, objValue, customizer, true) : result)) return false;
            }
        }
        return true;
    }
    module.exports = baseIsMatch;
}, function(module, exports, __webpack_require__) {
    var baseIsEqualDeep = __webpack_require__(107), isObject = __webpack_require__(44), isObjectLike = __webpack_require__(51);
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
        if (value === other) return true;
        if (null == value || null == other || !isObject(value) && !isObjectLike(other)) return value !== value && other !== other;
        return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }
    module.exports = baseIsEqual;
}, function(module, exports, __webpack_require__) {
    var equalArrays = __webpack_require__(108), equalByTag = __webpack_require__(110), equalObjects = __webpack_require__(111), isArray = __webpack_require__(52), isTypedArray = __webpack_require__(112);
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objToString = objectProto.toString;
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
        if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) objTag = objectTag; else if (objTag != objectTag) objIsArr = isTypedArray(object);
        }
        if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) othTag = objectTag; else if (othTag != objectTag) othIsArr = isTypedArray(other);
        }
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && !(objIsArr || objIsObj)) return equalByTag(object, other, objTag);
        if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
        if (!isSameTag) return false;
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--) if (stackA[length] == object) return stackB[length] == other;
        stackA.push(object);
        stackB.push(other);
        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
        stackA.pop();
        stackB.pop();
        return result;
    }
    module.exports = baseIsEqualDeep;
}, function(module, exports, __webpack_require__) {
    var arraySome = __webpack_require__(109);
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
        var index = -1, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isLoose && othLength > arrLength)) return false;
        while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index], result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : void 0;
            if (void 0 !== result) {
                if (result) continue;
                return false;
            }
            if (isLoose) {
                if (!arraySome(other, function(othValue) {
                    return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                })) return false;
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) return false;
        }
        return true;
    }
    module.exports = equalArrays;
}, function(module, exports) {
    function arraySome(array, predicate) {
        var index = -1, length = array.length;
        while (++index < length) if (predicate(array[index], index, array)) return true;
        return false;
    }
    module.exports = arraySome;
}, function(module, exports) {
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", numberTag = "[object Number]", regexpTag = "[object RegExp]", stringTag = "[object String]";
    function equalByTag(object, other, tag) {
        switch (tag) {
          case boolTag:
          case dateTag:
            return +object == +other;

          case errorTag:
            return object.name == other.name && object.message == other.message;

          case numberTag:
            return object != +object ? other != +other : object == +other;

          case regexpTag:
          case stringTag:
            return object == other + "";
        }
        return false;
    }
    module.exports = equalByTag;
}, function(module, exports, __webpack_require__) {
    var keys = __webpack_require__(66);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
        var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
        if (objLength != othLength && !isLoose) return false;
        var index = objLength;
        while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) return false;
        }
        var skipCtor = isLoose;
        while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key], result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : void 0;
            if (!(void 0 === result ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) return false;
            skipCtor || (skipCtor = "constructor" == key);
        }
        if (!skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor)) return false;
        }
        return true;
    }
    module.exports = equalObjects;
}, function(module, exports, __webpack_require__) {
    var isLength = __webpack_require__(50), isObjectLike = __webpack_require__(51);
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    function isTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }
    module.exports = isTypedArray;
}, function(module, exports, __webpack_require__) {
    var isStrictComparable = __webpack_require__(114), pairs = __webpack_require__(115);
    function getMatchData(object) {
        var result = pairs(object), length = result.length;
        while (length--) result[length][2] = isStrictComparable(result[length][1]);
        return result;
    }
    module.exports = getMatchData;
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(44);
    function isStrictComparable(value) {
        return value === value && !isObject(value);
    }
    module.exports = isStrictComparable;
}, function(module, exports, __webpack_require__) {
    var keys = __webpack_require__(66), toObject = __webpack_require__(43);
    function pairs(object) {
        object = toObject(object);
        var index = -1, props = keys(object), length = props.length, result = Array(length);
        while (++index < length) {
            var key = props[index];
            result[index] = [ key, object[key] ];
        }
        return result;
    }
    module.exports = pairs;
}, function(module, exports, __webpack_require__) {
    var baseGet = __webpack_require__(117), baseIsEqual = __webpack_require__(106), baseSlice = __webpack_require__(118), isArray = __webpack_require__(52), isKey = __webpack_require__(119), isStrictComparable = __webpack_require__(114), last = __webpack_require__(120), toObject = __webpack_require__(43), toPath = __webpack_require__(121);
    function baseMatchesProperty(path, srcValue) {
        var isArr = isArray(path), isCommon = isKey(path) && isStrictComparable(srcValue), pathKey = path + "";
        path = toPath(path);
        return function(object) {
            if (null == object) return false;
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
                object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1));
                if (null == object) return false;
                key = last(path);
                object = toObject(object);
            }
            return object[key] === srcValue ? void 0 !== srcValue || key in object : baseIsEqual(srcValue, object[key], void 0, true);
        };
    }
    module.exports = baseMatchesProperty;
}, function(module, exports, __webpack_require__) {
    var toObject = __webpack_require__(43);
    function baseGet(object, path, pathKey) {
        if (null == object) return;
        if (void 0 !== pathKey && pathKey in toObject(object)) path = [ pathKey ];
        var index = 0, length = path.length;
        while (null != object && index < length) object = object[path[index++]];
        return index && index == length ? object : void 0;
    }
    module.exports = baseGet;
}, function(module, exports) {
    function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        start = null == start ? 0 : +start || 0;
        if (start < 0) start = -start > length ? 0 : length + start;
        end = void 0 === end || end > length ? length : +end || 0;
        if (end < 0) end += length;
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) result[index] = array[index + start];
        return result;
    }
    module.exports = baseSlice;
}, function(module, exports, __webpack_require__) {
    var isArray = __webpack_require__(52), toObject = __webpack_require__(43);
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
        var type = typeof value;
        if ("string" == type && reIsPlainProp.test(value) || "number" == type) return true;
        if (isArray(value)) return false;
        var result = !reIsDeepProp.test(value);
        return result || null != object && value in toObject(object);
    }
    module.exports = isKey;
}, function(module, exports) {
    function last(array) {
        var length = array ? array.length : 0;
        return length ? array[length - 1] : void 0;
    }
    module.exports = last;
}, function(module, exports, __webpack_require__) {
    var baseToString = __webpack_require__(122), isArray = __webpack_require__(52);
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    var reEscapeChar = /\\(\\)?/g;
    function toPath(value) {
        if (isArray(value)) return value;
        var result = [];
        baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
    }
    module.exports = toPath;
}, function(module, exports) {
    function baseToString(value) {
        return null == value ? "" : value + "";
    }
    module.exports = baseToString;
}, function(module, exports, __webpack_require__) {
    var baseProperty = __webpack_require__(49), basePropertyDeep = __webpack_require__(124), isKey = __webpack_require__(119);
    function property(path) {
        return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }
    module.exports = property;
}, function(module, exports, __webpack_require__) {
    var baseGet = __webpack_require__(117), toPath = __webpack_require__(121);
    function basePropertyDeep(path) {
        var pathKey = path + "";
        path = toPath(path);
        return function(object) {
            return baseGet(object, path, pathKey);
        };
    }
    module.exports = basePropertyDeep;
}, function(module, exports, __webpack_require__) {
    var baseForOwn = __webpack_require__(126), createBaseEach = __webpack_require__(127);
    var baseEach = createBaseEach(baseForOwn);
    module.exports = baseEach;
}, function(module, exports, __webpack_require__) {
    var baseFor = __webpack_require__(41), keys = __webpack_require__(66);
    function baseForOwn(object, iteratee) {
        return baseFor(object, iteratee, keys);
    }
    module.exports = baseForOwn;
}, function(module, exports, __webpack_require__) {
    var getLength = __webpack_require__(48), isLength = __webpack_require__(50), toObject = __webpack_require__(43);
    function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) return eachFunc(collection, iteratee);
            var index = fromRight ? length : -1, iterable = toObject(collection);
            while (fromRight ? index-- : ++index < length) if (false === iteratee(iterable[index], index, iterable)) break;
            return collection;
        };
    }
    module.exports = createBaseEach;
}, function(module, exports, __webpack_require__) {
    var baseDifference = __webpack_require__(129), baseFlatten = __webpack_require__(76), isArrayLike = __webpack_require__(47), isObjectLike = __webpack_require__(51), restParam = __webpack_require__(82);
    var difference = restParam(function(array, values) {
        return isObjectLike(array) && isArrayLike(array) ? baseDifference(array, baseFlatten(values, false, true)) : [];
    });
    module.exports = difference;
}, function(module, exports, __webpack_require__) {
    var baseIndexOf = __webpack_require__(130), cacheIndexOf = __webpack_require__(132), createCache = __webpack_require__(133);
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values) {
        var length = array ? array.length : 0, result = [];
        if (!length) return result;
        var index = -1, indexOf = baseIndexOf, isCommon = true, cache = isCommon && values.length >= LARGE_ARRAY_SIZE ? createCache(values) : null, valuesLength = values.length;
        if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
        }
        outer: while (++index < length) {
            var value = array[index];
            if (isCommon && value === value) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) if (values[valuesIndex] === value) continue outer;
                result.push(value);
            } else if (indexOf(values, value, 0) < 0) result.push(value);
        }
        return result;
    }
    module.exports = baseDifference;
}, function(module, exports, __webpack_require__) {
    var indexOfNaN = __webpack_require__(131);
    function baseIndexOf(array, value, fromIndex) {
        if (value !== value) return indexOfNaN(array, fromIndex);
        var index = fromIndex - 1, length = array.length;
        while (++index < length) if (array[index] === value) return index;
        return -1;
    }
    module.exports = baseIndexOf;
}, function(module, exports) {
    function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
        while (fromRight ? index-- : ++index < length) {
            var other = array[index];
            if (other !== other) return index;
        }
        return -1;
    }
    module.exports = indexOfNaN;
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(44);
    function cacheIndexOf(cache, value) {
        var data = cache.data, result = "string" == typeof value || isObject(value) ? data.set.has(value) : data.hash[value];
        return result ? 0 : -1;
    }
    module.exports = cacheIndexOf;
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var SetCache = __webpack_require__(134), getNative = __webpack_require__(53);
        var Set = getNative(global, "Set");
        var nativeCreate = getNative(Object, "create");
        function createCache(values) {
            return nativeCreate && Set ? new SetCache(values) : null;
        }
        module.exports = createCache;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var cachePush = __webpack_require__(135), getNative = __webpack_require__(53);
        var Set = getNative(global, "Set");
        var nativeCreate = getNative(Object, "create");
        function SetCache(values) {
            var length = values ? values.length : 0;
            this.data = {
                hash: nativeCreate(null),
                set: new Set()
            };
            while (length--) this.push(values[length]);
        }
        SetCache.prototype.push = cachePush;
        module.exports = SetCache;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(44);
    function cachePush(value) {
        var data = this.data;
        if ("string" == typeof value || isObject(value)) data.set.add(value); else data.hash[value] = true;
    }
    module.exports = cachePush;
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(137);
}, function(module, exports, __webpack_require__) {
    var arrayEach = __webpack_require__(138), baseEach = __webpack_require__(125), createForEach = __webpack_require__(139);
    var forEach = createForEach(arrayEach, baseEach);
    module.exports = forEach;
}, function(module, exports) {
    function arrayEach(array, iteratee) {
        var index = -1, length = array.length;
        while (++index < length) if (false === iteratee(array[index], index, array)) break;
        return array;
    }
    module.exports = arrayEach;
}, function(module, exports, __webpack_require__) {
    var bindCallback = __webpack_require__(78), isArray = __webpack_require__(52);
    function createForEach(arrayFunc, eachFunc) {
        return function(collection, iteratee, thisArg) {
            return "function" == typeof iteratee && void 0 === thisArg && isArray(collection) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
        };
    }
    module.exports = createForEach;
}, function(module, exports, __webpack_require__) {
    var arrayMap = __webpack_require__(141), baseCallback = __webpack_require__(103), baseMap = __webpack_require__(142), isArray = __webpack_require__(52);
    function map(collection, iteratee, thisArg) {
        var func = isArray(collection) ? arrayMap : baseMap;
        iteratee = baseCallback(iteratee, thisArg, 3);
        return func(collection, iteratee);
    }
    module.exports = map;
}, function(module, exports) {
    function arrayMap(array, iteratee) {
        var index = -1, length = array.length, result = Array(length);
        while (++index < length) result[index] = iteratee(array[index], index, array);
        return result;
    }
    module.exports = arrayMap;
}, function(module, exports, __webpack_require__) {
    var baseEach = __webpack_require__(125), isArrayLike = __webpack_require__(47);
    function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
        });
        return result;
    }
    module.exports = baseMap;
}, function(module, exports, __webpack_require__) {
    var createExtremum = __webpack_require__(144), gt = __webpack_require__(148);
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
    var max = createExtremum(gt, NEGATIVE_INFINITY);
    module.exports = max;
}, function(module, exports, __webpack_require__) {
    var arrayExtremum = __webpack_require__(145), baseCallback = __webpack_require__(103), baseExtremum = __webpack_require__(146), isArray = __webpack_require__(52), isIterateeCall = __webpack_require__(98), toIterable = __webpack_require__(147);
    function createExtremum(comparator, exValue) {
        return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) iteratee = void 0;
            iteratee = baseCallback(iteratee, thisArg, 3);
            if (1 == iteratee.length) {
                collection = isArray(collection) ? collection : toIterable(collection);
                var result = arrayExtremum(collection, iteratee, comparator, exValue);
                if (!(collection.length && result === exValue)) return result;
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
        };
    }
    module.exports = createExtremum;
}, function(module, exports) {
    function arrayExtremum(array, iteratee, comparator, exValue) {
        var index = -1, length = array.length, computed = exValue, result = computed;
        while (++index < length) {
            var value = array[index], current = +iteratee(value);
            if (comparator(current, computed)) {
                computed = current;
                result = value;
            }
        }
        return result;
    }
    module.exports = arrayExtremum;
}, function(module, exports, __webpack_require__) {
    var baseEach = __webpack_require__(125);
    function baseExtremum(collection, iteratee, comparator, exValue) {
        var computed = exValue, result = computed;
        baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || current === exValue && current === result) {
                computed = current;
                result = value;
            }
        });
        return result;
    }
    module.exports = baseExtremum;
}, function(module, exports, __webpack_require__) {
    var isArrayLike = __webpack_require__(47), isObject = __webpack_require__(44), values = __webpack_require__(64);
    function toIterable(value) {
        if (null == value) return [];
        if (!isArrayLike(value)) return values(value);
        return isObject(value) ? value : Object(value);
    }
    module.exports = toIterable;
}, function(module, exports) {
    function gt(value, other) {
        return value > other;
    }
    module.exports = gt;
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(44), now = __webpack_require__(150);
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    function debounce(func, wait, options) {
        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
        if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
        wait = wait < 0 ? 0 : +wait || 0;
        if (true === options) {
            var leading = true;
            trailing = false;
        } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = "maxWait" in options && nativeMax(+options.maxWait || 0, wait);
            trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function cancel() {
            if (timeoutId) clearTimeout(timeoutId);
            if (maxTimeoutId) clearTimeout(maxTimeoutId);
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = void 0;
        }
        function complete(isCalled, id) {
            if (id) clearTimeout(id);
            maxTimeoutId = timeoutId = trailingCall = void 0;
            if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) args = thisArg = void 0;
            }
        }
        function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) complete(trailingCall, maxTimeoutId); else timeoutId = setTimeout(delayed, remaining);
        }
        function maxDelayed() {
            complete(trailing, timeoutId);
        }
        function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (false === maxWait) var leadingCall = leading && !timeoutId; else {
                if (!maxTimeoutId && !leading) lastCalled = stamp;
                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0 || remaining > maxWait;
                if (isCalled) {
                    if (maxTimeoutId) maxTimeoutId = clearTimeout(maxTimeoutId);
                    lastCalled = stamp;
                    result = func.apply(thisArg, args);
                } else if (!maxTimeoutId) maxTimeoutId = setTimeout(maxDelayed, remaining);
            }
            if (isCalled && timeoutId) timeoutId = clearTimeout(timeoutId); else if (!timeoutId && wait !== maxWait) timeoutId = setTimeout(delayed, wait);
            if (leadingCall) {
                isCalled = true;
                result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) args = thisArg = void 0;
            return result;
        }
        debounced.cancel = cancel;
        return debounced;
    }
    module.exports = debounce;
}, function(module, exports, __webpack_require__) {
    var getNative = __webpack_require__(53);
    var nativeNow = getNative(Date, "now");
    var now = nativeNow || function() {
        return new Date().getTime();
    };
    module.exports = now;
}, function(module, exports, __webpack_require__) {
    var baseAssign = __webpack_require__(95), baseCreate = __webpack_require__(152), isIterateeCall = __webpack_require__(98);
    function create(prototype, properties, guard) {
        var result = baseCreate(prototype);
        if (guard && isIterateeCall(prototype, properties, guard)) properties = void 0;
        return properties ? baseAssign(result, properties) : result;
    }
    module.exports = create;
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(44);
    var baseCreate = function() {
        function object() {}
        return function(prototype) {
            if (isObject(prototype)) {
                object.prototype = prototype;
                var result = new object();
                object.prototype = void 0;
            }
            return result || {};
        };
    }();
    module.exports = baseCreate;
}, function(module, exports, __webpack_require__) {
    var isError = __webpack_require__(154), restParam = __webpack_require__(82);
    var attempt = restParam(function(func, args) {
        try {
            return func.apply(void 0, args);
        } catch (e) {
            return isError(e) ? e : new Error(e);
        }
    });
    module.exports = attempt;
}, function(module, exports, __webpack_require__) {
    var isObjectLike = __webpack_require__(51);
    var errorTag = "[object Error]";
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    function isError(value) {
        return isObjectLike(value) && "string" == typeof value.message && objToString.call(value) == errorTag;
    }
    module.exports = isError;
}, function(module, exports, __webpack_require__) {
    var debounce = __webpack_require__(149), isObject = __webpack_require__(44);
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
        if (false === options) leading = false; else if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
            leading: leading,
            maxWait: +wait,
            trailing: trailing
        });
    }
    module.exports = throttle;
}, function(module, exports, __webpack_require__) {
    var map = __webpack_require__(140), property = __webpack_require__(123);
    function pluck(collection, path) {
        return map(collection, property(path));
    }
    module.exports = pluck;
}, function(module, exports, __webpack_require__) {
    var baseMerge = __webpack_require__(158), createAssigner = __webpack_require__(97);
    var merge = createAssigner(baseMerge);
    module.exports = merge;
}, function(module, exports, __webpack_require__) {
    var arrayEach = __webpack_require__(138), baseMergeDeep = __webpack_require__(159), isArray = __webpack_require__(52), isArrayLike = __webpack_require__(47), isObject = __webpack_require__(44), isObjectLike = __webpack_require__(51), isTypedArray = __webpack_require__(112), keys = __webpack_require__(66);
    function baseMerge(object, source, customizer, stackA, stackB) {
        if (!isObject(object)) return object;
        var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)), props = isSrcArr ? void 0 : keys(source);
        arrayEach(props || source, function(srcValue, key) {
            if (props) {
                key = srcValue;
                srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
                stackA || (stackA = []);
                stackB || (stackB = []);
                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            } else {
                var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : void 0, isCommon = void 0 === result;
                if (isCommon) result = srcValue;
                if ((void 0 !== result || isSrcArr && !(key in object)) && (isCommon || (result === result ? result !== value : value === value))) object[key] = result;
            }
        });
        return object;
    }
    module.exports = baseMerge;
}, function(module, exports, __webpack_require__) {
    var arrayCopy = __webpack_require__(63), isArguments = __webpack_require__(46), isArray = __webpack_require__(52), isArrayLike = __webpack_require__(47), isPlainObject = __webpack_require__(39), isTypedArray = __webpack_require__(112), toPlainObject = __webpack_require__(160);
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
        var length = stackA.length, srcValue = source[key];
        while (length--) if (stackA[length] == srcValue) {
            object[key] = stackB[length];
            return;
        }
        var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : void 0, isCommon = void 0 === result;
        if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) result = isArray(value) ? value : isArrayLike(value) ? arrayCopy(value) : []; else if (isPlainObject(srcValue) || isArguments(srcValue)) result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {}; else isCommon = false;
        }
        stackA.push(srcValue);
        stackB.push(result);
        if (isCommon) object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB); else if (result === result ? result !== value : value === value) object[key] = result;
    }
    module.exports = baseMergeDeep;
}, function(module, exports, __webpack_require__) {
    var baseCopy = __webpack_require__(96), keysIn = __webpack_require__(45);
    function toPlainObject(value) {
        return baseCopy(value, keysIn(value));
    }
    module.exports = toPlainObject;
}, function(module, exports, __webpack_require__) {
    var baseClone = __webpack_require__(162), bindCallback = __webpack_require__(78);
    function cloneDeep(value, customizer, thisArg) {
        return "function" == typeof customizer ? baseClone(value, true, bindCallback(customizer, thisArg, 3)) : baseClone(value, true);
    }
    module.exports = cloneDeep;
}, function(module, exports, __webpack_require__) {
    var arrayCopy = __webpack_require__(63), arrayEach = __webpack_require__(138), baseAssign = __webpack_require__(95), baseForOwn = __webpack_require__(126), initCloneArray = __webpack_require__(163), initCloneByTag = __webpack_require__(164), initCloneObject = __webpack_require__(166), isArray = __webpack_require__(52), isObject = __webpack_require__(44);
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
        var result;
        if (customizer) result = object ? customizer(value, key, object) : customizer(value);
        if (void 0 !== result) return result;
        if (!isObject(value)) return value;
        var isArr = isArray(value);
        if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) return arrayCopy(value, result);
        } else {
            var tag = objToString.call(value), isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result = initCloneObject(isFunc ? {} : value);
                if (!isDeep) return baseAssign(result, value);
            } else return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
        }
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--) if (stackA[length] == value) return stackB[length];
        stackA.push(value);
        stackB.push(result);
        (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
        });
        return result;
    }
    module.exports = baseClone;
}, function(module, exports) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && "string" == typeof array[0] && hasOwnProperty.call(array, "index")) {
            result.index = array.index;
            result.input = array.input;
        }
        return result;
    }
    module.exports = initCloneArray;
}, function(module, exports, __webpack_require__) {
    var bufferClone = __webpack_require__(165);
    var boolTag = "[object Boolean]", dateTag = "[object Date]", numberTag = "[object Number]", regexpTag = "[object RegExp]", stringTag = "[object String]";
    var arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reFlags = /\w*$/;
    function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return bufferClone(object);

          case boolTag:
          case dateTag:
            return new Ctor(+object);

          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            var buffer = object.buffer;
            return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

          case numberTag:
          case stringTag:
            return new Ctor(object);

          case regexpTag:
            var result = new Ctor(object.source, reFlags.exec(object));
            result.lastIndex = object.lastIndex;
        }
        return result;
    }
    module.exports = initCloneByTag;
}, function(module, exports) {
    (function(global) {
        var ArrayBuffer = global.ArrayBuffer, Uint8Array = global.Uint8Array;
        function bufferClone(buffer) {
            var result = new ArrayBuffer(buffer.byteLength), view = new Uint8Array(result);
            view.set(new Uint8Array(buffer));
            return result;
        }
        module.exports = bufferClone;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports) {
    function initCloneObject(object) {
        var Ctor = object.constructor;
        if (!("function" == typeof Ctor && Ctor instanceof Ctor)) Ctor = Object;
        return new Ctor();
    }
    module.exports = initCloneObject;
}, function(module, exports, __webpack_require__) {
    var createWrapper = __webpack_require__(168), isIterateeCall = __webpack_require__(98);
    var ARY_FLAG = 128;
    var nativeMax = Math.max;
    function ary(func, n, guard) {
        if (guard && isIterateeCall(func, n, guard)) n = void 0;
        n = func && null == n ? func.length : nativeMax(+n || 0, 0);
        return createWrapper(func, ARY_FLAG, void 0, void 0, void 0, void 0, n);
    }
    module.exports = ary;
}, function(module, exports, __webpack_require__) {
    var baseSetData = __webpack_require__(169), createBindWrapper = __webpack_require__(171), createHybridWrapper = __webpack_require__(173), createPartialWrapper = __webpack_require__(188), getData = __webpack_require__(179), mergeData = __webpack_require__(189), setData = __webpack_require__(187);
    var BIND_FLAG = 1, BIND_KEY_FLAG = 2, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64;
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
        var isBindKey = bitmask & BIND_KEY_FLAG;
        if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
        var length = partials ? partials.length : 0;
        if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = void 0;
        }
        length -= holders ? holders.length : 0;
        if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = void 0;
        }
        var data = isBindKey ? void 0 : getData(func), newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
        if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
        }
        newData[9] = null == arity ? isBindKey ? 0 : func.length : nativeMax(arity - length, 0) || 0;
        if (bitmask == BIND_FLAG) var result = createBindWrapper(newData[0], newData[2]); else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) result = createPartialWrapper.apply(void 0, newData); else result = createHybridWrapper.apply(void 0, newData);
        var setter = data ? baseSetData : setData;
        return setter(result, newData);
    }
    module.exports = createWrapper;
}, function(module, exports, __webpack_require__) {
    var identity = __webpack_require__(79), metaMap = __webpack_require__(170);
    var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
    };
    module.exports = baseSetData;
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var getNative = __webpack_require__(53);
        var WeakMap = getNative(global, "WeakMap");
        var metaMap = WeakMap && new WeakMap();
        module.exports = metaMap;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var createCtorWrapper = __webpack_require__(172);
        function createBindWrapper(func, thisArg) {
            var Ctor = createCtorWrapper(func);
            function wrapper() {
                var fn = this && this !== global && this instanceof wrapper ? Ctor : func;
                return fn.apply(thisArg, arguments);
            }
            return wrapper;
        }
        module.exports = createBindWrapper;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    var baseCreate = __webpack_require__(152), isObject = __webpack_require__(44);
    function createCtorWrapper(Ctor) {
        return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();

              case 1:
                return new Ctor(args[0]);

              case 2:
                return new Ctor(args[0], args[1]);

              case 3:
                return new Ctor(args[0], args[1], args[2]);

              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);

              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);

              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
            return isObject(result) ? result : thisBinding;
        };
    }
    module.exports = createCtorWrapper;
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var arrayCopy = __webpack_require__(63), composeArgs = __webpack_require__(174), composeArgsRight = __webpack_require__(175), createCtorWrapper = __webpack_require__(172), isLaziable = __webpack_require__(176), reorder = __webpack_require__(185), replaceHolders = __webpack_require__(186), setData = __webpack_require__(187);
        var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128;
        var nativeMax = Math.max;
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurry = bitmask & CURRY_FLAG, isCurryBound = bitmask & CURRY_BOUND_FLAG, isCurryRight = bitmask & CURRY_RIGHT_FLAG, Ctor = isBindKey ? void 0 : createCtorWrapper(func);
            function wrapper() {
                var length = arguments.length, index = length, args = Array(length);
                while (index--) args[index] = arguments[index];
                if (partials) args = composeArgs(args, partials, holders);
                if (partialsRight) args = composeArgsRight(args, partialsRight, holdersRight);
                if (isCurry || isCurryRight) {
                    var placeholder = wrapper.placeholder, argsHolders = replaceHolders(args, placeholder);
                    length -= argsHolders.length;
                    if (length < arity) {
                        var newArgPos = argPos ? arrayCopy(argPos) : void 0, newArity = nativeMax(arity - length, 0), newsHolders = isCurry ? argsHolders : void 0, newHoldersRight = isCurry ? void 0 : argsHolders, newPartials = isCurry ? args : void 0, newPartialsRight = isCurry ? void 0 : args;
                        bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                        if (!isCurryBound) bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                        var newData = [ func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity ], result = createHybridWrapper.apply(void 0, newData);
                        if (isLaziable(func)) setData(result, newData);
                        result.placeholder = placeholder;
                        return result;
                    }
                }
                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                if (argPos) args = reorder(args, argPos);
                if (isAry && ary < args.length) args.length = ary;
                if (this && this !== global && this instanceof wrapper) fn = Ctor || createCtorWrapper(func);
                return fn.apply(thisBinding, args);
            }
            return wrapper;
        }
        module.exports = createHybridWrapper;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports) {
    var nativeMax = Math.max;
    function composeArgs(args, partials, holders) {
        var holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), leftIndex = -1, leftLength = partials.length, result = Array(leftLength + argsLength);
        while (++leftIndex < leftLength) result[leftIndex] = partials[leftIndex];
        while (++argsIndex < holdersLength) result[holders[argsIndex]] = args[argsIndex];
        while (argsLength--) result[leftIndex++] = args[argsIndex++];
        return result;
    }
    module.exports = composeArgs;
}, function(module, exports) {
    var nativeMax = Math.max;
    function composeArgsRight(args, partials, holders) {
        var holdersIndex = -1, holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), rightIndex = -1, rightLength = partials.length, result = Array(argsLength + rightLength);
        while (++argsIndex < argsLength) result[argsIndex] = args[argsIndex];
        var offset = argsIndex;
        while (++rightIndex < rightLength) result[offset + rightIndex] = partials[rightIndex];
        while (++holdersIndex < holdersLength) result[offset + holders[holdersIndex]] = args[argsIndex++];
        return result;
    }
    module.exports = composeArgsRight;
}, function(module, exports, __webpack_require__) {
    var LazyWrapper = __webpack_require__(177), getData = __webpack_require__(179), getFuncName = __webpack_require__(180), lodash = __webpack_require__(182);
    function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return false;
        if (func === other) return true;
        var data = getData(other);
        return !!data && func === data[0];
    }
    module.exports = isLaziable;
}, function(module, exports, __webpack_require__) {
    var baseCreate = __webpack_require__(152), baseLodash = __webpack_require__(178);
    var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
    function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = POSITIVE_INFINITY;
        this.__views__ = [];
    }
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;
    module.exports = LazyWrapper;
}, function(module, exports) {
    function baseLodash() {}
    module.exports = baseLodash;
}, function(module, exports, __webpack_require__) {
    var metaMap = __webpack_require__(170), noop = __webpack_require__(57);
    var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
    };
    module.exports = getData;
}, function(module, exports, __webpack_require__) {
    var realNames = __webpack_require__(181);
    function getFuncName(func) {
        var result = func.name + "", array = realNames[result], length = array ? array.length : 0;
        while (length--) {
            var data = array[length], otherFunc = data.func;
            if (null == otherFunc || otherFunc == func) return data.name;
        }
        return result;
    }
    module.exports = getFuncName;
}, function(module, exports) {
    var realNames = {};
    module.exports = realNames;
}, function(module, exports, __webpack_require__) {
    var LazyWrapper = __webpack_require__(177), LodashWrapper = __webpack_require__(183), baseLodash = __webpack_require__(178), isArray = __webpack_require__(52), isObjectLike = __webpack_require__(51), wrapperClone = __webpack_require__(184);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) return value;
            if (hasOwnProperty.call(value, "__chain__") && hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value);
        }
        return new LodashWrapper(value);
    }
    lodash.prototype = baseLodash.prototype;
    module.exports = lodash;
}, function(module, exports, __webpack_require__) {
    var baseCreate = __webpack_require__(152), baseLodash = __webpack_require__(178);
    function LodashWrapper(value, chainAll, actions) {
        this.__wrapped__ = value;
        this.__actions__ = actions || [];
        this.__chain__ = !!chainAll;
    }
    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;
    module.exports = LodashWrapper;
}, function(module, exports, __webpack_require__) {
    var LazyWrapper = __webpack_require__(177), LodashWrapper = __webpack_require__(183), arrayCopy = __webpack_require__(63);
    function wrapperClone(wrapper) {
        return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }
    module.exports = wrapperClone;
}, function(module, exports, __webpack_require__) {
    var arrayCopy = __webpack_require__(63), isIndex = __webpack_require__(56);
    var nativeMin = Math.min;
    function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = arrayCopy(array);
        while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : void 0;
        }
        return array;
    }
    module.exports = reorder;
}, function(module, exports) {
    var PLACEHOLDER = "__lodash_placeholder__";
    function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
        }
        return result;
    }
    module.exports = replaceHolders;
}, function(module, exports, __webpack_require__) {
    var baseSetData = __webpack_require__(169), now = __webpack_require__(150);
    var HOT_COUNT = 150, HOT_SPAN = 16;
    var setData = function() {
        var count = 0, lastCalled = 0;
        return function(key, value) {
            var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
                if (++count >= HOT_COUNT) return key;
            } else count = 0;
            return baseSetData(key, value);
        };
    }();
    module.exports = setData;
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var createCtorWrapper = __webpack_require__(172);
        var BIND_FLAG = 1;
        function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
            function wrapper() {
                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength);
                while (++leftIndex < leftLength) args[leftIndex] = partials[leftIndex];
                while (argsLength--) args[leftIndex++] = arguments[++argsIndex];
                var fn = this && this !== global && this instanceof wrapper ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, args);
            }
            return wrapper;
        }
        module.exports = createPartialWrapper;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    var arrayCopy = __webpack_require__(63), composeArgs = __webpack_require__(174), composeArgsRight = __webpack_require__(175), replaceHolders = __webpack_require__(186);
    var BIND_FLAG = 1, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, ARY_FLAG = 128, REARG_FLAG = 256;
    var PLACEHOLDER = "__lodash_placeholder__";
    var nativeMin = Math.min;
    function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < ARY_FLAG;
        var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG;
        if (!(isCommon || isCombo)) return data;
        if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
        }
        value = source[5];
        if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
        }
        value = source[7];
        if (value) data[7] = arrayCopy(value);
        if (srcBitmask & ARY_FLAG) data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8]);
        if (null == data[9]) data[9] = source[9];
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
    }
    module.exports = mergeData;
}, function(module, exports, __webpack_require__) {
    var baseToString = __webpack_require__(122);
    var nativeMin = Math.min;
    function endsWith(string, target, position) {
        string = baseToString(string);
        target += "";
        var length = string.length;
        position = void 0 === position ? length : nativeMin(position < 0 ? 0 : +position || 0, length);
        position -= target.length;
        return position >= 0 && string.indexOf(target, position) == position;
    }
    module.exports = endsWith;
}, function(module, exports, __webpack_require__) {
    (function(global) {
        var baseToString = __webpack_require__(122);
        var nativeFloor = Math.floor, nativeIsFinite = global.isFinite;
        function repeat(string, n) {
            var result = "";
            string = baseToString(string);
            n = +n;
            if (n < 1 || !string || !nativeIsFinite(n)) return result;
            do {
                if (n % 2) result += string;
                n = nativeFloor(n / 2);
                string += string;
            } while (n);
            return result;
        }
        module.exports = repeat;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(93);
}, function(module, exports, __webpack_require__) {
    var baseGet = __webpack_require__(117), toPath = __webpack_require__(121);
    function get(object, path, defaultValue) {
        var result = null == object ? void 0 : baseGet(object, toPath(path), path + "");
        return void 0 === result ? defaultValue : result;
    }
    module.exports = get;
}, function(module, exports, __webpack_require__) {
    var baseForOwn = __webpack_require__(126), createFindKey = __webpack_require__(195);
    var findKey = createFindKey(baseForOwn);
    module.exports = findKey;
}, function(module, exports, __webpack_require__) {
    var baseCallback = __webpack_require__(103), baseFind = __webpack_require__(196);
    function createFindKey(objectFunc) {
        return function(object, predicate, thisArg) {
            predicate = baseCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
        };
    }
    module.exports = createFindKey;
}, function(module, exports) {
    function baseFind(collection, predicate, eachFunc, retKey) {
        var result;
        eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
                result = retKey ? key : value;
                return false;
            }
        });
        return result;
    }
    module.exports = baseFind;
}, function(module, exports, __webpack_require__) {
    var baseEach = __webpack_require__(125), createFind = __webpack_require__(198);
    var find = createFind(baseEach);
    module.exports = find;
}, function(module, exports, __webpack_require__) {
    var baseCallback = __webpack_require__(103), baseFind = __webpack_require__(196), baseFindIndex = __webpack_require__(199), isArray = __webpack_require__(52);
    function createFind(eachFunc, fromRight) {
        return function(collection, predicate, thisArg) {
            predicate = baseCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
                var index = baseFindIndex(collection, predicate, fromRight);
                return index > -1 ? collection[index] : void 0;
            }
            return baseFind(collection, predicate, eachFunc);
        };
    }
    module.exports = createFind;
}, function(module, exports) {
    function baseFindIndex(array, predicate, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while (fromRight ? index-- : ++index < length) if (predicate(array[index], index, array)) return index;
        return -1;
    }
    module.exports = baseFindIndex;
}, function(module, exports, __webpack_require__) {
    var baseCallback = __webpack_require__(103), baseUniq = __webpack_require__(201), isIterateeCall = __webpack_require__(98), sortedUniq = __webpack_require__(202);
    function uniq(array, isSorted, iteratee, thisArg) {
        var length = array ? array.length : 0;
        if (!length) return [];
        if (null != isSorted && "boolean" != typeof isSorted) {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? void 0 : isSorted;
            isSorted = false;
        }
        iteratee = null == iteratee ? iteratee : baseCallback(iteratee, thisArg, 3);
        return isSorted ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
    }
    module.exports = uniq;
}, function(module, exports, __webpack_require__) {
    var baseIndexOf = __webpack_require__(130), cacheIndexOf = __webpack_require__(132), createCache = __webpack_require__(133);
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee) {
        var index = -1, indexOf = baseIndexOf, length = array.length, isCommon = true, isLarge = isCommon && length >= LARGE_ARRAY_SIZE, seen = isLarge ? createCache() : null, result = [];
        if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
        } else {
            isLarge = false;
            seen = iteratee ? [] : result;
        }
        outer: while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
            if (isCommon && value === value) {
                var seenIndex = seen.length;
                while (seenIndex--) if (seen[seenIndex] === computed) continue outer;
                if (iteratee) seen.push(computed);
                result.push(value);
            } else if (indexOf(seen, computed, 0) < 0) {
                if (iteratee || isLarge) seen.push(computed);
                result.push(value);
            }
        }
        return result;
    }
    module.exports = baseUniq;
}, function(module, exports) {
    function sortedUniq(array, iteratee) {
        var seen, index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
            if (!index || seen !== computed) {
                seen = computed;
                result[++resIndex] = value;
            }
        }
        return result;
    }
    module.exports = sortedUniq;
}, function(module, exports, __webpack_require__) {
    var isObjectLike = __webpack_require__(51);
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    function isNumber(value) {
        return "number" == typeof value || isObjectLike(value) && objToString.call(value) == numberTag;
    }
    module.exports = isNumber;
}, function(module, exports, __webpack_require__) {
    var arrayFilter = __webpack_require__(205), baseCallback = __webpack_require__(103), baseFilter = __webpack_require__(206), isArray = __webpack_require__(52);
    function filter(collection, predicate, thisArg) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        predicate = baseCallback(predicate, thisArg, 3);
        return func(collection, predicate);
    }
    module.exports = filter;
}, function(module, exports) {
    function arrayFilter(array, predicate) {
        var index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) result[++resIndex] = value;
        }
        return result;
    }
    module.exports = arrayFilter;
}, function(module, exports, __webpack_require__) {
    var baseEach = __webpack_require__(125);
    function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) result.push(value);
        });
        return result;
    }
    module.exports = baseFilter;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var CURLY_RX = /\{([^}]+)\}/g;
    var _ = __webpack_require__(91);
    exports.insertVars = function(tmpl, vars, options) {
        if ("string" !== typeof tmpl) return tmpl;
        if (!vars || "object" !== ("undefined" === typeof vars ? "undefined" : _typeof(vars))) return tmpl;
        options = _.defaults({}, options, {
            regex: CURLY_RX,
            getter: _.get,
            encode: null
        });
        return tmpl.replace(options.regex, function(match, varName) {
            varName = varName.trim();
            var replacement = options.getter(vars, varName);
            if (void 0 === replacement) return match; else return options.encode ? options.encode(replacement) : replacement;
        });
    };
    exports.insertUrlVars = function(tmpl, vars, options) {
        options = options || {};
        options.encode = options.encode || encodeURIComponent;
        return exports.insertVars(tmpl, vars, options);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asyncLib = __webpack_require__(209);
    var alarms = __webpack_require__(3);
    var frontendMessaging = __webpack_require__(213);
    var frontendInitSender = __webpack_require__(214);
    var cookiesYasoft = __webpack_require__(450);
    var auth = __webpack_require__(429);
    var uninstall = __webpack_require__(536);
    var settings = __webpack_require__(216);
    var settingsPlatformBridge = __webpack_require__(528);
    var database = __webpack_require__(295);
    var pickup = __webpack_require__(435);
    var collection = __webpack_require__(270);
    var branding = __webpack_require__(277);
    var backgrounds = __webpack_require__(390);
    var closedTabs = __webpack_require__(307);
    var platformConfigure = __webpack_require__(331);
    var cookiesYs = __webpack_require__(451);
    var gpauto = __webpack_require__(441);
    var remoteConfig = __webpack_require__(372);
    var advertisement = __webpack_require__(369);
    var backup = __webpack_require__(411);
    var formatMessage = __webpack_require__(58);
    var error = __webpack_require__(396);
    var buildInfo = __webpack_require__(20);
    var platformAbout = __webpack_require__(23);
    var platformClid = __webpack_require__(288);
    var browserInfo = __webpack_require__(22);
    var i18n = __webpack_require__(280);
    var buildData = __webpack_require__(218);
    var logLevels = __webpack_require__(527);
    var experiments = __webpack_require__(328);
    var runstate = __webpack_require__(344);
    var logger = __webpack_require__(5).create("Startup");
    var normalModules = [ logLevels, experiments, collection, pickup, __webpack_require__(530), __webpack_require__(222), backgrounds, cookiesYs, cookiesYasoft, __webpack_require__(398), __webpack_require__(350), __webpack_require__(502), __webpack_require__(363), remoteConfig, advertisement, __webpack_require__(363), __webpack_require__(557), __webpack_require__(462), backup, closedTabs, gpauto, __webpack_require__(499), __webpack_require__(452), __webpack_require__(545), __webpack_require__(434), __webpack_require__(302), __webpack_require__(500), __webpack_require__(501) ];
    window.debug = __webpack_require__(361).getters;
    exports.prepare = function() {
        logLevels.prepare();
        logHeader();
        error.attach(window);
    };
    exports.initCore = function(callback) {
        asyncLib.series([ platformClid.init.bind(platformClid), database.open.bind(database), settings.load.bind(settings), settingsPlatformBridge.init.bind(settingsPlatformBridge), branding.init.bind(branding) ], function(err) {
            if (err) logger.error("Error during init core modules: %s", err.message);
            try {
                platformConfigure({
                    showZen: false
                });
                platformConfigure({
                    fileDownloader: true
                });
                platformConfigure({
                    browserAction: true
                });
                i18n.init(branding.vars.defaultLocale);
            } catch (err) {
                logger.error("Error during platform configuration: %s", err.message);
            } finally {
                callback();
            }
        });
    };
    exports.initNormal = function() {
        normalModules.forEach(function(module) {
            if (module.init) module.init(); else throw new Error(formatMessage("No `init` method for module %j", module));
        });
        platformConfigure({
            removeIfAnotherInstance: true
        });
        platformConfigure({
            softExport: "init"
        });
        platformConfigure({
            barNavig: "init"
        });
        platformConfigure({
            ybImport: "init"
        });
    };
    exports.finalize = function(callback) {
        alarms.stopCaching();
        frontendMessaging.run();
        frontendInitSender.sendAll();
        auth.init();
        alarms.logAll();
        cookiesYasoft.set();
        uninstall.setup();
        runstate.setReady();
        callback();
    };
    function logHeader() {
        logger.info("======================== Initializing.. ========================");
        logger.info("Browser: %s %s", browserInfo.name, browserInfo.version);
        logger.info("Platform: %s %s-%s %s", platformAbout.id, buildInfo.getVersion(), buildInfo.getRevision(), !buildInfo.isDebug() ? "PROD" : "DEV");
        logger.info("Common backend: %s-%s (%s) %s", buildData.version, buildData.git.buildNumber, buildData.git.sha, buildData.git.release ? "PROD" : "DEV");
    }
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    (function(global, setImmediate, process) {
        !function() {
            var async = {};
            function noop() {}
            function identity(v) {
                return v;
            }
            function toBool(v) {
                return !!v;
            }
            function notId(v) {
                return !v;
            }
            var previous_async;
            var root = "object" === typeof self && self.self === self && self || "object" === typeof global && global.global === global && global || this;
            if (null != root) previous_async = root.async;
            async.noConflict = function() {
                root.async = previous_async;
                return async;
            };
            function only_once(fn) {
                return function() {
                    if (null === fn) throw new Error("Callback was already called.");
                    fn.apply(this, arguments);
                    fn = null;
                };
            }
            function _once(fn) {
                return function() {
                    if (null === fn) return;
                    fn.apply(this, arguments);
                    fn = null;
                };
            }
            var _toString = Object.prototype.toString;
            var _isArray = Array.isArray || function(obj) {
                return "[object Array]" === _toString.call(obj);
            };
            var _isObject = function(obj) {
                var type = typeof obj;
                return "function" === type || "object" === type && !!obj;
            };
            function _isArrayLike(arr) {
                return _isArray(arr) || "number" === typeof arr.length && arr.length >= 0 && arr.length % 1 === 0;
            }
            function _arrayEach(arr, iterator) {
                var index = -1, length = arr.length;
                while (++index < length) iterator(arr[index], index, arr);
            }
            function _map(arr, iterator) {
                var index = -1, length = arr.length, result = Array(length);
                while (++index < length) result[index] = iterator(arr[index], index, arr);
                return result;
            }
            function _range(count) {
                return _map(Array(count), function(v, i) {
                    return i;
                });
            }
            function _reduce(arr, iterator, memo) {
                _arrayEach(arr, function(x, i, a) {
                    memo = iterator(memo, x, i, a);
                });
                return memo;
            }
            function _forEachOf(object, iterator) {
                _arrayEach(_keys(object), function(key) {
                    iterator(object[key], key);
                });
            }
            function _indexOf(arr, item) {
                for (var i = 0; i < arr.length; i++) if (arr[i] === item) return i;
                return -1;
            }
            var _keys = Object.keys || function(obj) {
                var keys = [];
                for (var k in obj) if (obj.hasOwnProperty(k)) keys.push(k);
                return keys;
            };
            function _keyIterator(coll) {
                var i = -1;
                var len;
                var keys;
                if (_isArrayLike(coll)) {
                    len = coll.length;
                    return function() {
                        i++;
                        return i < len ? i : null;
                    };
                } else {
                    keys = _keys(coll);
                    len = keys.length;
                    return function() {
                        i++;
                        return i < len ? keys[i] : null;
                    };
                }
            }
            function _restParam(func, startIndex) {
                startIndex = null == startIndex ? func.length - 1 : +startIndex;
                return function() {
                    var length = Math.max(arguments.length - startIndex, 0);
                    var rest = Array(length);
                    for (var index = 0; index < length; index++) rest[index] = arguments[index + startIndex];
                    switch (startIndex) {
                      case 0:
                        return func.call(this, rest);

                      case 1:
                        return func.call(this, arguments[0], rest);
                    }
                };
            }
            function _withoutIndex(iterator) {
                return function(value, index, callback) {
                    return iterator(value, callback);
                };
            }
            var _setImmediate = "function" === typeof setImmediate && setImmediate;
            var _delay = _setImmediate ? function(fn) {
                _setImmediate(fn);
            } : function(fn) {
                setTimeout(fn, 0);
            };
            if ("object" === typeof process && "function" === typeof process.nextTick) async.nextTick = process.nextTick; else async.nextTick = _delay;
            async.setImmediate = _setImmediate ? _delay : async.nextTick;
            async.forEach = async.each = function(arr, iterator, callback) {
                return async.eachOf(arr, _withoutIndex(iterator), callback);
            };
            async.forEachSeries = async.eachSeries = function(arr, iterator, callback) {
                return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
            };
            async.forEachLimit = async.eachLimit = function(arr, limit, iterator, callback) {
                return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
            };
            async.forEachOf = async.eachOf = function(object, iterator, callback) {
                callback = _once(callback || noop);
                object = object || [];
                var iter = _keyIterator(object);
                var key, completed = 0;
                while (null != (key = iter())) {
                    completed += 1;
                    iterator(object[key], key, only_once(done));
                }
                if (0 === completed) callback(null);
                function done(err) {
                    completed--;
                    if (err) callback(err); else if (null === key && completed <= 0) callback(null);
                }
            };
            async.forEachOfSeries = async.eachOfSeries = function(obj, iterator, callback) {
                callback = _once(callback || noop);
                obj = obj || [];
                var nextKey = _keyIterator(obj);
                var key = nextKey();
                function iterate() {
                    var sync = true;
                    if (null === key) return callback(null);
                    iterator(obj[key], key, only_once(function(err) {
                        if (err) callback(err); else {
                            key = nextKey();
                            if (null === key) return callback(null); else if (sync) async.setImmediate(iterate); else iterate();
                        }
                    }));
                    sync = false;
                }
                iterate();
            };
            async.forEachOfLimit = async.eachOfLimit = function(obj, limit, iterator, callback) {
                _eachOfLimit(limit)(obj, iterator, callback);
            };
            function _eachOfLimit(limit) {
                return function(obj, iterator, callback) {
                    callback = _once(callback || noop);
                    obj = obj || [];
                    var nextKey = _keyIterator(obj);
                    if (limit <= 0) return callback(null);
                    var done = false;
                    var running = 0;
                    var errored = false;
                    !function replenish() {
                        if (done && running <= 0) return callback(null);
                        while (running < limit && !errored) {
                            var key = nextKey();
                            if (null === key) {
                                done = true;
                                if (running <= 0) callback(null);
                                return;
                            }
                            running += 1;
                            iterator(obj[key], key, only_once(function(err) {
                                running -= 1;
                                if (err) {
                                    callback(err);
                                    errored = true;
                                } else replenish();
                            }));
                        }
                    }();
                };
            }
            function doParallel(fn) {
                return function(obj, iterator, callback) {
                    return fn(async.eachOf, obj, iterator, callback);
                };
            }
            function doParallelLimit(fn) {
                return function(obj, limit, iterator, callback) {
                    return fn(_eachOfLimit(limit), obj, iterator, callback);
                };
            }
            function doSeries(fn) {
                return function(obj, iterator, callback) {
                    return fn(async.eachOfSeries, obj, iterator, callback);
                };
            }
            function _asyncMap(eachfn, arr, iterator, callback) {
                callback = _once(callback || noop);
                arr = arr || [];
                var results = _isArrayLike(arr) ? [] : {};
                eachfn(arr, function(value, index, callback) {
                    iterator(value, function(err, v) {
                        results[index] = v;
                        callback(err);
                    });
                }, function(err) {
                    callback(err, results);
                });
            }
            async.map = doParallel(_asyncMap);
            async.mapSeries = doSeries(_asyncMap);
            async.mapLimit = doParallelLimit(_asyncMap);
            async.inject = async.foldl = async.reduce = function(arr, memo, iterator, callback) {
                async.eachOfSeries(arr, function(x, i, callback) {
                    iterator(memo, x, function(err, v) {
                        memo = v;
                        callback(err);
                    });
                }, function(err) {
                    callback(err, memo);
                });
            };
            async.foldr = async.reduceRight = function(arr, memo, iterator, callback) {
                var reversed = _map(arr, identity).reverse();
                async.reduce(reversed, memo, iterator, callback);
            };
            async.transform = function(arr, memo, iterator, callback) {
                if (3 === arguments.length) {
                    callback = iterator;
                    iterator = memo;
                    memo = _isArray(arr) ? [] : {};
                }
                async.eachOf(arr, function(v, k, cb) {
                    iterator(memo, v, k, cb);
                }, function(err) {
                    callback(err, memo);
                });
            };
            function _filter(eachfn, arr, iterator, callback) {
                var results = [];
                eachfn(arr, function(x, index, callback) {
                    iterator(x, function(v) {
                        if (v) results.push({
                            index: index,
                            value: x
                        });
                        callback();
                    });
                }, function() {
                    callback(_map(results.sort(function(a, b) {
                        return a.index - b.index;
                    }), function(x) {
                        return x.value;
                    }));
                });
            }
            async.select = async.filter = doParallel(_filter);
            async.selectLimit = async.filterLimit = doParallelLimit(_filter);
            async.selectSeries = async.filterSeries = doSeries(_filter);
            function _reject(eachfn, arr, iterator, callback) {
                _filter(eachfn, arr, function(value, cb) {
                    iterator(value, function(v) {
                        cb(!v);
                    });
                }, callback);
            }
            async.reject = doParallel(_reject);
            async.rejectLimit = doParallelLimit(_reject);
            async.rejectSeries = doSeries(_reject);
            function _createTester(eachfn, check, getResult) {
                return function(arr, limit, iterator, cb) {
                    function done() {
                        if (cb) cb(getResult(false, void 0));
                    }
                    function iteratee(x, _, callback) {
                        if (!cb) return callback();
                        iterator(x, function(v) {
                            if (cb && check(v)) {
                                cb(getResult(true, x));
                                cb = iterator = false;
                            }
                            callback();
                        });
                    }
                    if (arguments.length > 3) eachfn(arr, limit, iteratee, done); else {
                        cb = iterator;
                        iterator = limit;
                        eachfn(arr, iteratee, done);
                    }
                };
            }
            async.any = async.some = _createTester(async.eachOf, toBool, identity);
            async.someLimit = _createTester(async.eachOfLimit, toBool, identity);
            async.all = async.every = _createTester(async.eachOf, notId, notId);
            async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
            function _findGetResult(v, x) {
                return x;
            }
            async.detect = _createTester(async.eachOf, identity, _findGetResult);
            async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
            async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);
            async.sortBy = function(arr, iterator, callback) {
                async.map(arr, function(x, callback) {
                    iterator(x, function(err, criteria) {
                        if (err) callback(err); else callback(null, {
                            value: x,
                            criteria: criteria
                        });
                    });
                }, function(err, results) {
                    if (err) return callback(err); else callback(null, _map(results.sort(comparator), function(x) {
                        return x.value;
                    }));
                });
                function comparator(left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                }
            };
            async.auto = function(tasks, concurrency, callback) {
                if ("function" === typeof arguments[1]) {
                    callback = concurrency;
                    concurrency = null;
                }
                callback = _once(callback || noop);
                var keys = _keys(tasks);
                var remainingTasks = keys.length;
                if (!remainingTasks) return callback(null);
                if (!concurrency) concurrency = remainingTasks;
                var results = {};
                var runningTasks = 0;
                var hasError = false;
                var listeners = [];
                function addListener(fn) {
                    listeners.unshift(fn);
                }
                function removeListener(fn) {
                    var idx = _indexOf(listeners, fn);
                    if (idx >= 0) listeners.splice(idx, 1);
                }
                function taskComplete() {
                    remainingTasks--;
                    _arrayEach(listeners.slice(0), function(fn) {
                        fn();
                    });
                }
                addListener(function() {
                    if (!remainingTasks) callback(null, results);
                });
                _arrayEach(keys, function(k) {
                    if (hasError) return;
                    var task = _isArray(tasks[k]) ? tasks[k] : [ tasks[k] ];
                    var taskCallback = _restParam(function(err, args) {
                        runningTasks--;
                        if (args.length <= 1) args = args[0];
                        if (err) {
                            var safeResults = {};
                            _forEachOf(results, function(val, rkey) {
                                safeResults[rkey] = val;
                            });
                            safeResults[k] = args;
                            hasError = true;
                            callback(err, safeResults);
                        } else {
                            results[k] = args;
                            async.setImmediate(taskComplete);
                        }
                    });
                    var requires = task.slice(0, task.length - 1);
                    var len = requires.length;
                    var dep;
                    while (len--) {
                        if (!(dep = tasks[requires[len]])) throw new Error("Has nonexistent dependency in " + requires.join(", "));
                        if (_isArray(dep) && _indexOf(dep, k) >= 0) throw new Error("Has cyclic dependencies");
                    }
                    function ready() {
                        return runningTasks < concurrency && _reduce(requires, function(a, x) {
                            return a && results.hasOwnProperty(x);
                        }, true) && !results.hasOwnProperty(k);
                    }
                    if (ready()) {
                        runningTasks++;
                        task[task.length - 1](taskCallback, results);
                    } else addListener(listener);
                    function listener() {
                        if (ready()) {
                            runningTasks++;
                            removeListener(listener);
                            task[task.length - 1](taskCallback, results);
                        }
                    }
                });
            };
            async.retry = function(times, task, callback) {
                var DEFAULT_TIMES = 5;
                var DEFAULT_INTERVAL = 0;
                var attempts = [];
                var opts = {
                    times: DEFAULT_TIMES,
                    interval: DEFAULT_INTERVAL
                };
                function parseTimes(acc, t) {
                    if ("number" === typeof t) acc.times = parseInt(t, 10) || DEFAULT_TIMES; else if ("object" === typeof t) {
                        acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                        acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
                    } else throw new Error("Unsupported argument type for 'times': " + typeof t);
                }
                var length = arguments.length;
                if (length < 1 || length > 3) throw new Error("Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)"); else if (length <= 2 && "function" === typeof times) {
                    callback = task;
                    task = times;
                }
                if ("function" !== typeof times) parseTimes(opts, times);
                opts.callback = callback;
                opts.task = task;
                function wrappedTask(wrappedCallback, wrappedResults) {
                    function retryAttempt(task, finalAttempt) {
                        return function(seriesCallback) {
                            task(function(err, result) {
                                seriesCallback(!err || finalAttempt, {
                                    err: err,
                                    result: result
                                });
                            }, wrappedResults);
                        };
                    }
                    function retryInterval(interval) {
                        return function(seriesCallback) {
                            setTimeout(function() {
                                seriesCallback(null);
                            }, interval);
                        };
                    }
                    while (opts.times) {
                        var finalAttempt = !(opts.times -= 1);
                        attempts.push(retryAttempt(opts.task, finalAttempt));
                        if (!finalAttempt && opts.interval > 0) attempts.push(retryInterval(opts.interval));
                    }
                    async.series(attempts, function(done, data) {
                        data = data[data.length - 1];
                        (wrappedCallback || opts.callback)(data.err, data.result);
                    });
                }
                return opts.callback ? wrappedTask() : wrappedTask;
            };
            async.waterfall = function(tasks, callback) {
                callback = _once(callback || noop);
                if (!_isArray(tasks)) {
                    var err = new Error("First argument to waterfall must be an array of functions");
                    return callback(err);
                }
                if (!tasks.length) return callback();
                function wrapIterator(iterator) {
                    return _restParam(function(err, args) {
                        if (err) callback.apply(null, [ err ].concat(args)); else {
                            var next = iterator.next();
                            if (next) args.push(wrapIterator(next)); else args.push(callback);
                            ensureAsync(iterator).apply(null, args);
                        }
                    });
                }
                wrapIterator(async.iterator(tasks))();
            };
            function _parallel(eachfn, tasks, callback) {
                callback = callback || noop;
                var results = _isArrayLike(tasks) ? [] : {};
                eachfn(tasks, function(task, key, callback) {
                    task(_restParam(function(err, args) {
                        if (args.length <= 1) args = args[0];
                        results[key] = args;
                        callback(err);
                    }));
                }, function(err) {
                    callback(err, results);
                });
            }
            async.parallel = function(tasks, callback) {
                _parallel(async.eachOf, tasks, callback);
            };
            async.parallelLimit = function(tasks, limit, callback) {
                _parallel(_eachOfLimit(limit), tasks, callback);
            };
            async.series = function(tasks, callback) {
                _parallel(async.eachOfSeries, tasks, callback);
            };
            async.iterator = function(tasks) {
                function makeCallback(index) {
                    function fn() {
                        if (tasks.length) tasks[index].apply(null, arguments);
                        return fn.next();
                    }
                    fn.next = function() {
                        return index < tasks.length - 1 ? makeCallback(index + 1) : null;
                    };
                    return fn;
                }
                return makeCallback(0);
            };
            async.apply = _restParam(function(fn, args) {
                return _restParam(function(callArgs) {
                    return fn.apply(null, args.concat(callArgs));
                });
            });
            function _concat(eachfn, arr, fn, callback) {
                var result = [];
                eachfn(arr, function(x, index, cb) {
                    fn(x, function(err, y) {
                        result = result.concat(y || []);
                        cb(err);
                    });
                }, function(err) {
                    callback(err, result);
                });
            }
            async.concat = doParallel(_concat);
            async.concatSeries = doSeries(_concat);
            async.whilst = function(test, iterator, callback) {
                callback = callback || noop;
                if (test()) {
                    var next = _restParam(function(err, args) {
                        if (err) callback(err); else if (test.apply(this, args)) iterator(next); else callback.apply(null, [ null ].concat(args));
                    });
                    iterator(next);
                } else callback(null);
            };
            async.doWhilst = function(iterator, test, callback) {
                var calls = 0;
                return async.whilst(function() {
                    return ++calls <= 1 || test.apply(this, arguments);
                }, iterator, callback);
            };
            async.until = function(test, iterator, callback) {
                return async.whilst(function() {
                    return !test.apply(this, arguments);
                }, iterator, callback);
            };
            async.doUntil = function(iterator, test, callback) {
                return async.doWhilst(iterator, function() {
                    return !test.apply(this, arguments);
                }, callback);
            };
            async.during = function(test, iterator, callback) {
                callback = callback || noop;
                var next = _restParam(function(err, args) {
                    if (err) callback(err); else {
                        args.push(check);
                        test.apply(this, args);
                    }
                });
                var check = function(err, truth) {
                    if (err) callback(err); else if (truth) iterator(next); else callback(null);
                };
                test(check);
            };
            async.doDuring = function(iterator, test, callback) {
                var calls = 0;
                async.during(function(next) {
                    if (calls++ < 1) next(null, true); else test.apply(this, arguments);
                }, iterator, callback);
            };
            function _queue(worker, concurrency, payload) {
                if (null == concurrency) concurrency = 1; else if (0 === concurrency) throw new Error("Concurrency must not be zero");
                function _insert(q, data, pos, callback) {
                    if (null != callback && "function" !== typeof callback) throw new Error("task callback must be a function");
                    q.started = true;
                    if (!_isArray(data)) data = [ data ];
                    if (0 === data.length && q.idle()) return async.setImmediate(function() {
                        q.drain();
                    });
                    _arrayEach(data, function(task) {
                        var item = {
                            data: task,
                            callback: callback || noop
                        };
                        if (pos) q.tasks.unshift(item); else q.tasks.push(item);
                        if (q.tasks.length === q.concurrency) q.saturated();
                    });
                    async.setImmediate(q.process);
                }
                function _next(q, tasks) {
                    return function() {
                        workers -= 1;
                        var removed = false;
                        var args = arguments;
                        _arrayEach(tasks, function(task) {
                            _arrayEach(workersList, function(worker, index) {
                                if (worker === task && !removed) {
                                    workersList.splice(index, 1);
                                    removed = true;
                                }
                            });
                            task.callback.apply(task, args);
                        });
                        if (q.tasks.length + workers === 0) q.drain();
                        q.process();
                    };
                }
                var workers = 0;
                var workersList = [];
                var q = {
                    tasks: [],
                    concurrency: concurrency,
                    payload: payload,
                    saturated: noop,
                    empty: noop,
                    drain: noop,
                    started: false,
                    paused: false,
                    push: function(data, callback) {
                        _insert(q, data, false, callback);
                    },
                    kill: function() {
                        q.drain = noop;
                        q.tasks = [];
                    },
                    unshift: function(data, callback) {
                        _insert(q, data, true, callback);
                    },
                    process: function() {
                        while (!q.paused && workers < q.concurrency && q.tasks.length) {
                            var tasks = q.payload ? q.tasks.splice(0, q.payload) : q.tasks.splice(0, q.tasks.length);
                            var data = _map(tasks, function(task) {
                                return task.data;
                            });
                            if (0 === q.tasks.length) q.empty();
                            workers += 1;
                            workersList.push(tasks[0]);
                            var cb = only_once(_next(q, tasks));
                            worker(data, cb);
                        }
                    },
                    length: function() {
                        return q.tasks.length;
                    },
                    running: function() {
                        return workers;
                    },
                    workersList: function() {
                        return workersList;
                    },
                    idle: function() {
                        return q.tasks.length + workers === 0;
                    },
                    pause: function() {
                        q.paused = true;
                    },
                    resume: function() {
                        if (false === q.paused) return;
                        q.paused = false;
                        var resumeCount = Math.min(q.concurrency, q.tasks.length);
                        for (var w = 1; w <= resumeCount; w++) async.setImmediate(q.process);
                    }
                };
                return q;
            }
            async.queue = function(worker, concurrency) {
                var q = _queue(function(items, cb) {
                    worker(items[0], cb);
                }, concurrency, 1);
                return q;
            };
            async.priorityQueue = function(worker, concurrency) {
                function _compareTasks(a, b) {
                    return a.priority - b.priority;
                }
                function _binarySearch(sequence, item, compare) {
                    var beg = -1, end = sequence.length - 1;
                    while (beg < end) {
                        var mid = beg + (end - beg + 1 >>> 1);
                        if (compare(item, sequence[mid]) >= 0) beg = mid; else end = mid - 1;
                    }
                    return beg;
                }
                function _insert(q, data, priority, callback) {
                    if (null != callback && "function" !== typeof callback) throw new Error("task callback must be a function");
                    q.started = true;
                    if (!_isArray(data)) data = [ data ];
                    if (0 === data.length) return async.setImmediate(function() {
                        q.drain();
                    });
                    _arrayEach(data, function(task) {
                        var item = {
                            data: task,
                            priority: priority,
                            callback: "function" === typeof callback ? callback : noop
                        };
                        q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
                        if (q.tasks.length === q.concurrency) q.saturated();
                        async.setImmediate(q.process);
                    });
                }
                var q = async.queue(worker, concurrency);
                q.push = function(data, priority, callback) {
                    _insert(q, data, priority, callback);
                };
                delete q.unshift;
                return q;
            };
            async.cargo = function(worker, payload) {
                return _queue(worker, 1, payload);
            };
            function _console_fn(name) {
                return _restParam(function(fn, args) {
                    fn.apply(null, args.concat([ _restParam(function(err, args) {
                        if ("object" === typeof console) if (err) {
                            if (console.error) console.error(err);
                        } else if (console[name]) _arrayEach(args, function(x) {
                            console[name](x);
                        });
                    }) ]));
                });
            }
            async.log = _console_fn("log");
            async.dir = _console_fn("dir");
            async.memoize = function(fn, hasher) {
                var memo = {};
                var queues = {};
                var has = Object.prototype.hasOwnProperty;
                hasher = hasher || identity;
                var memoized = _restParam(function(args) {
                    var callback = args.pop();
                    var key = hasher.apply(null, args);
                    if (has.call(memo, key)) async.setImmediate(function() {
                        callback.apply(null, memo[key]);
                    }); else if (has.call(queues, key)) queues[key].push(callback); else {
                        queues[key] = [ callback ];
                        fn.apply(null, args.concat([ _restParam(function(args) {
                            memo[key] = args;
                            var q = queues[key];
                            delete queues[key];
                            for (var i = 0, l = q.length; i < l; i++) q[i].apply(null, args);
                        }) ]));
                    }
                });
                memoized.memo = memo;
                memoized.unmemoized = fn;
                return memoized;
            };
            async.unmemoize = function(fn) {
                return function() {
                    return (fn.unmemoized || fn).apply(null, arguments);
                };
            };
            function _times(mapper) {
                return function(count, iterator, callback) {
                    mapper(_range(count), iterator, callback);
                };
            }
            async.times = _times(async.map);
            async.timesSeries = _times(async.mapSeries);
            async.timesLimit = function(count, limit, iterator, callback) {
                return async.mapLimit(_range(count), limit, iterator, callback);
            };
            async.seq = function() {
                var fns = arguments;
                return _restParam(function(args) {
                    var that = this;
                    var callback = args[args.length - 1];
                    if ("function" == typeof callback) args.pop(); else callback = noop;
                    async.reduce(fns, args, function(newargs, fn, cb) {
                        fn.apply(that, newargs.concat([ _restParam(function(err, nextargs) {
                            cb(err, nextargs);
                        }) ]));
                    }, function(err, results) {
                        callback.apply(that, [ err ].concat(results));
                    });
                });
            };
            async.compose = function() {
                return async.seq.apply(null, Array.prototype.reverse.call(arguments));
            };
            function _applyEach(eachfn) {
                return _restParam(function(fns, args) {
                    var go = _restParam(function(args) {
                        var that = this;
                        var callback = args.pop();
                        return eachfn(fns, function(fn, _, cb) {
                            fn.apply(that, args.concat([ cb ]));
                        }, callback);
                    });
                    if (args.length) return go.apply(this, args); else return go;
                });
            }
            async.applyEach = _applyEach(async.eachOf);
            async.applyEachSeries = _applyEach(async.eachOfSeries);
            async.forever = function(fn, callback) {
                var done = only_once(callback || noop);
                var task = ensureAsync(fn);
                function next(err) {
                    if (err) return done(err);
                    task(next);
                }
                next();
            };
            function ensureAsync(fn) {
                return _restParam(function(args) {
                    var callback = args.pop();
                    args.push(function() {
                        var innerArgs = arguments;
                        if (sync) async.setImmediate(function() {
                            callback.apply(null, innerArgs);
                        }); else callback.apply(null, innerArgs);
                    });
                    var sync = true;
                    fn.apply(this, args);
                    sync = false;
                });
            }
            async.ensureAsync = ensureAsync;
            async.constant = _restParam(function(values) {
                var args = [ null ].concat(values);
                return function(callback) {
                    return callback.apply(this, args);
                };
            });
            async.wrapSync = async.asyncify = function(func) {
                return _restParam(function(args) {
                    var callback = args.pop();
                    var result;
                    try {
                        result = func.apply(this, args);
                    } catch (e) {
                        return callback(e);
                    }
                    if (_isObject(result) && "function" === typeof result.then) result.then(function(value) {
                        callback(null, value);
                    })["catch"](function(err) {
                        callback(err.message ? err : new Error(err));
                    }); else callback(null, result);
                });
            };
            if ("object" === typeof module && module.exports) module.exports = async; else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], 
            __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return async;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else root.async = async;
        }();
    }).call(exports, function() {
        return this;
    }(), __webpack_require__(210).setImmediate, __webpack_require__(212));
}, function(module, exports, __webpack_require__) {
    var apply = Function.prototype.apply;
    exports.setTimeout = function() {
        return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
    };
    exports.setInterval = function() {
        return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
    };
    exports.clearTimeout = exports.clearInterval = function(timeout) {
        if (timeout) timeout.close();
    };
    function Timeout(id, clearFn) {
        this._id = id;
        this._clearFn = clearFn;
    }
    Timeout.prototype.unref = Timeout.prototype.ref = function() {};
    Timeout.prototype.close = function() {
        this._clearFn.call(window, this._id);
    };
    exports.enroll = function(item, msecs) {
        clearTimeout(item._idleTimeoutId);
        item._idleTimeout = msecs;
    };
    exports.unenroll = function(item) {
        clearTimeout(item._idleTimeoutId);
        item._idleTimeout = -1;
    };
    exports._unrefActive = exports.active = function(item) {
        clearTimeout(item._idleTimeoutId);
        var msecs = item._idleTimeout;
        if (msecs >= 0) item._idleTimeoutId = setTimeout(function() {
            if (item._onTimeout) item._onTimeout();
        }, msecs);
    };
    __webpack_require__(211);
    exports.setImmediate = setImmediate;
    exports.clearImmediate = clearImmediate;
}, function(module, exports, __webpack_require__) {
    (function(global, process) {
        !function(global, undefined) {
            "use strict";
            if (global.setImmediate) return;
            var nextHandle = 1;
            var tasksByHandle = {};
            var currentlyRunningATask = false;
            var doc = global.document;
            var registerImmediate;
            function setImmediate(callback) {
                if ("function" !== typeof callback) callback = new Function("" + callback);
                var args = new Array(arguments.length - 1);
                for (var i = 0; i < args.length; i++) args[i] = arguments[i + 1];
                var task = {
                    callback: callback,
                    args: args
                };
                tasksByHandle[nextHandle] = task;
                registerImmediate(nextHandle);
                return nextHandle++;
            }
            function clearImmediate(handle) {
                delete tasksByHandle[handle];
            }
            function run(task) {
                var callback = task.callback;
                var args = task.args;
                switch (args.length) {
                  case 0:
                    callback();
                    break;

                  case 1:
                    callback(args[0]);
                    break;

                  case 2:
                    callback(args[0], args[1]);
                    break;

                  case 3:
                    callback(args[0], args[1], args[2]);
                    break;

                  default:
                    callback.apply(undefined, args);
                }
            }
            function runIfPresent(handle) {
                if (currentlyRunningATask) setTimeout(runIfPresent, 0, handle); else {
                    var task = tasksByHandle[handle];
                    if (task) {
                        currentlyRunningATask = true;
                        try {
                            run(task);
                        } finally {
                            clearImmediate(handle);
                            currentlyRunningATask = false;
                        }
                    }
                }
            }
            function installNextTickImplementation() {
                registerImmediate = function(handle) {
                    process.nextTick(function() {
                        runIfPresent(handle);
                    });
                };
            }
            function canUsePostMessage() {
                if (global.postMessage && !global.importScripts) {
                    var postMessageIsAsynchronous = true;
                    var oldOnMessage = global.onmessage;
                    global.onmessage = function() {
                        postMessageIsAsynchronous = false;
                    };
                    global.postMessage("", "*");
                    global.onmessage = oldOnMessage;
                    return postMessageIsAsynchronous;
                }
            }
            function installPostMessageImplementation() {
                var messagePrefix = "setImmediate$" + Math.random() + "$";
                var onGlobalMessage = function(event) {
                    if (event.source === global && "string" === typeof event.data && 0 === event.data.indexOf(messagePrefix)) runIfPresent(+event.data.slice(messagePrefix.length));
                };
                if (global.addEventListener) global.addEventListener("message", onGlobalMessage, false); else global.attachEvent("onmessage", onGlobalMessage);
                registerImmediate = function(handle) {
                    global.postMessage(messagePrefix + handle, "*");
                };
            }
            function installMessageChannelImplementation() {
                var channel = new MessageChannel();
                channel.port1.onmessage = function(event) {
                    var handle = event.data;
                    runIfPresent(handle);
                };
                registerImmediate = function(handle) {
                    channel.port2.postMessage(handle);
                };
            }
            function installReadyStateChangeImplementation() {
                var html = doc.documentElement;
                registerImmediate = function(handle) {
                    var script = doc.createElement("script");
                    script.onreadystatechange = function() {
                        runIfPresent(handle);
                        script.onreadystatechange = null;
                        html.removeChild(script);
                        script = null;
                    };
                    html.appendChild(script);
                };
            }
            function installSetTimeoutImplementation() {
                registerImmediate = function(handle) {
                    setTimeout(runIfPresent, 0, handle);
                };
            }
            var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
            attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
            if ("[object process]" === {}.toString.call(global.process)) installNextTickImplementation(); else if (canUsePostMessage()) installPostMessageImplementation(); else if (global.MessageChannel) installMessageChannelImplementation(); else if (doc && "onreadystatechange" in doc.createElement("script")) installReadyStateChangeImplementation(); else installSetTimeoutImplementation();
            attachTo.setImmediate = setImmediate;
            attachTo.clearImmediate = clearImmediate;
        }("undefined" === typeof self ? "undefined" === typeof global ? this : global : self);
    }).call(exports, function() {
        return this;
    }(), __webpack_require__(212));
}, function(module, exports) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
    }
    !function() {
        try {
            if ("function" === typeof setTimeout) cachedSetTimeout = setTimeout; else cachedSetTimeout = defaultSetTimout;
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if ("function" === typeof clearTimeout) cachedClearTimeout = clearTimeout; else cachedClearTimeout = defaultClearTimeout;
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    }();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
        if (!draining || !currentQueue) return;
        draining = false;
        if (currentQueue.length) queue = currentQueue.concat(queue); else queueIndex = -1;
        if (queue.length) drainQueue();
    }
    function drainQueue() {
        if (draining) return;
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) if (currentQueue) currentQueue[queueIndex].run();
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
        queue.push(new Item(fun, args));
        if (1 === queue.length && !draining) runTimeout(drainQueue);
    };
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function() {
        this.fun.apply(null, this.array);
    };
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = "";
    process.versions = {};
    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    process.listeners = function(name) {
        return [];
    };
    process.binding = function(name) {
        throw new Error("process.binding is not supported");
    };
    process.cwd = function() {
        return "/";
    };
    process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
    };
    process.umask = function() {
        return 0;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var logger = __webpack_require__(5).create("Frontend/messaging");
    var formatMessage = __webpack_require__(58);
    var isRunning = false;
    var listeners = {};
    exports.run = function() {
        isRunning = true;
        chrome.runtime.onMessage.addListener(onMessage);
        logger.info("Start messaging");
    };
    exports.send = function(command, data, tabId) {
        if (!isRunning) return;
        var msgBody = {
            type: command,
            data: data
        };
        if (tabId) {
            logger.info("Message sent to frontend in tab %i: %s %j", tabId, command, data);
            chrome.tabs.sendMessage(parseInt(tabId, 10), msgBody);
        } else {
            logger.info("Message sent to all frontends: %s %j", command, data);
            chrome.runtime.sendMessage(msgBody, utils.noop);
        }
    };
    exports.on = function(action, fn) {
        if ("function" !== typeof fn) throw new Error(formatMessage("Function required for listener: %s", action));
        if (listeners[action]) throw new Error(formatMessage("Dublicate action listener: %s", action)); else listeners[action] = fn;
    };
    function onMessage(req, sender, sendResponse) {
        if (!isRunning) {
            logger.error("Can not process frontend action %j as module is not running", req);
            return;
        }
        var action = req && req.action;
        if (!action) return;
        if (listeners[action]) {
            var sendResponseSafe = wrapSendResponse(action, sendResponse);
            return listeners[action](req, sender, sendResponseSafe);
        } else logger.error("Listener not found for action: %s", action);
    }
    function wrapSendResponse(action, sendResponse) {
        return function() {
            try {
                Function.prototype.apply.call(sendResponse, null, arguments);
            } catch (e) {
                logger.warn("sendResponse failed for action %s: %s", action, e.message);
            }
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Frontend-init");
    var messaging = __webpack_require__(213);
    var checkboxes = __webpack_require__(215);
    var settings = __webpack_require__(216);
    var buildData = __webpack_require__(218);
    var closedTabs = __webpack_require__(307);
    var experiments = __webpack_require__(328);
    var tabs = __webpack_require__(282);
    var platformAbout = __webpack_require__(23);
    var debugPanel = __webpack_require__(360);
    var customLogo = __webpack_require__(461);
    var advertisement = __webpack_require__(454);
    var aboutPlatform = __webpack_require__(23);
    var branding = __webpack_require__(277);
    var frontendInformers = __webpack_require__(484);
    var events = __webpack_require__(268);
    var initChecker = __webpack_require__(497);
    var auth = __webpack_require__(456);
    var zen = __webpack_require__(494);
    var isSendingToAll = false;
    var processedTabIds = [];
    exports.init = function() {
        messaging.on(events.frontend.INIT, function(req, sender) {
            if (sender && sender.tab) {
                var tab = sender.tab;
                logger.info("Got init request from tab %i", tab.id);
                if (isSendingToAll) processedTabIds.push(tab.id);
                exports.send(tab);
                initChecker.started(tab.id);
            }
        });
        messaging.on(events.frontend.DRAW_FINISHED, function(req, sender) {
            initChecker.loaded(sender.tab.id);
        });
    };
    exports.send = function(tab) {
        if (!tab.id) {
            logger.error("Empty tab.id");
            return;
        }
        if (!tab.windowId) {
            logger.error("Empty tab.windowId");
            return;
        }
        var result = collectInitData({
            windowId: tab.windowId,
            tabId: tab.id
        });
        messaging.send(events.backend.INIT, result, tab.id);
        if (result.showBookmarks) __webpack_require__(219).sendRootItems(tab.id);
        if (result.zen) zen.sendZenConfig(tab.id);
        frontendInformers.send();
        if (result.debug) debugPanel.send(tab.id);
    };
    exports.sendAll = function() {
        logger.info("Trying send init to all open frontends...");
        isSendingToAll = true;
        tabs.getOpen(function(err, items) {
            items = Array.isArray(items) ? items : [];
            var frontends = items.filter(function(tab) {
                return tab.url === platformAbout.visbookmarksUrl && processedTabIds.indexOf(tab.id) === -1;
            });
            isSendingToAll = false;
            processedTabIds.length = 0;
            logger.info("Frontends found: %i", frontends.length);
            frontends.forEach(exports.send);
        });
    };
    function collectInitData(info) {
        logger.info("Collecting init data..");
        var checkValues = checkboxes.getValues();
        var result = {};
        result.background = __webpack_require__(389).getCurrent();
        result.thumbs = __webpack_require__(269).getAll();
        result.locale = __webpack_require__(280).locale;
        result.branding = getBranding();
        result.auth = auth.getAuth();
        result.debug = !buildData.git.release;
        result.debugMode = settings.get("debugMode");
        result.showBookmarks = checkValues.showBookmarks;
        result.showSearchForm = checkValues.showSearchForm;
        result.advertisement = advertisement.get();
        result.hasClosedTabs = closedTabs.hasClosed(info.windowId);
        result.experiments = getExperiments();
        result.customLogo = customLogo.getCurrent();
        result.vbID = aboutPlatform.type;
        result.zen = settings.get("showZen");
        result.hasApps = false;
        result.sync = {
            status: 4
        };
        return result;
    }
    function getBranding() {
        return {
            regionBrandId: branding.getRegionBrandId(),
            customBrandId: branding.getCustomBrandId(),
            productName: branding.info.productName,
            productShortName: branding.info.productShortName,
            thumbSuggestURL: branding.thumbs.suggestUrl,
            logo: getLogo(),
            search: getSearch()
        };
    }
    function getSearch() {
        return {
            url: branding.search.url,
            suggest: branding.search.suggest,
            navigateTitle: branding.search.navigateTitle
        };
    }
    function getLogo() {
        return {
            url: branding.logo.url,
            img: branding.logo.imgClear,
            imgDark: branding.logo.imgDark,
            alt: branding.logo.alt,
            title: branding.logo.title
        };
    }
    function getExperiments() {
        return experiments.getExperimentsList().map(function(experiment) {
            return {
                testId: experiment.testId,
                name: experiment.name,
                data: experiment.data,
                bucket: experiment.bucket
            };
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Frontend/settings-checkboxes");
    var settings = __webpack_require__(216);
    var messaging = __webpack_require__(213);
    var frontendBookmarks = __webpack_require__(219);
    var frontendThumbSender = __webpack_require__(269);
    var informers = __webpack_require__(302);
    var events = __webpack_require__(268);
    var NAMES = [ "uiThumbsType", "showBookmarks", "showSearchForm", "showAdvertisement", "geolocation", "boroda", "sendUsageStat", "backgroundRotation" ];
    exports.init = function() {
        settings.onChanged.addListener(onSettingChanged);
        if (informers.isSupported()) NAMES.push("showInformers");
        NAMES.push("showZen");
    };
    exports.apply = function(name, value) {
        if (isValidName(name)) applySettingValue(name, value); else logger.error("Unknown setting: %s", name);
    };
    exports.getValues = function() {
        return NAMES.reduce(function(result, name) {
            result[name] = settings.get(name);
            return result;
        }, {});
    };
    function isValidName(name) {
        return NAMES.indexOf(name) >= 0;
    }
    function applySettingValue(name, value) {
        var oldValue = settings.get(name);
        if (oldValue !== value) {
            logger.info("Change setting %s from %s to %s", name, oldValue, value);
            settings.set(name, value);
        }
    }
    function getData(name, newValue, callback) {
        if ("showBookmarks" === name && true === newValue) frontendBookmarks.getRootItems(callback); else if ("uiThumbsType" === name) callback(frontendThumbSender.getAll()); else callback(null);
    }
    function onSettingChanged(info) {
        if (isValidName(info.key)) sendSettingChanged(info.key, info.oldValue, info.newValue);
    }
    function sendSettingChanged(name, oldValue, newValue) {
        getData(name, newValue, function(data) {
            messaging.send(events.backend.SETTING_CHANGE, {
                id: name,
                oldValue: oldValue,
                newValue: newValue,
                data: data
            });
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var defaults = __webpack_require__(217);
    var utils = __webpack_require__(30);
    var isPlainObject = __webpack_require__(39);
    var channel = __webpack_require__(27);
    var logger = __webpack_require__(5).create("Settings");
    var PREFIX = "settings.";
    var currentPrefs = Object.create(null);
    var RESETEABLE_SETTINGS = [ "showBookmarks", "showSearchForm", "showAdvertisement", "uiThumbsType", "geolocation", "boroda", "showInformers", "backgroundRotation", "showZen" ];
    var settings = module.exports = {
        load: function(callback) {
            addListeners();
            load(callback);
        },
        get: function(key) {
            var prefixedKey = getPrefixedKey(key);
            return isValidPrefixedKey(prefixedKey) ? currentPrefs[prefixedKey].value : null;
        },
        set: function(key, value, options) {
            options = options || {};
            var prefixedKey = getPrefixedKey(key);
            if (!isValidPrefixedKey(prefixedKey)) return;
            currentPrefs[prefixedKey].value = value;
            currentPrefs[prefixedKey].isDefault = Boolean(options.isDefault);
            var storageData = {};
            storageData[prefixedKey] = value;
            chrome.storage.local.set(storageData);
            if (options.log) logger.info("Setting %s changed to %j", key, value);
        },
        hasUserValue: function(key) {
            var prefixedKey = getPrefixedKey(key);
            return isValidPrefixedKey(prefixedKey) ? !currentPrefs[prefixedKey].isDefault : false;
        },
        isLoaded: isLoaded,
        get __items() {
            return currentPrefs;
        },
        resetDefaults: function() {
            var changes = [];
            RESETEABLE_SETTINGS.forEach(function(key) {
                var oldValue = currentPrefs[getPrefixedKey(key)] || {};
                var defaultValue = defaults[key];
                if (oldValue.isDefault) return;
                this.set(key, defaultValue, {
                    isDefault: true
                });
                changes.push(key);
            }, this);
            if (0 === changes.length) {
                logger.info("All settings are defaults");
                return;
            }
            logger.info("%i item(s) were restored to default ", changes.length);
        },
        onChanged: channel.create()
    };
    function getPrefixedKey(key) {
        return PREFIX + key;
    }
    function getUnprefixedKey(prefixedKey) {
        return 0 === prefixedKey.indexOf(PREFIX) ? prefixedKey.replace(PREFIX, "") : prefixedKey;
    }
    function isValidPrefixedKey(prefixedKey) {
        if (!currentPrefs[prefixedKey]) {
            logger.error("Can't use preference (" + prefixedKey + ") which was not described in defaults");
            return false;
        } else return true;
    }
    function isLoaded() {
        return Object.keys(currentPrefs).length > 0;
    }
    function onChanged(changes, areaName) {
        if ("local" !== areaName) return;
        Object.keys(changes).forEach(function(prefixedKey) {
            if (0 === prefixedKey.indexOf(PREFIX) && currentPrefs[prefixedKey]) {
                currentPrefs[prefixedKey].value = changes[prefixedKey].newValue;
                dispatchOnChanged(prefixedKey, changes[prefixedKey].oldValue, changes[prefixedKey].newValue);
            }
        });
    }
    function dispatchOnChanged(prefixedKey, oldValue, newValue) {
        if (oldValue === newValue) return;
        settings.onChanged.dispatch({
            key: getUnprefixedKey(prefixedKey),
            oldValue: oldValue,
            newValue: newValue
        });
    }
    function load(callback) {
        callback = callback || utils.noop;
        chrome.storage.local.get(null, function(values) {
            if (!isPlainObject(values)) {
                logger.error("values is not an object");
                values = Object.create(null);
            }
            Object.keys(defaults).forEach(function(key) {
                var prefixedKey = getPrefixedKey(key);
                var isDefault = void 0 === values[prefixedKey];
                currentPrefs[prefixedKey] = {
                    value: isDefault ? defaults[key] : values[prefixedKey],
                    isDefault: isDefault
                };
            });
            logger.info("Loaded %i item(s)", Object.keys(currentPrefs).length);
            callback();
        });
    }
    function addListeners() {
        chrome.storage.onChanged.addListener(onChanged);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var buildData = __webpack_require__(218);
    var consoleLevels = buildData.git.release ? [] : [ "info", "warn", "error" ];
    module.exports = {
        showBookmarks: false,
        showSearchForm: true,
        showAdvertisement: true,
        uiThumbsType: 1,
        backgroundImage: "",
        geolocation: true,
        boroda: false,
        showInformers: true,
        backgroundRotation: false,
        showZen: false,
        appInstallTime: 0,
        backgroundImagePath: null,
        backgroundImagesFontColors: {},
        backgroundImagesList: [],
        backgroundImagesVersion: 0,
        backgroundMissingCloudData: null,
        backgroundRotationIndex: 0,
        blacklist: {
            domains: [],
            regexps: []
        },
        debug: false,
        debugMode: false,
        lastDayUseSendTime: 0,
        lastDayUseExpSendTime: 0,
        consoleLogLevels: consoleLevels,
        platformLogLevels: [ "info", "warn", "error" ],
        maxAvailableIncreased: false,
        refreshThumbsBackgroundsTime: 0,
        advertisementState: {
            blocks: {}
        },
        hasUserAddedThumb: false,
        versionsHistory: [],
        lastScrollTimeOn: 0,
        lastScrollTimeOff: 0,
        bannerid: null,
        remoteConfig: {},
        experiments: [],
        closedTabs: [],
        searchExamples: [],
        customLogos: [],
        remoteBrandingData: null,
        informerReginfo: null,
        informerQuotes: null,
        remoteSyncTimestamp: 0,
        localSyncSnapshot: {},
        brandingPackage: "",
        statUID: "",
        r1String: "",
        sendUsageStat: false,
        isVoiceUsed: false
    };
}, function(module, exports) {
    module.exports = {
        git: {
            buildNumber: 0,
            branch: "release/3.0.6",
            sha: "035f9547f17b658510e922225b8550185173d574",
            release: true,
            branchVersion: "3.0.6"
        },
        version: "3.0.6",
        time: 1729684623719
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var logger = __webpack_require__(5).create("Frontend/bookmarks");
    var bookmarks = __webpack_require__(220);
    var favicon = __webpack_require__(222);
    var faviconYandex = __webpack_require__(258);
    var urlUtils = __webpack_require__(83);
    var events = __webpack_require__(268);
    exports.sendRootItems = function(tabId) {
        exports.getRootItems(function(children) {
            messaging.send(events.backend.BOOKMARKS_CHANGED, children, tabId);
        });
    };
    exports.getRootItems = function(callback) {
        getChildren(bookmarks.BOOKMARKS_BAR_ID, callback);
    };
    exports.init = function() {
        messaging.on(events.frontend.REQUEST_BOOKMARKS_BRANCH, function(req, sender, sendResponse) {
            if (req.id) {
                logger.info("requestBookmarksBranch id %s", req.id);
                getChildren(req.id, sendResponse);
                return true;
            } else logger.error("Empty req.id");
        });
        bookmarks.onChanged.addListener(exports.sendRootItems);
    };
    function getChildren(levelId, callback) {
        bookmarks.getChildren(levelId, function(children) {
            var normalized = normalizeBookmarks(children);
            callback(normalized);
        });
    }
    function normalizeBookmarks(bookmarks) {
        return Array.isArray(bookmarks) ? bookmarks.map(normalizeBookmark) : [];
    }
    function normalizeBookmark(bookmark) {
        return {
            favicon: getFaviconUrl(bookmark.url),
            url: bookmark.url,
            title: bookmark.title || urlUtils.getReadableUrl(bookmark.url),
            id: bookmark.id,
            isFolder: !bookmark.url
        };
    }
    function getFaviconUrl(siteUrl) {
        var cached = favicon.getCached(siteUrl);
        if (cached && cached.url) return cached.url; else return urlUtils.isRemote(siteUrl) ? faviconYandex.getUrl(siteUrl) : "";
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var channel = __webpack_require__(27);
    var platformBookmarks = __webpack_require__(221);
    var FIREFOX_INTERNAL_URL_REGEXP = /^(place|about):/;
    exports.ROOT_ID = platformBookmarks.ROOT_ID;
    exports.BOOKMARKS_BAR_ID = platformBookmarks.BOOKMARKS_BAR_ID;
    exports.requestAll = function(callback) {
        chrome.bookmarks.search({}, function(nodes) {
            var children = nodes.filter(function(item) {
                return Boolean(item.url) && !FIREFOX_INTERNAL_URL_REGEXP.test(item.url);
            });
            callback(null, children);
        });
    };
    exports.onChanged = channel.create("bookmarks.onChanged");
    exports.init = function() {
        [ "onCreated", "onRemoved", "onChanged", "onMoved", "onChildrenReordered", "onImportEnded" ].forEach(function(eventName) {
            chrome.bookmarks[eventName].addListener(this.onChanged.dispatch.bind(this.onChanged));
        }, this);
    };
    exports.getChildren = function(id, callback) {
        chrome.bookmarks.getChildren(id, function(children) {
            children = children.filter(function(child) {
                return !(Boolean(child.url) && FIREFOX_INTERNAL_URL_REGEXP.test(child.url));
            });
            callback(children);
        });
    };
}, function(module, exports) {
    "use strict";
    module.exports = {
        ROOT_ID: "0",
        BOOKMARKS_BAR_ID: "1"
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var loader = __webpack_require__(223);
    var urlUtils = __webpack_require__(83);
    var colors = __webpack_require__(259);
    var asyncLib = __webpack_require__(209);
    var logger = __webpack_require__(5).create("favicon");
    var ResourceLoader = __webpack_require__(256);
    var FileStorage = __webpack_require__(263);
    var dateUtils = __webpack_require__(4);
    var formatMessage = __webpack_require__(58);
    var fileStorage;
    var resourceLoader;
    exports.FAVICON_DIR = "favicons";
    exports.init = function() {
        fileStorage = new FileStorage(exports.FAVICON_DIR);
        resourceLoader = new ResourceLoader({
            succesValidatePeriodMs: 2 * dateUtils.DAY_MS,
            errorValidatePeriodMs: dateUtils.HOUR_MS
        });
    };
    exports.getFavicon = function(siteUrl, callback) {
        resourceLoader.load({
            id: urlUtils.getNormalDomain(siteUrl),
            loadMethod: loadMethod.bind(null, siteUrl),
            callback: callback
        });
    };
    exports.getCached = function(siteUrl) {
        var domain = urlUtils.getNormalDomain(siteUrl);
        return resourceLoader.getCache(domain, 1);
    };
    exports.hasCached = function(siteUrl) {
        var domain = urlUtils.getNormalDomain(siteUrl);
        return resourceLoader.hasCache(domain);
    };
    exports.clearExpired = function() {
        logger.info("Clear expired items");
        resourceLoader.clearExpired();
    };
    function loadMethod(siteUrl, callback) {
        asyncLib.waterfall([ init.bind(null, siteUrl), load, save, calcColor ], function(err, data) {
            if (err || !data) callback(err || new Error("Empty data")); else {
                clearData(data);
                callback(null, data);
            }
        });
    }
    function init(siteUrl, next) {
        next(null, {
            siteUrl: siteUrl,
            domain: "",
            img: null,
            url: "",
            filePath: "",
            remoteUrl: "",
            color: ""
        });
    }
    function load(data, next) {
        loader.loadFavicon(data.siteUrl, function(err, faviconData) {
            if (faviconData) {
                data.remoteUrl = faviconData.url;
                data.img = faviconData.img;
            }
            next(err, data);
        });
    }
    function save(data, next) {
        data.domain = urlUtils.getNormalDomain(data.siteUrl);
        fileStorage.saveAnyUrl(data.remoteUrl, data.domain, function(err, storageData) {
            if (err || !storageData || !storageData.url) {
                var message = formatMessage("Can not save icon from %s %j", data.remoteUrl, err);
                next(new Error(message));
                return;
            }
            data.url = storageData.url;
            data.filePath = storageData.path;
            next(null, data);
        });
    }
    function calcColor(data, next) {
        if (data && data.url) colors.calculateDominantColorByUrl(data.url, {}, function(color) {
            data.color = color;
            next(null, data);
        }); else next(null, data);
    }
    function clearData(data) {
        delete data.img;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var loadImage = __webpack_require__(224);
    var asyncLib = __webpack_require__(209);
    var faviconSite = __webpack_require__(225);
    var faviconYandex = __webpack_require__(258);
    var MIN_WIDTH = 2;
    var MIN_HEIGHT = 2;
    exports.loadFavicon = function(siteUrl, callback) {
        asyncLib.eachSeries([ function(callback) {
            var url = faviconYandex.getUrl(siteUrl);
            callback(url);
        }, function(callback) {
            faviconSite.getUrl(siteUrl, function(err, url) {
                callback(url);
            });
        } ], getFaviconUrl, function(faviconData) {
            if (!faviconData) callback(new Error("Can not find favicon image for " + siteUrl)); else callback(null, faviconData);
        });
    };
    function getFaviconUrl(fn, next) {
        fn(function(url) {
            if (url) checkImage(url, next); else next(null);
        });
    }
    function checkImage(url, callback) {
        loadImage({
            url: url
        }, function(err, img) {
            if (err || img.width < MIN_WIDTH || img.height < MIN_HEIGHT) callback(null); else callback({
                url: url,
                img: img
            });
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var urlUtils = __webpack_require__(83);
    var xhr = __webpack_require__(32);
    module.exports = function(options, callback) {
        options = options || {};
        var src = options.noCache ? urlUtils.addRandomParam(options.url) : options.url;
        xhr({
            url: src
        }, function(err, img) {
            if (!err) onLoad(img, callback); else onError({
                src: src
            }, callback);
        });
    };
    function onLoad(img, callback) {
        setTimeout(function() {
            callback(null, img);
        }, 0);
    }
    function onError(img, callback) {
        callback(new Error("Image load error: " + img.src), img);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var siteLoader = __webpack_require__(226);
    var urlUtils = __webpack_require__(83);
    var get = __webpack_require__(193);
    var LINK_RELS = [ "icon", "shortcut icon" ];
    var DEFAULT_FAVICON_PATH = "/favicon.ico";
    exports.getUrl = function(siteUrl, callback) {
        var indexSiteUrl = urlUtils.getIndexPart(siteUrl);
        if (indexSiteUrl) siteLoader.load(indexSiteUrl, function(err, rootNode) {
            if (err) callback(err); else callback(null, parseSite(indexSiteUrl, rootNode));
        }); else callback(new Error("Can not get index part of siteUrl " + siteUrl));
    };
    function parseSite(siteUrl, data) {
        var iconHref = getIconHref(data) || DEFAULT_FAVICON_PATH;
        if (urlUtils.isDataUri(iconHref)) return iconHref; else {
            var baseUrl = get(data, "base[0].attributes.href");
            return urlUtils.resolve(siteUrl, baseUrl, iconHref);
        }
    }
    function getIconHref(data) {
        var favIconLinks = [];
        try {
            favIconLinks = data.link.filter(function(link) {
                return link.attributes.href && LINK_RELS.indexOf(link.attributes.rel) >= 0;
            });
        } catch (e) {}
        return favIconLinks.length ? favIconLinks[0].attributes.href : "";
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var urlUtils = __webpack_require__(83);
    var xhr = __webpack_require__(32);
    var SaxParser = __webpack_require__(227);
    var ResourceLoader = __webpack_require__(256);
    var resourceLoader;
    var PARSER_OPTIONS = {
        tagToParse: "head",
        children: [ "link", "base", "title", "meta" ],
        parseOptions: {
            lowercase: true,
            normalize: true,
            noscript: true
        }
    };
    function saxParse(htmlString) {
        try {
            var parser = new SaxParser(PARSER_OPTIONS);
            return parser.parse(htmlString);
        } catch (e) {
            return null;
        }
    }
    exports.init = function() {
        resourceLoader = new ResourceLoader();
    };
    exports.load = function(url, callback) {
        resourceLoader.load({
            id: url,
            loadMethod: loadMethod.bind(null, url),
            callback: callback
        });
    };
    function loadMethod(url, callback) {
        xhr({
            url: urlUtils.addTechnicalParam(url),
            parse: "text"
        }, function(err, htmlString) {
            callback(err, saxParse(htmlString));
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var sax = __webpack_require__(228);
    function Parser(options) {
        this._parser = sax.parser(options.strict, options.parseOptions);
        this._inTagToParse = false;
        this._currentTag = null;
        this._tagToParse = options.tagToParse;
        this._children = options.children;
        this._result = createResultObject(this._children);
        this._addListeners();
    }
    Parser.prototype.parse = function(str) {
        this._parser.write(str).close();
        return this._result;
    };
    Parser.prototype._addListeners = function() {
        this._parser.onerror = this._onerror.bind(this);
        this._parser.onopentag = this._onopentag.bind(this);
        this._parser.ontext = this._ontext.bind(this);
        this._parser.onclosetag = this._onclosetag.bind(this);
    };
    Parser.prototype._onerror = function(error) {
        if (this._inTagToParse) {
            this._result.error.push(error);
            this._parser.resume();
        }
    };
    Parser.prototype._onopentag = function(node) {
        if (!node) return;
        if (node.name === this._tagToParse) this._inTagToParse = true; else this._parseChild(node);
    };
    Parser.prototype._parseChild = function(node) {
        if (this._inTagToParse && this._children.indexOf(node.name) !== -1) {
            this._currentTag = node;
            this._result[node.name].push(node);
        }
    };
    Parser.prototype._ontext = function(text) {
        if (this._currentTag) this._currentTag.value = text;
    };
    Parser.prototype._onclosetag = function(node) {
        if (node && node.name === this._tagToParse) {
            this._inTagToParse = false;
            this._parser.end();
        }
        this._currentTag = null;
    };
    function createResultObject(tagNames) {
        return tagNames.reduce(function(result, tagName) {
            result[tagName] = [];
            return result;
        }, {
            error: []
        });
    }
    module.exports = Parser;
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        "use strict";
        var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        !function(sax) {
            sax.parser = function(strict, opt) {
                return new SAXParser(strict, opt);
            };
            sax.SAXParser = SAXParser;
            sax.SAXStream = SAXStream;
            sax.createStream = createStream;
            sax.MAX_BUFFER_LENGTH = 64 * 1024;
            var buffers = [ "comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script" ];
            sax.EVENTS = [ "text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace" ];
            function SAXParser(strict, opt) {
                if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
                var parser = this;
                clearBuffers(parser);
                parser.q = parser.c = "";
                parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
                parser.opt = opt || {};
                parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
                parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
                parser.tags = [];
                parser.closed = parser.closedRoot = parser.sawRoot = false;
                parser.tag = parser.error = null;
                parser.strict = !!strict;
                parser.noscript = !!(strict || parser.opt.noscript);
                parser.state = S.BEGIN;
                parser.strictEntities = parser.opt.strictEntities;
                parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
                parser.attribList = [];
                if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
                parser.trackPosition = false !== parser.opt.position;
                if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
                emit(parser, "onready");
            }
            if (!Object.create) Object.create = function(o) {
                function F() {}
                F.prototype = o;
                var newf = new F();
                return newf;
            };
            if (!Object.keys) Object.keys = function(o) {
                var a = [];
                for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
                return a;
            };
            function checkBufferLength(parser) {
                var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
                var maxActual = 0;
                for (var i = 0, l = buffers.length; i < l; i++) {
                    var len = parser[buffers[i]].length;
                    if (len > maxAllowed) switch (buffers[i]) {
                      case "textNode":
                        closeText(parser);
                        break;

                      case "cdata":
                        emitNode(parser, "oncdata", parser.cdata);
                        parser.cdata = "";
                        break;

                      case "script":
                        emitNode(parser, "onscript", parser.script);
                        parser.script = "";
                        break;

                      default:
                        error(parser, "Max buffer length exceeded: " + buffers[i]);
                    }
                    maxActual = Math.max(maxActual, len);
                }
                var m = sax.MAX_BUFFER_LENGTH - maxActual;
                parser.bufferCheckPosition = m + parser.position;
            }
            function clearBuffers(parser) {
                for (var i = 0, l = buffers.length; i < l; i++) parser[buffers[i]] = "";
            }
            function flushBuffers(parser) {
                closeText(parser);
                if ("" !== parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                    parser.cdata = "";
                }
                if ("" !== parser.script) {
                    emitNode(parser, "onscript", parser.script);
                    parser.script = "";
                }
            }
            SAXParser.prototype = {
                end: function() {
                    _end(this);
                },
                write: write,
                resume: function() {
                    this.error = null;
                    return this;
                },
                close: function() {
                    return this.write(null);
                },
                flush: function() {
                    flushBuffers(this);
                }
            };
            var Stream;
            try {
                Stream = __webpack_require__(233).Stream;
            } catch (ex) {
                Stream = function() {};
            }
            var streamWraps = sax.EVENTS.filter(function(ev) {
                return "error" !== ev && "end" !== ev;
            });
            function createStream(strict, opt) {
                return new SAXStream(strict, opt);
            }
            function SAXStream(strict, opt) {
                if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
                Stream.apply(this);
                this._parser = new SAXParser(strict, opt);
                this.writable = true;
                this.readable = true;
                var me = this;
                this._parser.onend = function() {
                    me.emit("end");
                };
                this._parser.onerror = function(er) {
                    me.emit("error", er);
                    me._parser.error = null;
                };
                this._decoder = null;
                streamWraps.forEach(function(ev) {
                    Object.defineProperty(me, "on" + ev, {
                        get: function() {
                            return me._parser["on" + ev];
                        },
                        set: function(h) {
                            if (!h) {
                                me.removeAllListeners(ev);
                                me._parser["on" + ev] = h;
                                return h;
                            }
                            me.on(ev, h);
                        },
                        enumerable: true,
                        configurable: false
                    });
                });
            }
            SAXStream.prototype = Object.create(Stream.prototype, {
                constructor: {
                    value: SAXStream
                }
            });
            SAXStream.prototype.write = function(data) {
                if ("function" === typeof Buffer && "function" === typeof Buffer.isBuffer && Buffer.isBuffer(data)) {
                    if (!this._decoder) {
                        var SD = __webpack_require__(255).StringDecoder;
                        this._decoder = new SD("utf8");
                    }
                    data = this._decoder.write(data);
                }
                this._parser.write(data.toString());
                this.emit("data", data);
                return true;
            };
            SAXStream.prototype.end = function(chunk) {
                if (chunk && chunk.length) this.write(chunk);
                this._parser.end();
                return true;
            };
            SAXStream.prototype.on = function(ev, handler) {
                var me = this;
                if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) me._parser["on" + ev] = function() {
                    var args = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments);
                    args.splice(0, 0, ev);
                    me.emit.apply(me, args);
                };
                return Stream.prototype.on.call(me, ev, handler);
            };
            var whitespace = "\r\n\t ";
            var number = "0124356789";
            var letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            var quote = "'\"";
            var attribEnd = whitespace + ">";
            var CDATA = "[CDATA[";
            var DOCTYPE = "DOCTYPE";
            var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
            var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
            var rootNS = {
                xml: XML_NAMESPACE,
                xmlns: XMLNS_NAMESPACE
            };
            whitespace = charClass(whitespace);
            number = charClass(number);
            letter = charClass(letter);
            var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
            var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
            quote = charClass(quote);
            attribEnd = charClass(attribEnd);
            function charClass(str) {
                return str.split("").reduce(function(s, c) {
                    s[c] = true;
                    return s;
                }, {});
            }
            function isRegExp(c) {
                return "[object RegExp]" === Object.prototype.toString.call(c);
            }
            function is(charclass, c) {
                return isRegExp(charclass) ? !!c.match(charclass) : charclass[c];
            }
            function not(charclass, c) {
                return !is(charclass, c);
            }
            var S = 0;
            sax.STATE = {
                BEGIN: S++,
                BEGIN_WHITESPACE: S++,
                TEXT: S++,
                TEXT_ENTITY: S++,
                OPEN_WAKA: S++,
                SGML_DECL: S++,
                SGML_DECL_QUOTED: S++,
                DOCTYPE: S++,
                DOCTYPE_QUOTED: S++,
                DOCTYPE_DTD: S++,
                DOCTYPE_DTD_QUOTED: S++,
                COMMENT_STARTING: S++,
                COMMENT: S++,
                COMMENT_ENDING: S++,
                COMMENT_ENDED: S++,
                CDATA: S++,
                CDATA_ENDING: S++,
                CDATA_ENDING_2: S++,
                PROC_INST: S++,
                PROC_INST_BODY: S++,
                PROC_INST_ENDING: S++,
                OPEN_TAG: S++,
                OPEN_TAG_SLASH: S++,
                ATTRIB: S++,
                ATTRIB_NAME: S++,
                ATTRIB_NAME_SAW_WHITE: S++,
                ATTRIB_VALUE: S++,
                ATTRIB_VALUE_QUOTED: S++,
                ATTRIB_VALUE_CLOSED: S++,
                ATTRIB_VALUE_UNQUOTED: S++,
                ATTRIB_VALUE_ENTITY_Q: S++,
                ATTRIB_VALUE_ENTITY_U: S++,
                CLOSE_TAG: S++,
                CLOSE_TAG_SAW_WHITE: S++,
                SCRIPT: S++,
                SCRIPT_ENDING: S++
            };
            sax.XML_ENTITIES = {
                amp: "&",
                gt: ">",
                lt: "<",
                quot: '"',
                apos: "'"
            };
            sax.ENTITIES = {
                amp: "&",
                gt: ">",
                lt: "<",
                quot: '"',
                apos: "'",
                AElig: 198,
                Aacute: 193,
                Acirc: 194,
                Agrave: 192,
                Aring: 197,
                Atilde: 195,
                Auml: 196,
                Ccedil: 199,
                ETH: 208,
                Eacute: 201,
                Ecirc: 202,
                Egrave: 200,
                Euml: 203,
                Iacute: 205,
                Icirc: 206,
                Igrave: 204,
                Iuml: 207,
                Ntilde: 209,
                Oacute: 211,
                Ocirc: 212,
                Ograve: 210,
                Oslash: 216,
                Otilde: 213,
                Ouml: 214,
                THORN: 222,
                Uacute: 218,
                Ucirc: 219,
                Ugrave: 217,
                Uuml: 220,
                Yacute: 221,
                aacute: 225,
                acirc: 226,
                aelig: 230,
                agrave: 224,
                aring: 229,
                atilde: 227,
                auml: 228,
                ccedil: 231,
                eacute: 233,
                ecirc: 234,
                egrave: 232,
                eth: 240,
                euml: 235,
                iacute: 237,
                icirc: 238,
                igrave: 236,
                iuml: 239,
                ntilde: 241,
                oacute: 243,
                ocirc: 244,
                ograve: 242,
                oslash: 248,
                otilde: 245,
                ouml: 246,
                szlig: 223,
                thorn: 254,
                uacute: 250,
                ucirc: 251,
                ugrave: 249,
                uuml: 252,
                yacute: 253,
                yuml: 255,
                copy: 169,
                reg: 174,
                nbsp: 160,
                iexcl: 161,
                cent: 162,
                pound: 163,
                curren: 164,
                yen: 165,
                brvbar: 166,
                sect: 167,
                uml: 168,
                ordf: 170,
                laquo: 171,
                not: 172,
                shy: 173,
                macr: 175,
                deg: 176,
                plusmn: 177,
                sup1: 185,
                sup2: 178,
                sup3: 179,
                acute: 180,
                micro: 181,
                para: 182,
                middot: 183,
                cedil: 184,
                ordm: 186,
                raquo: 187,
                frac14: 188,
                frac12: 189,
                frac34: 190,
                iquest: 191,
                times: 215,
                divide: 247,
                OElig: 338,
                oelig: 339,
                Scaron: 352,
                scaron: 353,
                Yuml: 376,
                fnof: 402,
                circ: 710,
                tilde: 732,
                Alpha: 913,
                Beta: 914,
                Gamma: 915,
                Delta: 916,
                Epsilon: 917,
                Zeta: 918,
                Eta: 919,
                Theta: 920,
                Iota: 921,
                Kappa: 922,
                Lambda: 923,
                Mu: 924,
                Nu: 925,
                Xi: 926,
                Omicron: 927,
                Pi: 928,
                Rho: 929,
                Sigma: 931,
                Tau: 932,
                Upsilon: 933,
                Phi: 934,
                Chi: 935,
                Psi: 936,
                Omega: 937,
                alpha: 945,
                beta: 946,
                gamma: 947,
                delta: 948,
                epsilon: 949,
                zeta: 950,
                eta: 951,
                theta: 952,
                iota: 953,
                kappa: 954,
                lambda: 955,
                mu: 956,
                nu: 957,
                xi: 958,
                omicron: 959,
                pi: 960,
                rho: 961,
                sigmaf: 962,
                sigma: 963,
                tau: 964,
                upsilon: 965,
                phi: 966,
                chi: 967,
                psi: 968,
                omega: 969,
                thetasym: 977,
                upsih: 978,
                piv: 982,
                ensp: 8194,
                emsp: 8195,
                thinsp: 8201,
                zwnj: 8204,
                zwj: 8205,
                lrm: 8206,
                rlm: 8207,
                ndash: 8211,
                mdash: 8212,
                lsquo: 8216,
                rsquo: 8217,
                sbquo: 8218,
                ldquo: 8220,
                rdquo: 8221,
                bdquo: 8222,
                dagger: 8224,
                Dagger: 8225,
                bull: 8226,
                hellip: 8230,
                permil: 8240,
                prime: 8242,
                Prime: 8243,
                lsaquo: 8249,
                rsaquo: 8250,
                oline: 8254,
                frasl: 8260,
                euro: 8364,
                image: 8465,
                weierp: 8472,
                real: 8476,
                trade: 8482,
                alefsym: 8501,
                larr: 8592,
                uarr: 8593,
                rarr: 8594,
                darr: 8595,
                harr: 8596,
                crarr: 8629,
                lArr: 8656,
                uArr: 8657,
                rArr: 8658,
                dArr: 8659,
                hArr: 8660,
                forall: 8704,
                part: 8706,
                exist: 8707,
                empty: 8709,
                nabla: 8711,
                isin: 8712,
                notin: 8713,
                ni: 8715,
                prod: 8719,
                sum: 8721,
                minus: 8722,
                lowast: 8727,
                radic: 8730,
                prop: 8733,
                infin: 8734,
                ang: 8736,
                and: 8743,
                or: 8744,
                cap: 8745,
                cup: 8746,
                int: 8747,
                there4: 8756,
                sim: 8764,
                cong: 8773,
                asymp: 8776,
                ne: 8800,
                equiv: 8801,
                le: 8804,
                ge: 8805,
                sub: 8834,
                sup: 8835,
                nsub: 8836,
                sube: 8838,
                supe: 8839,
                oplus: 8853,
                otimes: 8855,
                perp: 8869,
                sdot: 8901,
                lceil: 8968,
                rceil: 8969,
                lfloor: 8970,
                rfloor: 8971,
                lang: 9001,
                rang: 9002,
                loz: 9674,
                spades: 9824,
                clubs: 9827,
                hearts: 9829,
                diams: 9830
            };
            Object.keys(sax.ENTITIES).forEach(function(key) {
                var e = sax.ENTITIES[key];
                var s = "number" === typeof e ? String.fromCharCode(e) : e;
                sax.ENTITIES[key] = s;
            });
            for (var s in sax.STATE) sax.STATE[sax.STATE[s]] = s;
            S = sax.STATE;
            function emit(parser, event, data) {
                parser[event] && parser[event](data);
            }
            function emitNode(parser, nodeType, data) {
                if (parser.textNode) closeText(parser);
                emit(parser, nodeType, data);
            }
            function closeText(parser) {
                parser.textNode = textopts(parser.opt, parser.textNode);
                if (parser.textNode) emit(parser, "ontext", parser.textNode);
                parser.textNode = "";
            }
            function textopts(opt, text) {
                if (opt.trim) text = text.trim();
                if (opt.normalize) text = text.replace(/\s+/g, " ");
                return text;
            }
            function error(parser, er) {
                closeText(parser);
                if (parser.trackPosition) er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
                er = new Error(er);
                parser.error = er;
                emit(parser, "onerror", er);
                return parser;
            }
            function _end(parser) {
                if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
                if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error(parser, "Unexpected end");
                closeText(parser);
                parser.c = "";
                parser.closed = true;
                emit(parser, "onend");
                SAXParser.call(parser, parser.strict, parser.opt);
                return parser;
            }
            function strictFail(parser, message) {
                if ("object" !== ("undefined" === typeof parser ? "undefined" : _typeof(parser)) || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
                if (parser.strict) error(parser, message);
            }
            function newTag(parser) {
                if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
                var parent = parser.tags[parser.tags.length - 1] || parser;
                var tag = parser.tag = {
                    name: parser.tagName,
                    attributes: {}
                };
                if (parser.opt.xmlns) tag.ns = parent.ns;
                parser.attribList.length = 0;
            }
            function qname(name, attribute) {
                var i = name.indexOf(":");
                var qualName = i < 0 ? [ "", name ] : name.split(":");
                var prefix = qualName[0];
                var local = qualName[1];
                if (attribute && "xmlns" === name) {
                    prefix = "xmlns";
                    local = "";
                }
                return {
                    prefix: prefix,
                    local: local
                };
            }
            function attrib(parser) {
                if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
                if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
                    parser.attribName = parser.attribValue = "";
                    return;
                }
                if (parser.opt.xmlns) {
                    var qn = qname(parser.attribName, true);
                    var prefix = qn.prefix;
                    var local = qn.local;
                    if ("xmlns" === prefix) if ("xml" === local && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\n" + "Actual: " + parser.attribValue); else if ("xmlns" === local && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n" + "Actual: " + parser.attribValue); else {
                        var tag = parser.tag;
                        var parent = parser.tags[parser.tags.length - 1] || parser;
                        if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
                        tag.ns[local] = parser.attribValue;
                    }
                    parser.attribList.push([ parser.attribName, parser.attribValue ]);
                } else {
                    parser.tag.attributes[parser.attribName] = parser.attribValue;
                    emitNode(parser, "onattribute", {
                        name: parser.attribName,
                        value: parser.attribValue
                    });
                }
                parser.attribName = parser.attribValue = "";
            }
            function openTag(parser, selfClosing) {
                if (parser.opt.xmlns) {
                    var tag = parser.tag;
                    var qn = qname(parser.tagName);
                    tag.prefix = qn.prefix;
                    tag.local = qn.local;
                    tag.uri = tag.ns[qn.prefix] || "";
                    if (tag.prefix && !tag.uri) {
                        strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
                        tag.uri = qn.prefix;
                    }
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
                        emitNode(parser, "onopennamespace", {
                            prefix: p,
                            uri: tag.ns[p]
                        });
                    });
                    for (var i = 0, l = parser.attribList.length; i < l; i++) {
                        var nv = parser.attribList[i];
                        var name = nv[0];
                        var value = nv[1];
                        var qualName = qname(name, true);
                        var prefix = qualName.prefix;
                        var local = qualName.local;
                        var uri = "" === prefix ? "" : tag.ns[prefix] || "";
                        var a = {
                            name: name,
                            value: value,
                            prefix: prefix,
                            local: local,
                            uri: uri
                        };
                        if (prefix && "xmlns" !== prefix && !uri) {
                            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                            a.uri = prefix;
                        }
                        parser.tag.attributes[name] = a;
                        emitNode(parser, "onattribute", a);
                    }
                    parser.attribList.length = 0;
                }
                parser.tag.isSelfClosing = !!selfClosing;
                parser.sawRoot = true;
                parser.tags.push(parser.tag);
                emitNode(parser, "onopentag", parser.tag);
                if (!selfClosing) {
                    if (!parser.noscript && "script" === parser.tagName.toLowerCase()) parser.state = S.SCRIPT; else parser.state = S.TEXT;
                    parser.tag = null;
                    parser.tagName = "";
                }
                parser.attribName = parser.attribValue = "";
                parser.attribList.length = 0;
            }
            function closeTag(parser) {
                if (!parser.tagName) {
                    strictFail(parser, "Weird empty close tag.");
                    parser.textNode += "</>";
                    parser.state = S.TEXT;
                    return;
                }
                if (parser.script) {
                    if ("script" !== parser.tagName) {
                        parser.script += "</" + parser.tagName + ">";
                        parser.tagName = "";
                        parser.state = S.SCRIPT;
                        return;
                    }
                    emitNode(parser, "onscript", parser.script);
                    parser.script = "";
                }
                var t = parser.tags.length;
                var tagName = parser.tagName;
                if (!parser.strict) tagName = tagName[parser.looseCase]();
                var closeTo = tagName;
                while (t--) {
                    var close = parser.tags[t];
                    if (close.name !== closeTo) strictFail(parser, "Unexpected close tag"); else break;
                }
                if (t < 0) {
                    strictFail(parser, "Unmatched closing tag: " + parser.tagName);
                    parser.textNode += "</" + parser.tagName + ">";
                    parser.state = S.TEXT;
                    return;
                }
                parser.tagName = tagName;
                var s = parser.tags.length;
                while (s-- > t) {
                    var tag = parser.tag = parser.tags.pop();
                    parser.tagName = parser.tag.name;
                    emitNode(parser, "onclosetag", parser.tagName);
                    var x = {};
                    for (var i in tag.ns) x[i] = tag.ns[i];
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (parser.opt.xmlns && tag.ns !== parent.ns) Object.keys(tag.ns).forEach(function(p) {
                        var n = tag.ns[p];
                        emitNode(parser, "onclosenamespace", {
                            prefix: p,
                            uri: n
                        });
                    });
                }
                if (0 === t) parser.closedRoot = true;
                parser.tagName = parser.attribValue = parser.attribName = "";
                parser.attribList.length = 0;
                parser.state = S.TEXT;
            }
            function parseEntity(parser) {
                var entity = parser.entity;
                var entityLC = entity.toLowerCase();
                var num;
                var numStr = "";
                if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
                if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
                entity = entityLC;
                if ("#" === entity.charAt(0)) if ("x" === entity.charAt(1)) {
                    entity = entity.slice(2);
                    num = parseInt(entity, 16);
                    numStr = num.toString(16);
                } else {
                    entity = entity.slice(1);
                    num = parseInt(entity, 10);
                    numStr = num.toString(10);
                }
                entity = entity.replace(/^0+/, "");
                if (isNaN(num) || num < 0 || num > 1114111 || numStr.toLowerCase() !== entity) {
                    strictFail(parser, "Invalid character entity");
                    return "&" + parser.entity + ";";
                }
                return String.fromCodePoint(num);
            }
            function beginWhiteSpace(parser, c) {
                if ("<" === c) {
                    parser.state = S.OPEN_WAKA;
                    parser.startTagPosition = parser.position;
                } else if (not(whitespace, c)) {
                    strictFail(parser, "Non-whitespace before first tag.");
                    parser.textNode = c;
                    parser.state = S.TEXT;
                }
            }
            function charAt(chunk, i) {
                var result = "";
                if (i < chunk.length) result = chunk.charAt(i);
                return result;
            }
            function write(chunk) {
                var parser = this;
                if (this.error) throw this.error;
                if (parser.closed) return error(parser, "Cannot write after close. Assign an onready handler.");
                if (null === chunk) return _end(parser);
                var i = 0;
                var c = "";
                while (true) {
                    c = charAt(chunk, i++);
                    parser.c = c;
                    if (!c) break;
                    if (parser.trackPosition) {
                        parser.position++;
                        if ("\n" === c) {
                            parser.line++;
                            parser.column = 0;
                        } else parser.column++;
                    }
                    switch (parser.state) {
                      case S.BEGIN:
                        parser.state = S.BEGIN_WHITESPACE;
                        if ("\ufeff" === c) continue;
                        beginWhiteSpace(parser, c);
                        continue;

                      case S.BEGIN_WHITESPACE:
                        beginWhiteSpace(parser, c);
                        continue;

                      case S.TEXT:
                        if (parser.sawRoot && !parser.closedRoot) {
                            var starti = i - 1;
                            while (c && "<" !== c && "&" !== c) {
                                c = charAt(chunk, i++);
                                if (c && parser.trackPosition) {
                                    parser.position++;
                                    if ("\n" === c) {
                                        parser.line++;
                                        parser.column = 0;
                                    } else parser.column++;
                                }
                            }
                            parser.textNode += chunk.substring(starti, i - 1);
                        }
                        if ("<" === c && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                            parser.state = S.OPEN_WAKA;
                            parser.startTagPosition = parser.position;
                        } else {
                            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, "Text data outside of root node.");
                            if ("&" === c) parser.state = S.TEXT_ENTITY; else parser.textNode += c;
                        }
                        continue;

                      case S.SCRIPT:
                        if ("<" === c) parser.state = S.SCRIPT_ENDING; else parser.script += c;
                        continue;

                      case S.SCRIPT_ENDING:
                        if ("/" === c) parser.state = S.CLOSE_TAG; else {
                            parser.script += "<" + c;
                            parser.state = S.SCRIPT;
                        }
                        continue;

                      case S.OPEN_WAKA:
                        if ("!" === c) {
                            parser.state = S.SGML_DECL;
                            parser.sgmlDecl = "";
                        } else if (is(whitespace, c)) ; else if (is(nameStart, c)) {
                            parser.state = S.OPEN_TAG;
                            parser.tagName = c;
                        } else if ("/" === c) {
                            parser.state = S.CLOSE_TAG;
                            parser.tagName = "";
                        } else if ("?" === c) {
                            parser.state = S.PROC_INST;
                            parser.procInstName = parser.procInstBody = "";
                        } else {
                            strictFail(parser, "Unencoded <");
                            if (parser.startTagPosition + 1 < parser.position) {
                                var pad = parser.position - parser.startTagPosition;
                                c = new Array(pad).join(" ") + c;
                            }
                            parser.textNode += "<" + c;
                            parser.state = S.TEXT;
                        }
                        continue;

                      case S.SGML_DECL:
                        if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                            emitNode(parser, "onopencdata");
                            parser.state = S.CDATA;
                            parser.sgmlDecl = "";
                            parser.cdata = "";
                        } else if (parser.sgmlDecl + c === "--") {
                            parser.state = S.COMMENT;
                            parser.comment = "";
                            parser.sgmlDecl = "";
                        } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                            parser.state = S.DOCTYPE;
                            if (parser.doctype || parser.sawRoot) strictFail(parser, "Inappropriately located doctype declaration");
                            parser.doctype = "";
                            parser.sgmlDecl = "";
                        } else if (">" === c) {
                            emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                            parser.sgmlDecl = "";
                            parser.state = S.TEXT;
                        } else if (is(quote, c)) {
                            parser.state = S.SGML_DECL_QUOTED;
                            parser.sgmlDecl += c;
                        } else parser.sgmlDecl += c;
                        continue;

                      case S.SGML_DECL_QUOTED:
                        if (c === parser.q) {
                            parser.state = S.SGML_DECL;
                            parser.q = "";
                        }
                        parser.sgmlDecl += c;
                        continue;

                      case S.DOCTYPE:
                        if (">" === c) {
                            parser.state = S.TEXT;
                            emitNode(parser, "ondoctype", parser.doctype);
                            parser.doctype = true;
                        } else {
                            parser.doctype += c;
                            if ("[" === c) parser.state = S.DOCTYPE_DTD; else if (is(quote, c)) {
                                parser.state = S.DOCTYPE_QUOTED;
                                parser.q = c;
                            }
                        }
                        continue;

                      case S.DOCTYPE_QUOTED:
                        parser.doctype += c;
                        if (c === parser.q) {
                            parser.q = "";
                            parser.state = S.DOCTYPE;
                        }
                        continue;

                      case S.DOCTYPE_DTD:
                        parser.doctype += c;
                        if ("]" === c) parser.state = S.DOCTYPE; else if (is(quote, c)) {
                            parser.state = S.DOCTYPE_DTD_QUOTED;
                            parser.q = c;
                        }
                        continue;

                      case S.DOCTYPE_DTD_QUOTED:
                        parser.doctype += c;
                        if (c === parser.q) {
                            parser.state = S.DOCTYPE_DTD;
                            parser.q = "";
                        }
                        continue;

                      case S.COMMENT:
                        if ("-" === c) parser.state = S.COMMENT_ENDING; else parser.comment += c;
                        continue;

                      case S.COMMENT_ENDING:
                        if ("-" === c) {
                            parser.state = S.COMMENT_ENDED;
                            parser.comment = textopts(parser.opt, parser.comment);
                            if (parser.comment) emitNode(parser, "oncomment", parser.comment);
                            parser.comment = "";
                        } else {
                            parser.comment += "-" + c;
                            parser.state = S.COMMENT;
                        }
                        continue;

                      case S.COMMENT_ENDED:
                        if (">" !== c) {
                            strictFail(parser, "Malformed comment");
                            parser.comment += "--" + c;
                            parser.state = S.COMMENT;
                        } else parser.state = S.TEXT;
                        continue;

                      case S.CDATA:
                        if ("]" === c) parser.state = S.CDATA_ENDING; else parser.cdata += c;
                        continue;

                      case S.CDATA_ENDING:
                        if ("]" === c) parser.state = S.CDATA_ENDING_2; else {
                            parser.cdata += "]" + c;
                            parser.state = S.CDATA;
                        }
                        continue;

                      case S.CDATA_ENDING_2:
                        if (">" === c) {
                            if (parser.cdata) emitNode(parser, "oncdata", parser.cdata);
                            emitNode(parser, "onclosecdata");
                            parser.cdata = "";
                            parser.state = S.TEXT;
                        } else if ("]" === c) parser.cdata += "]"; else {
                            parser.cdata += "]]" + c;
                            parser.state = S.CDATA;
                        }
                        continue;

                      case S.PROC_INST:
                        if ("?" === c) parser.state = S.PROC_INST_ENDING; else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY; else parser.procInstName += c;
                        continue;

                      case S.PROC_INST_BODY:
                        if (!parser.procInstBody && is(whitespace, c)) continue; else if ("?" === c) parser.state = S.PROC_INST_ENDING; else parser.procInstBody += c;
                        continue;

                      case S.PROC_INST_ENDING:
                        if (">" === c) {
                            emitNode(parser, "onprocessinginstruction", {
                                name: parser.procInstName,
                                body: parser.procInstBody
                            });
                            parser.procInstName = parser.procInstBody = "";
                            parser.state = S.TEXT;
                        } else {
                            parser.procInstBody += "?" + c;
                            parser.state = S.PROC_INST_BODY;
                        }
                        continue;

                      case S.OPEN_TAG:
                        if (is(nameBody, c)) parser.tagName += c; else {
                            newTag(parser);
                            if (">" === c) openTag(parser); else if ("/" === c) parser.state = S.OPEN_TAG_SLASH; else {
                                if (not(whitespace, c)) strictFail(parser, "Invalid character in tag name");
                                parser.state = S.ATTRIB;
                            }
                        }
                        continue;

                      case S.OPEN_TAG_SLASH:
                        if (">" === c) {
                            openTag(parser, true);
                            closeTag(parser);
                        } else {
                            strictFail(parser, "Forward-slash in opening tag not followed by >");
                            parser.state = S.ATTRIB;
                        }
                        continue;

                      case S.ATTRIB:
                        if (is(whitespace, c)) continue; else if (">" === c) openTag(parser); else if ("/" === c) parser.state = S.OPEN_TAG_SLASH; else if (is(nameStart, c)) {
                            parser.attribName = c;
                            parser.attribValue = "";
                            parser.state = S.ATTRIB_NAME;
                        } else strictFail(parser, "Invalid attribute name");
                        continue;

                      case S.ATTRIB_NAME:
                        if ("=" === c) parser.state = S.ATTRIB_VALUE; else if (">" === c) {
                            strictFail(parser, "Attribute without value");
                            parser.attribValue = parser.attribName;
                            attrib(parser);
                            openTag(parser);
                        } else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE; else if (is(nameBody, c)) parser.attribName += c; else strictFail(parser, "Invalid attribute name");
                        continue;

                      case S.ATTRIB_NAME_SAW_WHITE:
                        if ("=" === c) parser.state = S.ATTRIB_VALUE; else if (is(whitespace, c)) continue; else {
                            strictFail(parser, "Attribute without value");
                            parser.tag.attributes[parser.attribName] = "";
                            parser.attribValue = "";
                            emitNode(parser, "onattribute", {
                                name: parser.attribName,
                                value: ""
                            });
                            parser.attribName = "";
                            if (">" === c) openTag(parser); else if (is(nameStart, c)) {
                                parser.attribName = c;
                                parser.state = S.ATTRIB_NAME;
                            } else {
                                strictFail(parser, "Invalid attribute name");
                                parser.state = S.ATTRIB;
                            }
                        }
                        continue;

                      case S.ATTRIB_VALUE:
                        if (is(whitespace, c)) continue; else if (is(quote, c)) {
                            parser.q = c;
                            parser.state = S.ATTRIB_VALUE_QUOTED;
                        } else {
                            strictFail(parser, "Unquoted attribute value");
                            parser.state = S.ATTRIB_VALUE_UNQUOTED;
                            parser.attribValue = c;
                        }
                        continue;

                      case S.ATTRIB_VALUE_QUOTED:
                        if (c !== parser.q) {
                            if ("&" === c) parser.state = S.ATTRIB_VALUE_ENTITY_Q; else parser.attribValue += c;
                            continue;
                        }
                        attrib(parser);
                        parser.q = "";
                        parser.state = S.ATTRIB_VALUE_CLOSED;
                        continue;

                      case S.ATTRIB_VALUE_CLOSED:
                        if (is(whitespace, c)) parser.state = S.ATTRIB; else if (">" === c) openTag(parser); else if ("/" === c) parser.state = S.OPEN_TAG_SLASH; else if (is(nameStart, c)) {
                            strictFail(parser, "No whitespace between attributes");
                            parser.attribName = c;
                            parser.attribValue = "";
                            parser.state = S.ATTRIB_NAME;
                        } else strictFail(parser, "Invalid attribute name");
                        continue;

                      case S.ATTRIB_VALUE_UNQUOTED:
                        if (not(attribEnd, c)) {
                            if ("&" === c) parser.state = S.ATTRIB_VALUE_ENTITY_U; else parser.attribValue += c;
                            continue;
                        }
                        attrib(parser);
                        if (">" === c) openTag(parser); else parser.state = S.ATTRIB;
                        continue;

                      case S.CLOSE_TAG:
                        if (!parser.tagName) if (is(whitespace, c)) continue; else if (not(nameStart, c)) if (parser.script) {
                            parser.script += "</" + c;
                            parser.state = S.SCRIPT;
                        } else strictFail(parser, "Invalid tagname in closing tag."); else parser.tagName = c; else if (">" === c) closeTag(parser); else if (is(nameBody, c)) parser.tagName += c; else if (parser.script) {
                            parser.script += "</" + parser.tagName;
                            parser.tagName = "";
                            parser.state = S.SCRIPT;
                        } else {
                            if (not(whitespace, c)) strictFail(parser, "Invalid tagname in closing tag");
                            parser.state = S.CLOSE_TAG_SAW_WHITE;
                        }
                        continue;

                      case S.CLOSE_TAG_SAW_WHITE:
                        if (is(whitespace, c)) continue;
                        if (">" === c) closeTag(parser); else strictFail(parser, "Invalid characters in closing tag");
                        continue;

                      case S.TEXT_ENTITY:
                      case S.ATTRIB_VALUE_ENTITY_Q:
                      case S.ATTRIB_VALUE_ENTITY_U:
                        var returnState;
                        var buffer;
                        switch (parser.state) {
                          case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = "textNode";
                            break;

                          case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = "attribValue";
                            break;

                          case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = "attribValue";
                        }
                        if (";" === c) {
                            parser[buffer] += parseEntity(parser);
                            parser.entity = "";
                            parser.state = returnState;
                        } else if (is(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c; else {
                            strictFail(parser, "Invalid character in entity name");
                            parser[buffer] += "&" + parser.entity + c;
                            parser.entity = "";
                            parser.state = returnState;
                        }
                        continue;

                      default:
                        throw new Error(parser, "Unknown state: " + parser.state);
                    }
                }
                if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
                return parser;
            }
            if (!String.fromCodePoint) !function() {
                var stringFromCharCode = String.fromCharCode;
                var floor = Math.floor;
                var fromCodePoint = function() {
                    var MAX_SIZE = 16384;
                    var codeUnits = [];
                    var highSurrogate;
                    var lowSurrogate;
                    var index = -1;
                    var length = arguments.length;
                    if (!length) return "";
                    var result = "";
                    while (++index < length) {
                        var codePoint = Number(arguments[index]);
                        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) throw RangeError("Invalid code point: " + codePoint);
                        if (codePoint <= 65535) codeUnits.push(codePoint); else {
                            codePoint -= 65536;
                            highSurrogate = (codePoint >> 10) + 55296;
                            lowSurrogate = codePoint % 1024 + 56320;
                            codeUnits.push(highSurrogate, lowSurrogate);
                        }
                        if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                            result += stringFromCharCode.apply(null, codeUnits);
                            codeUnits.length = 0;
                        }
                    }
                    return result;
                };
                if (Object.defineProperty) Object.defineProperty(String, "fromCodePoint", {
                    value: fromCodePoint,
                    configurable: true,
                    writable: true
                }); else String.fromCodePoint = fromCodePoint;
            }();
        }(false ? (void 0).sax = {} : exports);
    }).call(exports, __webpack_require__(229).Buffer);
}, function(module, exports, __webpack_require__) {
    (function(global) {
        "use strict";
        var base64 = __webpack_require__(230);
        var ieee754 = __webpack_require__(231);
        var isArray = __webpack_require__(232);
        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        Buffer.TYPED_ARRAY_SUPPORT = void 0 !== global.TYPED_ARRAY_SUPPORT ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
        exports.kMaxLength = kMaxLength();
        function typedArraySupport() {
            try {
                var arr = new Uint8Array(1);
                arr.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42;
                    }
                };
                return 42 === arr.foo() && "function" === typeof arr.subarray && 0 === arr.subarray(1, 1).byteLength;
            } catch (e) {
                return false;
            }
        }
        function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function createBuffer(that, length) {
            if (kMaxLength() < length) throw new RangeError("Invalid typed array length");
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = new Uint8Array(length);
                that.__proto__ = Buffer.prototype;
            } else {
                if (null === that) that = new Buffer(length);
                that.length = length;
            }
            return that;
        }
        function Buffer(arg, encodingOrOffset, length) {
            if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) return new Buffer(arg, encodingOrOffset, length);
            if ("number" === typeof arg) {
                if ("string" === typeof encodingOrOffset) throw new Error("If encoding is specified then the first argument must be a string");
                return allocUnsafe(this, arg);
            }
            return from(this, arg, encodingOrOffset, length);
        }
        Buffer.poolSize = 8192;
        Buffer._augment = function(arr) {
            arr.__proto__ = Buffer.prototype;
            return arr;
        };
        function from(that, value, encodingOrOffset, length) {
            if ("number" === typeof value) throw new TypeError('"value" argument must not be a number');
            if ("undefined" !== typeof ArrayBuffer && value instanceof ArrayBuffer) return fromArrayBuffer(that, value, encodingOrOffset, length);
            if ("string" === typeof value) return fromString(that, value, encodingOrOffset);
            return fromObject(that, value);
        }
        Buffer.from = function(value, encodingOrOffset, length) {
            return from(null, value, encodingOrOffset, length);
        };
        if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype;
            Buffer.__proto__ = Uint8Array;
            if ("undefined" !== typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer) Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true
            });
        }
        function assertSize(size) {
            if ("number" !== typeof size) throw new TypeError('"size" argument must be a number'); else if (size < 0) throw new RangeError('"size" argument must not be negative');
        }
        function alloc(that, size, fill, encoding) {
            assertSize(size);
            if (size <= 0) return createBuffer(that, size);
            if (void 0 !== fill) return "string" === typeof encoding ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
            return createBuffer(that, size);
        }
        Buffer.alloc = function(size, fill, encoding) {
            return alloc(null, size, fill, encoding);
        };
        function allocUnsafe(that, size) {
            assertSize(size);
            that = createBuffer(that, size < 0 ? 0 : 0 | checked(size));
            if (!Buffer.TYPED_ARRAY_SUPPORT) for (var i = 0; i < size; ++i) that[i] = 0;
            return that;
        }
        Buffer.allocUnsafe = function(size) {
            return allocUnsafe(null, size);
        };
        Buffer.allocUnsafeSlow = function(size) {
            return allocUnsafe(null, size);
        };
        function fromString(that, string, encoding) {
            if ("string" !== typeof encoding || "" === encoding) encoding = "utf8";
            if (!Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
            var length = 0 | byteLength(string, encoding);
            that = createBuffer(that, length);
            var actual = that.write(string, encoding);
            if (actual !== length) that = that.slice(0, actual);
            return that;
        }
        function fromArrayLike(that, array) {
            var length = array.length < 0 ? 0 : 0 | checked(array.length);
            that = createBuffer(that, length);
            for (var i = 0; i < length; i += 1) that[i] = 255 & array[i];
            return that;
        }
        function fromArrayBuffer(that, array, byteOffset, length) {
            array.byteLength;
            if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError("'offset' is out of bounds");
            if (array.byteLength < byteOffset + (length || 0)) throw new RangeError("'length' is out of bounds");
            if (void 0 === byteOffset && void 0 === length) array = new Uint8Array(array); else if (void 0 === length) array = new Uint8Array(array, byteOffset); else array = new Uint8Array(array, byteOffset, length);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = array;
                that.__proto__ = Buffer.prototype;
            } else that = fromArrayLike(that, array);
            return that;
        }
        function fromObject(that, obj) {
            if (Buffer.isBuffer(obj)) {
                var len = 0 | checked(obj.length);
                that = createBuffer(that, len);
                if (0 === that.length) return that;
                obj.copy(that, 0, 0, len);
                return that;
            }
            if (obj) {
                if ("undefined" !== typeof ArrayBuffer && obj.buffer instanceof ArrayBuffer || "length" in obj) {
                    if ("number" !== typeof obj.length || isnan(obj.length)) return createBuffer(that, 0);
                    return fromArrayLike(that, obj);
                }
                if ("Buffer" === obj.type && isArray(obj.data)) return fromArrayLike(that, obj.data);
            }
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        function checked(length) {
            if (length >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes");
            return 0 | length;
        }
        function SlowBuffer(length) {
            if (+length != length) length = 0;
            return Buffer.alloc(+length);
        }
        Buffer.isBuffer = function(b) {
            return !!(null != b && b._isBuffer);
        };
        Buffer.compare = function(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError("Arguments must be Buffers");
            if (a === b) return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        Buffer.isEncoding = function(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;

              default:
                return false;
            }
        };
        Buffer.concat = function(list, length) {
            if (!isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === list.length) return Buffer.alloc(0);
            var i;
            if (void 0 === length) {
                length = 0;
                for (i = 0; i < list.length; ++i) length += list[i].length;
            }
            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
                buf.copy(buffer, pos);
                pos += buf.length;
            }
            return buffer;
        };
        function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) return string.length;
            if ("undefined" !== typeof ArrayBuffer && "function" === typeof ArrayBuffer.isView && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) return string.byteLength;
            if ("string" !== typeof string) string = "" + string;
            var len = string.length;
            if (0 === len) return 0;
            var loweredCase = false;
            for (;;) switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;

              case "utf8":
              case "utf-8":
              case void 0:
                return utf8ToBytes(string).length;

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * len;

              case "hex":
                return len >>> 1;

              case "base64":
                return base64ToBytes(string).length;

              default:
                if (loweredCase) return utf8ToBytes(string).length;
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
        }
        Buffer.byteLength = byteLength;
        function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (void 0 === start || start < 0) start = 0;
            if (start > this.length) return "";
            if (void 0 === end || end > this.length) end = this.length;
            if (end <= 0) return "";
            end >>>= 0;
            start >>>= 0;
            if (end <= start) return "";
            if (!encoding) encoding = "utf8";
            while (true) switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);

              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);

              case "ascii":
                return asciiSlice(this, start, end);

              case "latin1":
              case "binary":
                return latin1Slice(this, start, end);

              case "base64":
                return base64Slice(this, start, end);

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);

              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
        }
        Buffer.prototype._isBuffer = true;
        function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
        }
        Buffer.prototype.swap16 = function() {
            var len = this.length;
            if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var i = 0; i < len; i += 2) swap(this, i, i + 1);
            return this;
        };
        Buffer.prototype.swap32 = function() {
            var len = this.length;
            if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
            }
            return this;
        };
        Buffer.prototype.swap64 = function() {
            var len = this.length;
            if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
            }
            return this;
        };
        Buffer.prototype.toString = function() {
            var length = 0 | this.length;
            if (0 === length) return "";
            if (0 === arguments.length) return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
        };
        Buffer.prototype.equals = function(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return true;
            return 0 === Buffer.compare(this, b);
        };
        Buffer.prototype.inspect = function() {
            var str = "";
            var max = exports.INSPECT_MAX_BYTES;
            if (this.length > 0) {
                str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                if (this.length > max) str += " ... ";
            }
            return "<Buffer " + str + ">";
        };
        Buffer.prototype.compare = function(target, start, end, thisStart, thisEnd) {
            if (!Buffer.isBuffer(target)) throw new TypeError("Argument must be a Buffer");
            if (void 0 === start) start = 0;
            if (void 0 === end) end = target ? target.length : 0;
            if (void 0 === thisStart) thisStart = 0;
            if (void 0 === thisEnd) thisEnd = this.length;
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
            if (thisStart >= thisEnd && start >= end) return 0;
            if (thisStart >= thisEnd) return -1;
            if (start >= end) return 1;
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target) return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (0 === buffer.length) return -1;
            if ("string" === typeof byteOffset) {
                encoding = byteOffset;
                byteOffset = 0;
            } else if (byteOffset > 2147483647) byteOffset = 2147483647; else if (byteOffset < -2147483648) byteOffset = -2147483648;
            byteOffset = +byteOffset;
            if (isNaN(byteOffset)) byteOffset = dir ? 0 : buffer.length - 1;
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) if (dir) return -1; else byteOffset = buffer.length - 1; else if (byteOffset < 0) if (dir) byteOffset = 0; else return -1;
            if ("string" === typeof val) val = Buffer.from(val, encoding);
            if (Buffer.isBuffer(val)) {
                if (0 === val.length) return -1;
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if ("number" === typeof val) {
                val &= 255;
                if (Buffer.TYPED_ARRAY_SUPPORT && "function" === typeof Uint8Array.prototype.indexOf) if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset); else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (void 0 !== encoding) {
                encoding = String(encoding).toLowerCase();
                if ("ucs2" === encoding || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding) {
                    if (arr.length < 2 || val.length < 2) return -1;
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                }
            }
            function read(buf, i) {
                if (1 === indexSize) return buf[i]; else return buf.readUInt16BE(i * indexSize);
            }
            var i;
            if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                }
            } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                    var found = true;
                    for (var j = 0; j < valLength; j++) if (read(arr, i + j) !== read(val, j)) {
                        found = false;
                        break;
                    }
                    if (found) return i;
                }
            }
            return -1;
        }
        Buffer.prototype.includes = function(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer.prototype.indexOf = function(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer.prototype.lastIndexOf = function(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) length = remaining; else {
                length = Number(length);
                if (length > remaining) length = remaining;
            }
            var strLen = string.length;
            if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
            if (length > strLen / 2) length = strLen / 2;
            for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(2 * i, 2), 16);
                if (isNaN(parsed)) return i;
                buf[offset + i] = parsed;
            }
            return i;
        }
        function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer.prototype.write = function(string, offset, length, encoding) {
            if (void 0 === offset) {
                encoding = "utf8";
                length = this.length;
                offset = 0;
            } else if (void 0 === length && "string" === typeof offset) {
                encoding = offset;
                length = this.length;
                offset = 0;
            } else if (isFinite(offset)) {
                offset |= 0;
                if (isFinite(length)) {
                    length |= 0;
                    if (void 0 === encoding) encoding = "utf8";
                } else {
                    encoding = length;
                    length = void 0;
                }
            } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            var remaining = this.length - offset;
            if (void 0 === length || length > remaining) length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            if (!encoding) encoding = "utf8";
            var loweredCase = false;
            for (;;) switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);

              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);

              case "ascii":
                return asciiWrite(this, string, offset, length);

              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length);

              case "base64":
                return base64Write(this, string, offset, length);

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);

              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
        };
        Buffer.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        function base64Slice(buf, start, end) {
            if (0 === start && end === buf.length) return base64.fromByteArray(buf); else return base64.fromByteArray(buf.slice(start, end));
        }
        function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 128) codePoint = firstByte;
                        break;

                      case 2:
                        secondByte = buf[i + 1];
                        if (128 === (192 & secondByte)) {
                            tempCodePoint = (31 & firstByte) << 6 | 63 & secondByte;
                            if (tempCodePoint > 127) codePoint = tempCodePoint;
                        }
                        break;

                      case 3:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        if (128 === (192 & secondByte) && 128 === (192 & thirdByte)) {
                            tempCodePoint = (15 & firstByte) << 12 | (63 & secondByte) << 6 | 63 & thirdByte;
                            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                        }
                        break;

                      case 4:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        fourthByte = buf[i + 3];
                        if (128 === (192 & secondByte) && 128 === (192 & thirdByte) && 128 === (192 & fourthByte)) {
                            tempCodePoint = (15 & firstByte) << 18 | (63 & secondByte) << 12 | (63 & thirdByte) << 6 | 63 & fourthByte;
                            if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                        }
                    }
                }
                if (null === codePoint) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | 1023 & codePoint;
                }
                res.push(codePoint);
                i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
        }
        var MAX_ARGUMENTS_LENGTH = 4096;
        function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
            var res = "";
            var i = 0;
            while (i < len) res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            return res;
        }
        function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) ret += String.fromCharCode(127 & buf[i]);
            return ret;
        }
        function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) ret += String.fromCharCode(buf[i]);
            return ret;
        }
        function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = "";
            for (var i = start; i < end; ++i) out += toHex(buf[i]);
            return out;
        }
        function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
            return res;
        }
        Buffer.prototype.slice = function(start, end) {
            var len = this.length;
            start = ~~start;
            end = void 0 === end ? len : ~~end;
            if (start < 0) {
                start += len;
                if (start < 0) start = 0;
            } else if (start > len) start = len;
            if (end < 0) {
                end += len;
                if (end < 0) end = 0;
            } else if (end > len) end = len;
            if (end < start) end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer.prototype;
            } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, void 0);
                for (var i = 0; i < sliceLen; ++i) newBuf[i] = this[i + start];
            }
            return newBuf;
        };
        function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
            if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) val += this[offset + i] * mul;
            return val;
        };
        Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 256)) val += this[offset + --byteLength] * mul;
            return val;
        };
        Buffer.prototype.readUInt8 = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
        };
        Buffer.prototype.readUInt16LE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
        };
        Buffer.prototype.readUInt16BE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
        };
        Buffer.prototype.readUInt32LE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3];
        };
        Buffer.prototype.readUInt32BE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return 16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) val += this[offset + i] * mul;
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) val += this[offset + --i] * mul;
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readInt8 = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(128 & this[offset])) return this[offset];
            return (255 - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return 32768 & val ? 4294901760 | val : val;
        };
        Buffer.prototype.readInt16BE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return 32768 & val ? 4294901760 | val : val;
        };
        Buffer.prototype.readInt32LE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer.prototype.readInt32BE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer.prototype.readFloatLE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
        }
        Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
            value = +value;
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = 255 & value;
            while (++i < byteLength && (mul *= 256)) this[offset + i] = value / mul & 255;
            return offset + byteLength;
        };
        Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
            value = +value;
            offset |= 0;
            byteLength |= 0;
            if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
            }
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = 255 & value;
            while (--i >= 0 && (mul *= 256)) this[offset + i] = value / mul & 255;
            return offset + byteLength;
        };
        Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            this[offset] = 255 & value;
            return offset + 1;
        };
        function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0) value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> 8 * (littleEndian ? i : 1 - i);
        }
        Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = 255 & value;
                this[offset + 1] = value >>> 8;
            } else objectWriteUInt16(this, value, offset, true);
            return offset + 2;
        };
        Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = 255 & value;
            } else objectWriteUInt16(this, value, offset, false);
            return offset + 2;
        };
        function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0) value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) buf[offset + i] = value >>> 8 * (littleEndian ? i : 3 - i) & 255;
        }
        Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = 255 & value;
            } else objectWriteUInt32(this, value, offset, true);
            return offset + 4;
        };
        Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = 255 & value;
            } else objectWriteUInt32(this, value, offset, false);
            return offset + 4;
        };
        Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = 255 & value;
            while (++i < byteLength && (mul *= 256)) {
                if (value < 0 && 0 === sub && 0 !== this[offset + i - 1]) sub = 1;
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = 255 & value;
            while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && 0 === sub && 0 !== this[offset + i + 1]) sub = 1;
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            if (value < 0) value = 255 + value + 1;
            this[offset] = 255 & value;
            return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = 255 & value;
                this[offset + 1] = value >>> 8;
            } else objectWriteUInt16(this, value, offset, true);
            return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = 255 & value;
            } else objectWriteUInt16(this, value, offset, false);
            return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = 255 & value;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
            } else objectWriteUInt32(this, value, offset, true);
            return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
            value = +value;
            offset |= 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0) value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = 255 & value;
            } else objectWriteUInt32(this, value, offset, false);
            return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
            if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.copy = function(target, targetStart, start, end) {
            if (!start) start = 0;
            if (!end && 0 !== end) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start;
            if (end === start) return 0;
            if (0 === target.length || 0 === this.length) return 0;
            if (targetStart < 0) throw new RangeError("targetStart out of bounds");
            if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");
            if (end > this.length) end = this.length;
            if (target.length - targetStart < end - start) end = target.length - targetStart + start;
            var len = end - start;
            var i;
            if (this === target && start < targetStart && targetStart < end) for (i = len - 1; i >= 0; --i) target[i + targetStart] = this[i + start]; else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) for (i = 0; i < len; ++i) target[i + targetStart] = this[i + start]; else Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
            return len;
        };
        Buffer.prototype.fill = function(val, start, end, encoding) {
            if ("string" === typeof val) {
                if ("string" === typeof start) {
                    encoding = start;
                    start = 0;
                    end = this.length;
                } else if ("string" === typeof end) {
                    encoding = end;
                    end = this.length;
                }
                if (1 === val.length) {
                    var code = val.charCodeAt(0);
                    if (code < 256) val = code;
                }
                if (void 0 !== encoding && "string" !== typeof encoding) throw new TypeError("encoding must be a string");
                if ("string" === typeof encoding && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
            } else if ("number" === typeof val) val &= 255;
            if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
            if (end <= start) return this;
            start >>>= 0;
            end = void 0 === end ? this.length : end >>> 0;
            if (!val) val = 0;
            var i;
            if ("number" === typeof val) for (i = start; i < end; ++i) this[i] = val; else {
                var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
                var len = bytes.length;
                for (i = 0; i < end - start; ++i) this[i + start] = bytes[i % len];
            }
            return this;
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
        function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, "");
            if (str.length < 2) return "";
            while (str.length % 4 !== 0) str += "=";
            return str;
        }
        function stringtrim(str) {
            if (str.trim) return str.trim();
            return str.replace(/^\s+|\s+$/g, "");
        }
        function toHex(n) {
            if (n < 16) return "0" + n.toString(16);
            return n.toString(16);
        }
        function utf8ToBytes(string, units) {
            units = units || 1 / 0;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                        if (codePoint > 56319) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        } else if (i + 1 === length) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                    }
                    if (codePoint < 56320) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        leadSurrogate = codePoint;
                        continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = null;
                if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(codePoint >> 6 | 192, 63 & codePoint | 128);
                } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
                } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0) break;
                    bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
                } else throw new Error("Invalid code point");
            }
            return bytes;
        }
        function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) byteArray.push(255 & str.charCodeAt(i));
            return byteArray;
        }
        function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
            }
            return byteArray;
        }
        function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
            }
            return i;
        }
        function isnan(val) {
            return val !== val;
        }
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = "undefined" !== typeof Uint8Array ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function placeHoldersCount(b64) {
        var len = b64.length;
        if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        return "=" === b64[len - 2] ? 2 : "=" === b64[len - 1] ? 1 : 0;
    }
    function byteLength(b64) {
        return 3 * b64.length / 4 - placeHoldersCount(b64);
    }
    function toByteArray(b64) {
        var i, l, tmp, placeHolders, arr;
        var len = b64.length;
        placeHolders = placeHoldersCount(b64);
        arr = new Arr(3 * len / 4 - placeHolders);
        l = placeHolders > 0 ? len - 4 : len;
        var L = 0;
        for (i = 0; i < l; i += 4) {
            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
            arr[L++] = tmp >> 16 & 255;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = 255 & tmp;
        }
        if (2 === placeHolders) {
            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
            arr[L++] = 255 & tmp;
        } else if (1 === placeHolders) {
            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
            arr[L++] = tmp >> 8 & 255;
            arr[L++] = 255 & tmp;
        }
        return arr;
    }
    function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[63 & num];
    }
    function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
            tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
            output.push(tripletToBase64(tmp));
        }
        return output.join("");
    }
    function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3;
        var output = "";
        var parts = [];
        var maxChunkLength = 16383;
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        if (1 === extraBytes) {
            tmp = uint8[len - 1];
            output += lookup[tmp >> 2];
            output += lookup[tmp << 4 & 63];
            output += "==";
        } else if (2 === extraBytes) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            output += lookup[tmp >> 10];
            output += lookup[tmp >> 4 & 63];
            output += lookup[tmp << 2 & 63];
            output += "=";
        }
        parts.push(output);
        return parts.join("");
    }
}, function(module, exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = 8 * nBytes - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (;nBits > 0; e = 256 * e + buffer[offset + i], i += d, nBits -= 8) ;
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (;nBits > 0; m = 256 * m + buffer[offset + i], i += d, nBits -= 8) ;
        if (0 === e) e = 1 - eBias; else if (e === eMax) return m ? NaN : (s ? -1 : 1) * (1 / 0); else {
            m += Math.pow(2, mLen);
            e -= eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = 8 * nBytes - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === 1 / 0) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) value += rt / c; else value += rt * Math.pow(2, 1 - eBias);
            if (value * c >= 2) {
                e++;
                c /= 2;
            }
            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e += eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }
        for (;mLen >= 8; buffer[offset + i] = 255 & m, i += d, m /= 256, mLen -= 8) ;
        e = e << mLen | m;
        eLen += mLen;
        for (;eLen > 0; buffer[offset + i] = 255 & e, i += d, e /= 256, eLen -= 8) ;
        buffer[offset + i - d] |= 128 * s;
    };
}, function(module, exports) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
        return "[object Array]" == toString.call(arr);
    };
}, function(module, exports, __webpack_require__) {
    module.exports = Stream;
    var EE = __webpack_require__(234).EventEmitter;
    var inherits = __webpack_require__(235);
    inherits(Stream, EE);
    Stream.Readable = __webpack_require__(236);
    Stream.Writable = __webpack_require__(251);
    Stream.Duplex = __webpack_require__(252);
    Stream.Transform = __webpack_require__(253);
    Stream.PassThrough = __webpack_require__(254);
    Stream.Stream = Stream;
    function Stream() {
        EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
            if (dest.writable) if (false === dest.write(chunk) && source.pause) source.pause();
        }
        source.on("data", ondata);
        function ondrain() {
            if (source.readable && source.resume) source.resume();
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || false !== options.end)) {
            source.on("end", onend);
            source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
            if (didOnEnd) return;
            didOnEnd = true;
            dest.end();
        }
        function onclose() {
            if (didOnEnd) return;
            didOnEnd = true;
            if ("function" === typeof dest.destroy) dest.destroy();
        }
        function onerror(er) {
            cleanup();
            if (0 === EE.listenerCount(this, "error")) throw er;
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);
            source.removeListener("end", onend);
            source.removeListener("close", onclose);
            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);
            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);
            dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
    };
}, function(module, exports) {
    function EventEmitter() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || void 0;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
        if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
        this._maxListeners = n;
        return this;
    };
    EventEmitter.prototype.emit = function(type) {
        var er, handler, len, args, i, listeners;
        if (!this._events) this._events = {};
        if ("error" === type) if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
            er = arguments[1];
            if (er instanceof Error) throw er; else {
                var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
                err.context = er;
                throw err;
            }
        }
        handler = this._events[type];
        if (isUndefined(handler)) return false;
        if (isFunction(handler)) switch (arguments.length) {
          case 1:
            handler.call(this);
            break;

          case 2:
            handler.call(this, arguments[1]);
            break;

          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;

          default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        } else if (isObject(handler)) {
            args = Array.prototype.slice.call(arguments, 1);
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++) listeners[i].apply(this, args);
        }
        return true;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
        var m;
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        if (!this._events) this._events = {};
        if (this._events.newListener) this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
        if (!this._events[type]) this._events[type] = listener; else if (isObject(this._events[type])) this._events[type].push(listener); else this._events[type] = [ this._events[type], listener ];
        if (isObject(this._events[type]) && !this._events[type].warned) {
            if (!isUndefined(this._maxListeners)) m = this._maxListeners; else m = EventEmitter.defaultMaxListeners;
            if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
                if ("function" === typeof console.trace) console.trace();
            }
        }
        return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        var fired = false;
        function g() {
            this.removeListener(type, g);
            if (!fired) {
                fired = true;
                listener.apply(this, arguments);
            }
        }
        g.listener = listener;
        this.on(type, g);
        return this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
        var list, position, length, i;
        if (!isFunction(listener)) throw TypeError("listener must be a function");
        if (!this._events || !this._events[type]) return this;
        list = this._events[type];
        length = list.length;
        position = -1;
        if (list === listener || isFunction(list.listener) && list.listener === listener) {
            delete this._events[type];
            if (this._events.removeListener) this.emit("removeListener", type, listener);
        } else if (isObject(list)) {
            for (i = length; i-- > 0; ) if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                position = i;
                break;
            }
            if (position < 0) return this;
            if (1 === list.length) {
                list.length = 0;
                delete this._events[type];
            } else list.splice(position, 1);
            if (this._events.removeListener) this.emit("removeListener", type, listener);
        }
        return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
        var key, listeners;
        if (!this._events) return this;
        if (!this._events.removeListener) {
            if (0 === arguments.length) this._events = {}; else if (this._events[type]) delete this._events[type];
            return this;
        }
        if (0 === arguments.length) {
            for (key in this._events) {
                if ("removeListener" === key) continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = {};
            return this;
        }
        listeners = this._events[type];
        if (isFunction(listeners)) this.removeListener(type, listeners); else if (listeners) while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
        delete this._events[type];
        return this;
    };
    EventEmitter.prototype.listeners = function(type) {
        var ret;
        if (!this._events || !this._events[type]) ret = []; else if (isFunction(this._events[type])) ret = [ this._events[type] ]; else ret = this._events[type].slice();
        return ret;
    };
    EventEmitter.prototype.listenerCount = function(type) {
        if (this._events) {
            var evlistener = this._events[type];
            if (isFunction(evlistener)) return 1; else if (evlistener) return evlistener.length;
        }
        return 0;
    };
    EventEmitter.listenerCount = function(emitter, type) {
        return emitter.listenerCount(type);
    };
    function isFunction(arg) {
        return "function" === typeof arg;
    }
    function isNumber(arg) {
        return "number" === typeof arg;
    }
    function isObject(arg) {
        return "object" === typeof arg && null !== arg;
    }
    function isUndefined(arg) {
        return arg === void 0;
    }
}, function(module, exports) {
    if ("function" === typeof Object.create) module.exports = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }; else module.exports = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    };
}, function(module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(237);
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = __webpack_require__(246);
    exports.Duplex = __webpack_require__(245);
    exports.Transform = __webpack_require__(249);
    exports.PassThrough = __webpack_require__(250);
}, function(module, exports, __webpack_require__) {
    (function(global, process) {
        "use strict";
        var processNextTick = __webpack_require__(238);
        module.exports = Readable;
        var isArray = __webpack_require__(232);
        var Duplex;
        Readable.ReadableState = ReadableState;
        __webpack_require__(234).EventEmitter;
        var EElistenerCount = function(emitter, type) {
            return emitter.listeners(type).length;
        };
        var Stream = __webpack_require__(239);
        var Buffer = __webpack_require__(240).Buffer;
        var OurUint8Array = global.Uint8Array || function() {};
        function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
        }
        function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var util = __webpack_require__(241);
        util.inherits = __webpack_require__(235);
        var debugUtil = __webpack_require__(242);
        var debug = void 0;
        if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog("stream"); else debug = function() {};
        var BufferList = __webpack_require__(243);
        var destroyImpl = __webpack_require__(244);
        var StringDecoder;
        util.inherits(Readable, Stream);
        var kProxyEvents = [ "error", "close", "destroy", "pause", "resume" ];
        function prependListener(emitter, event, fn) {
            if ("function" === typeof emitter.prependListener) return emitter.prependListener(event, fn); else if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [ fn, emitter._events[event] ];
        }
        function ReadableState(options, stream) {
            Duplex = Duplex || __webpack_require__(245);
            options = options || {};
            this.objectMode = !!options.objectMode;
            if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
            var hwm = options.highWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = hwm || 0 === hwm ? hwm : defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.destroyed = false;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
                if (!StringDecoder) StringDecoder = __webpack_require__(248).StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
            }
        }
        function Readable(options) {
            Duplex = Duplex || __webpack_require__(245);
            if (!(this instanceof Readable)) return new Readable(options);
            this._readableState = new ReadableState(options, this);
            this.readable = true;
            if (options) {
                if ("function" === typeof options.read) this._read = options.read;
                if ("function" === typeof options.destroy) this._destroy = options.destroy;
            }
            Stream.call(this);
        }
        Object.defineProperty(Readable.prototype, "destroyed", {
            get: function() {
                if (void 0 === this._readableState) return false;
                return this._readableState.destroyed;
            },
            set: function(value) {
                if (!this._readableState) return;
                this._readableState.destroyed = value;
            }
        });
        Readable.prototype.destroy = destroyImpl.destroy;
        Readable.prototype._undestroy = destroyImpl.undestroy;
        Readable.prototype._destroy = function(err, cb) {
            this.push(null);
            cb(err);
        };
        Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
                if ("string" === typeof chunk) {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                        chunk = Buffer.from(chunk, encoding);
                        encoding = "";
                    }
                    skipChunkCheck = true;
                }
            } else skipChunkCheck = true;
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
        };
        Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false);
        };
        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            var state = stream._readableState;
            if (null === chunk) {
                state.reading = false;
                onEofChunk(stream, state);
            } else {
                var er;
                if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                if (er) stream.emit("error", er); else if (state.objectMode || chunk && chunk.length > 0) {
                    if ("string" !== typeof chunk && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
                    if (addToFront) if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event")); else addChunk(stream, state, chunk, true); else if (state.ended) stream.emit("error", new Error("stream.push() after EOF")); else {
                        state.reading = false;
                        if (state.decoder && !encoding) {
                            chunk = state.decoder.write(chunk);
                            if (state.objectMode || 0 !== chunk.length) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state);
                        } else addChunk(stream, state, chunk, false);
                    }
                } else if (!addToFront) state.reading = false;
            }
            return needMoreData(state);
        }
        function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && 0 === state.length && !state.sync) {
                stream.emit("data", chunk);
                stream.read(0);
            } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk);
                if (state.needReadable) emitReadable(stream);
            }
            maybeReadMore(stream, state);
        }
        function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && "string" !== typeof chunk && void 0 !== chunk && !state.objectMode) er = new TypeError("Invalid non-string/buffer chunk");
            return er;
        }
        function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || 0 === state.length);
        }
        Readable.prototype.isPaused = function() {
            return false === this._readableState.flowing;
        };
        Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder) StringDecoder = __webpack_require__(248).StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
        };
        var MAX_HWM = 8388608;
        function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) n = MAX_HWM; else {
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
            }
            return n;
        }
        function howMuchToRead(n, state) {
            if (n <= 0 || 0 === state.length && state.ended) return 0;
            if (state.objectMode) return 1;
            if (n !== n) if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;
            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length) return n;
            if (!state.ended) {
                state.needReadable = true;
                return 0;
            }
            return state.length;
        }
        Readable.prototype.read = function(n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (0 !== n) state.emittedReadable = false;
            if (0 === n && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                debug("read: emitReadable", state.length, state.ended);
                if (0 === state.length && state.ended) endReadable(this); else emitReadable(this);
                return null;
            }
            n = howMuchToRead(n, state);
            if (0 === n && state.ended) {
                if (0 === state.length) endReadable(this);
                return null;
            }
            var doRead = state.needReadable;
            debug("need readable", doRead);
            if (0 === state.length || state.length - n < state.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
            }
            if (state.ended || state.reading) {
                doRead = false;
                debug("reading or ended", doRead);
            } else if (doRead) {
                debug("do read");
                state.reading = true;
                state.sync = true;
                if (0 === state.length) state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading) n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0) ret = fromList(n, state); else ret = null;
            if (null === ret) {
                state.needReadable = true;
                n = 0;
            } else state.length -= n;
            if (0 === state.length) {
                if (!state.ended) state.needReadable = true;
                if (nOrig !== n && state.ended) endReadable(this);
            }
            if (null !== ret) this.emit("data", ret);
            return ret;
        };
        function onEofChunk(stream, state) {
            if (state.ended) return;
            if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                }
            }
            state.ended = true;
            emitReadable(stream);
        }
        function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
                debug("emitReadable", state.flowing);
                state.emittedReadable = true;
                if (state.sync) processNextTick(emitReadable_, stream); else emitReadable_(stream);
            }
        }
        function emitReadable_(stream) {
            debug("emit readable");
            stream.emit("readable");
            flow(stream);
        }
        function maybeReadMore(stream, state) {
            if (!state.readingMore) {
                state.readingMore = true;
                processNextTick(maybeReadMore_, stream, state);
            }
        }
        function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state.length) break; else len = state.length;
            }
            state.readingMore = false;
        }
        Readable.prototype._read = function(n) {
            this.emit("error", new Error("_read() is not implemented"));
        };
        Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;

              case 1:
                state.pipes = [ state.pipes, dest ];
                break;

              default:
                state.pipes.push(dest);
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || false !== pipeOpts.end) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted) processNextTick(endFn); else src.once("end", endFn);
            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) if (unpipeInfo && false === unpipeInfo.hasUnpiped) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                }
            }
            function onend() {
                debug("onend");
                dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);
            var cleanedUp = false;
            function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
            }
            var increasedAwaitDrain = false;
            src.on("data", ondata);
            function ondata(chunk) {
                debug("ondata");
                increasedAwaitDrain = false;
                var ret = dest.write(chunk);
                if (false === ret && !increasedAwaitDrain) {
                    if ((1 === state.pipesCount && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                        debug("false write response, pause", src._readableState.awaitDrain);
                        src._readableState.awaitDrain++;
                        increasedAwaitDrain = true;
                    }
                    src.pause();
                }
            }
            function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (0 === EElistenerCount(dest, "error")) dest.emit("error", er);
            }
            prependListener(dest, "error", onerror);
            function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
            }
            dest.once("finish", onfinish);
            function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
            }
            dest.emit("pipe", src);
            if (!state.flowing) {
                debug("pipe resume");
                src.resume();
            }
            return dest;
        };
        function pipeOnDrain(src) {
            return function() {
                var state = src._readableState;
                debug("pipeOnDrain", state.awaitDrain);
                if (state.awaitDrain) state.awaitDrain--;
                if (0 === state.awaitDrain && EElistenerCount(src, "data")) {
                    state.flowing = true;
                    flow(src);
                }
            };
        }
        Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            var unpipeInfo = {
                hasUnpiped: false
            };
            if (0 === state.pipesCount) return this;
            if (1 === state.pipesCount) {
                if (dest && dest !== state.pipes) return this;
                if (!dest) dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest) dest.emit("unpipe", this, unpipeInfo);
                return this;
            }
            if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, unpipeInfo);
                return this;
            }
            var index = indexOf(state.pipes, dest);
            if (index === -1) return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (1 === state.pipesCount) state.pipes = state.pipes[0];
            dest.emit("unpipe", this, unpipeInfo);
            return this;
        };
        Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if ("data" === ev) {
                if (false !== this._readableState.flowing) this.resume();
            } else if ("readable" === ev) {
                var state = this._readableState;
                if (!state.endEmitted && !state.readableListening) {
                    state.readableListening = state.needReadable = true;
                    state.emittedReadable = false;
                    if (!state.reading) processNextTick(nReadingNextTick, this); else if (state.length) emitReadable(this);
                }
            }
            return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;
        function nReadingNextTick(self) {
            debug("readable nexttick read 0");
            self.read(0);
        }
        Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
                debug("resume");
                state.flowing = true;
                resume(this, state);
            }
            return this;
        };
        function resume(stream, state) {
            if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                processNextTick(resume_, stream, state);
            }
        }
        function resume_(stream, state) {
            if (!state.reading) {
                debug("resume read 0");
                stream.read(0);
            }
            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading) stream.read(0);
        }
        Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (false !== this._readableState.flowing) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
            }
            return this;
        };
        function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && null !== stream.read()) ;
        }
        Readable.prototype.wrap = function(stream) {
            var state = this._readableState;
            var paused = false;
            var self = this;
            stream.on("end", function() {
                debug("wrapped end");
                if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) self.push(chunk);
                }
                self.push(null);
            });
            stream.on("data", function(chunk) {
                debug("wrapped data");
                if (state.decoder) chunk = state.decoder.write(chunk);
                if (state.objectMode && (null === chunk || void 0 === chunk)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return;
                var ret = self.push(chunk);
                if (!ret) {
                    paused = true;
                    stream.pause();
                }
            });
            for (var i in stream) if (void 0 === this[i] && "function" === typeof stream[i]) this[i] = function(method) {
                return function() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
            for (var n = 0; n < kProxyEvents.length; n++) stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
            self._read = function(n) {
                debug("wrapped _read", n);
                if (paused) {
                    paused = false;
                    stream.resume();
                }
            };
            return self;
        };
        Readable._fromList = fromList;
        function fromList(n, state) {
            if (0 === state.length) return null;
            var ret;
            if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {
                if (state.decoder) ret = state.buffer.join(""); else if (1 === state.buffer.length) ret = state.buffer.head.data; else ret = state.buffer.concat(state.length);
                state.buffer.clear();
            } else ret = fromListPartial(n, state.buffer, state.decoder);
            return ret;
        }
        function fromListPartial(n, list, hasStrings) {
            var ret;
            if (n < list.head.data.length) {
                ret = list.head.data.slice(0, n);
                list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) ret = list.shift(); else ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
            return ret;
        }
        function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
                var str = p.data;
                var nb = n > str.length ? str.length : n;
                if (nb === str.length) ret += str; else ret += str.slice(0, n);
                n -= nb;
                if (0 === n) {
                    if (nb === str.length) {
                        ++c;
                        if (p.next) list.head = p.next; else list.head = list.tail = null;
                    } else {
                        list.head = p;
                        p.data = str.slice(nb);
                    }
                    break;
                }
                ++c;
            }
            list.length -= c;
            return ret;
        }
        function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
                var buf = p.data;
                var nb = n > buf.length ? buf.length : n;
                buf.copy(ret, ret.length - n, 0, nb);
                n -= nb;
                if (0 === n) {
                    if (nb === buf.length) {
                        ++c;
                        if (p.next) list.head = p.next; else list.head = list.tail = null;
                    } else {
                        list.head = p;
                        p.data = buf.slice(nb);
                    }
                    break;
                }
                ++c;
            }
            list.length -= c;
            return ret;
        }
        function endReadable(stream) {
            var state = stream._readableState;
            if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
            if (!state.endEmitted) {
                state.ended = true;
                processNextTick(endReadableNT, state, stream);
            }
        }
        function endReadableNT(state, stream) {
            if (!state.endEmitted && 0 === state.length) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
            }
        }
        function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;
            return -1;
        }
    }).call(exports, function() {
        return this;
    }(), __webpack_require__(212));
}, function(module, exports, __webpack_require__) {
    (function(process) {
        "use strict";
        if (!process.version || 0 === process.version.indexOf("v0.") || 0 === process.version.indexOf("v1.") && 0 !== process.version.indexOf("v1.8.")) module.exports = nextTick; else module.exports = process.nextTick;
        function nextTick(fn, arg1, arg2, arg3) {
            if ("function" !== typeof fn) throw new TypeError('"callback" argument must be a function');
            var len = arguments.length;
            var args, i;
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn);

              case 2:
                return process.nextTick(function() {
                    fn.call(null, arg1);
                });

              case 3:
                return process.nextTick(function() {
                    fn.call(null, arg1, arg2);
                });

              case 4:
                return process.nextTick(function() {
                    fn.call(null, arg1, arg2, arg3);
                });

              default:
                args = new Array(len - 1);
                i = 0;
                while (i < args.length) args[i++] = arguments[i];
                return process.nextTick(function() {
                    fn.apply(null, args);
                });
            }
        }
    }).call(exports, __webpack_require__(212));
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(234).EventEmitter;
}, function(module, exports, __webpack_require__) {
    var buffer = __webpack_require__(229);
    var Buffer = buffer.Buffer;
    function copyProps(src, dst) {
        for (var key in src) dst[key] = src[key];
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer; else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
    }
    copyProps(Buffer, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if ("number" === typeof arg) throw new TypeError("Argument must not be a number");
        return Buffer(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
        if ("number" !== typeof size) throw new TypeError("Argument must be a number");
        var buf = Buffer(size);
        if (void 0 !== fill) if ("string" === typeof encoding) buf.fill(fill, encoding); else buf.fill(fill); else buf.fill(0);
        return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
        if ("number" !== typeof size) throw new TypeError("Argument must be a number");
        return Buffer(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
        if ("number" !== typeof size) throw new TypeError("Argument must be a number");
        return buffer.SlowBuffer(size);
    };
}, function(module, exports, __webpack_require__) {
    (function(Buffer) {
        function isArray(arg) {
            if (Array.isArray) return Array.isArray(arg);
            return "[object Array]" === objectToString(arg);
        }
        exports.isArray = isArray;
        function isBoolean(arg) {
            return "boolean" === typeof arg;
        }
        exports.isBoolean = isBoolean;
        function isNull(arg) {
            return null === arg;
        }
        exports.isNull = isNull;
        function isNullOrUndefined(arg) {
            return null == arg;
        }
        exports.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
            return "number" === typeof arg;
        }
        exports.isNumber = isNumber;
        function isString(arg) {
            return "string" === typeof arg;
        }
        exports.isString = isString;
        function isSymbol(arg) {
            return "symbol" === typeof arg;
        }
        exports.isSymbol = isSymbol;
        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;
        function isRegExp(re) {
            return "[object RegExp]" === objectToString(re);
        }
        exports.isRegExp = isRegExp;
        function isObject(arg) {
            return "object" === typeof arg && null !== arg;
        }
        exports.isObject = isObject;
        function isDate(d) {
            return "[object Date]" === objectToString(d);
        }
        exports.isDate = isDate;
        function isError(e) {
            return "[object Error]" === objectToString(e) || e instanceof Error;
        }
        exports.isError = isError;
        function isFunction(arg) {
            return "function" === typeof arg;
        }
        exports.isFunction = isFunction;
        function isPrimitive(arg) {
            return null === arg || "boolean" === typeof arg || "number" === typeof arg || "string" === typeof arg || "symbol" === typeof arg || "undefined" === typeof arg;
        }
        exports.isPrimitive = isPrimitive;
        exports.isBuffer = Buffer.isBuffer;
        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }
    }).call(exports, __webpack_require__(229).Buffer);
}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Buffer = __webpack_require__(240).Buffer;
    function copyBuffer(src, target, offset) {
        src.copy(target, offset);
    }
    module.exports = function() {
        function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
        }
        BufferList.prototype.push = function(v) {
            var entry = {
                data: v,
                next: null
            };
            if (this.length > 0) this.tail.next = entry; else this.head = entry;
            this.tail = entry;
            ++this.length;
        };
        BufferList.prototype.unshift = function(v) {
            var entry = {
                data: v,
                next: this.head
            };
            if (0 === this.length) this.tail = entry;
            this.head = entry;
            ++this.length;
        };
        BufferList.prototype.shift = function() {
            if (0 === this.length) return;
            var ret = this.head.data;
            if (1 === this.length) this.head = this.tail = null; else this.head = this.head.next;
            --this.length;
            return ret;
        };
        BufferList.prototype.clear = function() {
            this.head = this.tail = null;
            this.length = 0;
        };
        BufferList.prototype.join = function(s) {
            if (0 === this.length) return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) ret += s + p.data;
            return ret;
        };
        BufferList.prototype.concat = function(n) {
            if (0 === this.length) return Buffer.alloc(0);
            if (1 === this.length) return this.head.data;
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
                copyBuffer(p.data, ret, i);
                i += p.data.length;
                p = p.next;
            }
            return ret;
        };
        return BufferList;
    }();
}, function(module, exports, __webpack_require__) {
    "use strict";
    var processNextTick = __webpack_require__(238);
    function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
            if (cb) cb(err); else if (err && (!this._writableState || !this._writableState.errorEmitted)) processNextTick(emitErrorNT, this, err);
            return;
        }
        if (this._readableState) this._readableState.destroyed = true;
        if (this._writableState) this._writableState.destroyed = true;
        this._destroy(err || null, function(err) {
            if (!cb && err) {
                processNextTick(emitErrorNT, _this, err);
                if (_this._writableState) _this._writableState.errorEmitted = true;
            } else if (cb) cb(err);
        });
    }
    function undestroy() {
        if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
        }
        if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
        }
    }
    function emitErrorNT(self, err) {
        self.emit("error", err);
    }
    module.exports = {
        destroy: destroy,
        undestroy: undestroy
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var processNextTick = __webpack_require__(238);
    var objectKeys = Object.keys || function(obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    };
    module.exports = Duplex;
    var util = __webpack_require__(241);
    util.inherits = __webpack_require__(235);
    var Readable = __webpack_require__(237);
    var Writable = __webpack_require__(246);
    util.inherits(Duplex, Readable);
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
    function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && false === options.readable) this.readable = false;
        if (options && false === options.writable) this.writable = false;
        this.allowHalfOpen = true;
        if (options && false === options.allowHalfOpen) this.allowHalfOpen = false;
        this.once("end", onend);
    }
    function onend() {
        if (this.allowHalfOpen || this._writableState.ended) return;
        processNextTick(onEndNT, this);
    }
    function onEndNT(self) {
        self.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
        get: function() {
            if (void 0 === this._readableState || void 0 === this._writableState) return false;
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(value) {
            if (void 0 === this._readableState || void 0 === this._writableState) return;
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
        }
    });
    Duplex.prototype._destroy = function(err, cb) {
        this.push(null);
        this.end();
        processNextTick(cb, err);
    };
}, function(module, exports, __webpack_require__) {
    (function(process, setImmediate, global) {
        "use strict";
        var processNextTick = __webpack_require__(238);
        module.exports = Writable;
        function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function() {
                onCorkedFinish(_this, state);
            };
        }
        var asyncWrite = !process.browser && [ "v0.10", "v0.9." ].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
        var Duplex;
        Writable.WritableState = WritableState;
        var util = __webpack_require__(241);
        util.inherits = __webpack_require__(235);
        var internalUtil = {
            deprecate: __webpack_require__(247)
        };
        var Stream = __webpack_require__(239);
        var Buffer = __webpack_require__(240).Buffer;
        var OurUint8Array = global.Uint8Array || function() {};
        function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
        }
        function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var destroyImpl = __webpack_require__(244);
        util.inherits(Writable, Stream);
        function nop() {}
        function WritableState(options, stream) {
            Duplex = Duplex || __webpack_require__(245);
            options = options || {};
            this.objectMode = !!options.objectMode;
            if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
            var hwm = options.highWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            this.highWaterMark = hwm || 0 === hwm ? hwm : defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.finalCalled = false;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            this.destroyed = false;
            var noDecode = false === options.decodeStrings;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
                onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
            this.bufferedRequestCount = 0;
            this.corkedRequestsFree = new CorkedRequest(this);
        }
        WritableState.prototype.getBuffer = function() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
                out.push(current);
                current = current.next;
            }
            return out;
        };
        !function() {
            try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                    get: internalUtil.deprecate(function() {
                        return this.getBuffer();
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
                });
            } catch (_) {}
        }();
        var realHasInstance;
        if ("function" === typeof Symbol && Symbol.hasInstance && "function" === typeof Function.prototype[Symbol.hasInstance]) {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function(object) {
                    if (realHasInstance.call(this, object)) return true;
                    return object && object._writableState instanceof WritableState;
                }
            });
        } else realHasInstance = function(object) {
            return object instanceof this;
        };
        function Writable(options) {
            Duplex = Duplex || __webpack_require__(245);
            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) return new Writable(options);
            this._writableState = new WritableState(options, this);
            this.writable = true;
            if (options) {
                if ("function" === typeof options.write) this._write = options.write;
                if ("function" === typeof options.writev) this._writev = options.writev;
                if ("function" === typeof options.destroy) this._destroy = options.destroy;
                if ("function" === typeof options.final) this._final = options.final;
            }
            Stream.call(this);
        }
        Writable.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"));
        };
        function writeAfterEnd(stream, cb) {
            var er = new Error("write after end");
            stream.emit("error", er);
            processNextTick(cb, er);
        }
        function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er = false;
            if (null === chunk) er = new TypeError("May not write null values to stream"); else if ("string" !== typeof chunk && void 0 !== chunk && !state.objectMode) er = new TypeError("Invalid non-string/buffer chunk");
            if (er) {
                stream.emit("error", er);
                processNextTick(cb, er);
                valid = false;
            }
            return valid;
        }
        Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = _isUint8Array(chunk) && !state.objectMode;
            if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
            if ("function" === typeof encoding) {
                cb = encoding;
                encoding = null;
            }
            if (isBuf) encoding = "buffer"; else if (!encoding) encoding = state.defaultEncoding;
            if ("function" !== typeof cb) cb = nop;
            if (state.ended) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
        };
        Writable.prototype.cork = function() {
            var state = this._writableState;
            state.corked++;
        };
        Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
                state.corked--;
                if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
            }
        };
        Writable.prototype.setDefaultEncoding = function(encoding) {
            if ("string" === typeof encoding) encoding = encoding.toLowerCase();
            if (!([ "hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw" ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
        };
        function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && false !== state.decodeStrings && "string" === typeof chunk) chunk = Buffer.from(chunk, encoding);
            return chunk;
        }
        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                    isBuf = true;
                    encoding = "buffer";
                    chunk = newChunk;
                }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret) state.needDrain = true;
            if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                    chunk: chunk,
                    encoding: encoding,
                    isBuf: isBuf,
                    callback: cb,
                    next: null
                };
                if (last) last.next = state.lastBufferedRequest; else state.bufferedRequest = state.lastBufferedRequest;
                state.bufferedRequestCount += 1;
            } else doWrite(stream, state, false, len, chunk, encoding, cb);
            return ret;
        }
        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
        }
        function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
                processNextTick(cb, er);
                processNextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
            } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                stream.emit("error", er);
                finishMaybe(stream, state);
            }
        }
        function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
        }
        function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er) onwriteError(stream, state, sync, er, cb); else {
                var finished = needFinish(state);
                if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
                if (sync) asyncWrite(afterWrite, stream, state, finished, cb); else afterWrite(stream, state, finished, cb);
            }
        }
        function afterWrite(stream, state, finished, cb) {
            if (!finished) onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
        }
        function onwriteDrain(stream, state) {
            if (0 === state.length && state.needDrain) {
                state.needDrain = false;
                stream.emit("drain");
            }
        }
        function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
                var l = state.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                    buffer[count] = entry;
                    if (!entry.isBuf) allBuffers = false;
                    entry = entry.next;
                    count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                    state.corkedRequestsFree = holder.next;
                    holder.next = null;
                } else state.corkedRequestsFree = new CorkedRequest(state);
            } else {
                while (entry) {
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                    entry = entry.next;
                    if (state.writing) break;
                }
                if (null === entry) state.lastBufferedRequest = null;
            }
            state.bufferedRequestCount = 0;
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
        }
        Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"));
        };
        Writable.prototype._writev = null;
        Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if ("function" === typeof chunk) {
                cb = chunk;
                chunk = null;
                encoding = null;
            } else if ("function" === typeof encoding) {
                cb = encoding;
                encoding = null;
            }
            if (null !== chunk && void 0 !== chunk) this.write(chunk, encoding);
            if (state.corked) {
                state.corked = 1;
                this.uncork();
            }
            if (!state.ending && !state.finished) endWritable(this, state, cb);
        };
        function needFinish(state) {
            return state.ending && 0 === state.length && null === state.bufferedRequest && !state.finished && !state.writing;
        }
        function callFinal(stream, state) {
            stream._final(function(err) {
                state.pendingcb--;
                if (err) stream.emit("error", err);
                state.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state);
            });
        }
        function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) if ("function" === typeof stream._final) {
                state.pendingcb++;
                state.finalCalled = true;
                processNextTick(callFinal, stream, state);
            } else {
                state.prefinished = true;
                stream.emit("prefinish");
            }
        }
        function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
                prefinish(stream, state);
                if (0 === state.pendingcb) {
                    state.finished = true;
                    stream.emit("finish");
                }
            }
            return need;
        }
        function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) if (state.finished) processNextTick(cb); else stream.once("finish", cb);
            state.ended = true;
            stream.writable = false;
        }
        function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
            }
            if (state.corkedRequestsFree) state.corkedRequestsFree.next = corkReq; else state.corkedRequestsFree = corkReq;
        }
        Object.defineProperty(Writable.prototype, "destroyed", {
            get: function() {
                if (void 0 === this._writableState) return false;
                return this._writableState.destroyed;
            },
            set: function(value) {
                if (!this._writableState) return;
                this._writableState.destroyed = value;
            }
        });
        Writable.prototype.destroy = destroyImpl.destroy;
        Writable.prototype._undestroy = destroyImpl.undestroy;
        Writable.prototype._destroy = function(err, cb) {
            this.end();
            cb(err);
        };
    }).call(exports, __webpack_require__(212), __webpack_require__(210).setImmediate, function() {
        return this;
    }());
}, function(module, exports) {
    (function(global) {
        module.exports = deprecate;
        function deprecate(fn, msg) {
            if (config("noDeprecation")) return fn;
            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (config("throwDeprecation")) throw new Error(msg); else if (config("traceDeprecation")) console.trace(msg); else console.warn(msg);
                    warned = true;
                }
                return fn.apply(this, arguments);
            }
            return deprecated;
        }
        function config(name) {
            try {
                if (!global.localStorage) return false;
            } catch (_) {
                return false;
            }
            var val = global.localStorage[name];
            if (null == val) return false;
            return "true" === String(val).toLowerCase();
        }
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Buffer = __webpack_require__(240).Buffer;
    var isEncoding = Buffer.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;

          default:
            return false;
        }
    };
    function _normalizeEncoding(enc) {
        if (!enc) return "utf8";
        var retried;
        while (true) switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";

          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";

          case "latin1":
          case "binary":
            return "latin1";

          case "base64":
          case "ascii":
          case "hex":
            return enc;

          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
    }
    function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if ("string" !== typeof nenc && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;

          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;

          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;

          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
        if (0 === buf.length) return "";
        var r;
        var i;
        if (this.lastNeed) {
            r = this.fillLast(buf);
            if (void 0 === r) return "";
            i = this.lastNeed;
            this.lastNeed = 0;
        } else i = 0;
        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
        if (byte <= 127) return 0; else if (byte >> 5 === 6) return 2; else if (byte >> 4 === 14) return 3; else if (byte >> 3 === 30) return 4;
        return -1;
    }
    function utf8CheckIncomplete(self, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 1;
            return nb;
        }
        if (--j < i) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
            if (nb > 0) self.lastNeed = nb - 2;
            return nb;
        }
        if (--j < i) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
            if (nb > 0) if (2 === nb) nb = 0; else self.lastNeed = nb - 3;
            return nb;
        }
        return 0;
    }
    function utf8CheckExtraBytes(self, buf, p) {
        if (128 !== (192 & buf[0])) {
            self.lastNeed = 0;
            return "�".repeat(p);
        }
        if (self.lastNeed > 1 && buf.length > 1) {
            if (128 !== (192 & buf[1])) {
                self.lastNeed = 1;
                return "�".repeat(p + 1);
            }
            if (self.lastNeed > 2 && buf.length > 2) if (128 !== (192 & buf[2])) {
                self.lastNeed = 2;
                return "�".repeat(p + 2);
            }
        }
    }
    function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (void 0 !== r) return r;
        if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + "�".repeat(this.lastTotal - this.lastNeed);
        return r;
    }
    function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
                var c = r.charCodeAt(r.length - 1);
                if (c >= 55296 && c <= 56319) {
                    this.lastNeed = 2;
                    this.lastTotal = 4;
                    this.lastChar[0] = buf[buf.length - 2];
                    this.lastChar[1] = buf[buf.length - 1];
                    return r.slice(0, -1);
                }
            }
            return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
    }
    function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (0 === n) return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (1 === n) this.lastChar[0] = buf[buf.length - 1]; else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
    }
    function simpleWrite(buf) {
        return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = Transform;
    var Duplex = __webpack_require__(245);
    var util = __webpack_require__(241);
    util.inherits = __webpack_require__(235);
    util.inherits(Transform, Duplex);
    function TransformState(stream) {
        this.afterTransform = function(er, data) {
            return afterTransform(stream, er, data);
        };
        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
        this.writeencoding = null;
    }
    function afterTransform(stream, er, data) {
        var ts = stream._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb) return stream.emit("error", new Error("write callback called multiple times"));
        ts.writechunk = null;
        ts.writecb = null;
        if (null !== data && void 0 !== data) stream.push(data);
        cb(er);
        var rs = stream._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) stream._read(rs.highWaterMark);
    }
    function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = new TransformState(this);
        var stream = this;
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
            if ("function" === typeof options.transform) this._transform = options.transform;
            if ("function" === typeof options.flush) this._flush = options.flush;
        }
        this.once("prefinish", function() {
            if ("function" === typeof this._flush) this._flush(function(er, data) {
                done(stream, er, data);
            }); else done(stream);
        });
    }
    Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
    };
    Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (null !== ts.writechunk && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else ts.needTransform = true;
    };
    Transform.prototype._destroy = function(err, cb) {
        var _this = this;
        Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
            _this.emit("close");
        });
    };
    function done(stream, er, data) {
        if (er) return stream.emit("error", er);
        if (null !== data && void 0 !== data) stream.push(data);
        var ws = stream._writableState;
        var ts = stream._transformState;
        if (ws.length) throw new Error("Calling transform done when ws.length != 0");
        if (ts.transforming) throw new Error("Calling transform done when still transforming");
        return stream.push(null);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = PassThrough;
    var Transform = __webpack_require__(249);
    var util = __webpack_require__(241);
    util.inherits = __webpack_require__(235);
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
    };
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(246);
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(245);
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(236).Transform;
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(236).PassThrough;
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(229).Buffer;
    var isBufferEncoding = Buffer.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;

          default:
            return false;
        }
    };
    function assertEncoding(encoding) {
        if (encoding && !isBufferEncoding(encoding)) throw new Error("Unknown encoding: " + encoding);
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
        this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
        assertEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.surrogateSize = 3;
            break;

          case "ucs2":
          case "utf16le":
            this.surrogateSize = 2;
            this.detectIncompleteChar = utf16DetectIncompleteChar;
            break;

          case "base64":
            this.surrogateSize = 3;
            this.detectIncompleteChar = base64DetectIncompleteChar;
            break;

          default:
            this.write = passThroughWrite;
            return;
        }
        this.charBuffer = new Buffer(6);
        this.charReceived = 0;
        this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
            var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
            buffer.copy(this.charBuffer, this.charReceived, 0, available);
            this.charReceived += available;
            if (this.charReceived < this.charLength) return "";
            buffer = buffer.slice(available, buffer.length);
            charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
            var charCode = charStr.charCodeAt(charStr.length - 1);
            if (charCode >= 55296 && charCode <= 56319) {
                this.charLength += this.surrogateSize;
                charStr = "";
                continue;
            }
            this.charReceived = this.charLength = 0;
            if (0 === buffer.length) return charStr;
            break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
            buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
            end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
            var size = this.surrogateSize;
            this.charLength += size;
            this.charReceived += size;
            this.charBuffer.copy(this.charBuffer, size, 0, size);
            buffer.copy(this.charBuffer, 0, 0, size);
            return charStr.substring(0, end);
        }
        return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (;i > 0; i--) {
            var c = buffer[buffer.length - i];
            if (1 == i && c >> 5 == 6) {
                this.charLength = 2;
                break;
            }
            if (i <= 2 && c >> 4 == 14) {
                this.charLength = 3;
                break;
            }
            if (i <= 3 && c >> 3 == 30) {
                this.charLength = 4;
                break;
            }
        }
        this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length) res = this.write(buffer);
        if (this.charReceived) {
            var cr = this.charReceived;
            var buf = this.charBuffer;
            var enc = this.encoding;
            res += buf.slice(0, cr).toString(enc);
        }
        return res;
    };
    function passThroughWrite(buffer) {
        return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 2;
        this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
        this.charReceived = buffer.length % 3;
        this.charLength = this.charReceived ? 3 : 0;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var LoaderItem = __webpack_require__(257);
    var ResourceLoader = module.exports = function(options) {
        this._options = options;
        this._items = [];
    };
    ResourceLoader.prototype.load = function(options) {
        var loaderItem = this._getItem(options.id);
        if (!loaderItem) loaderItem = this._createItem(options.id);
        loaderItem.addCallback(options.callback);
        loaderItem.loadAttempt(options.loadMethod);
    };
    ResourceLoader.prototype.clearExpired = function() {
        this._items = this._items.filter(function(item) {
            return !item.isExpired();
        });
    };
    ResourceLoader.prototype.getCache = function(id, argumentIndex) {
        var loaderItem = this._getItem(id);
        if (!loaderItem) return null;
        var data = loaderItem.getData();
        if (data && void 0 !== argumentIndex) return data[argumentIndex];
        return data;
    };
    ResourceLoader.prototype.hasCache = function(id) {
        var loaderItem = this._getItem(id);
        return loaderItem ? Boolean(loaderItem.getData()) : false;
    };
    ResourceLoader.prototype._getItem = function(id) {
        for (var i = 0; i < this._items.length; i++) if (this._items[i].id === id) return this._items[i];
        return null;
    };
    ResourceLoader.prototype._createItem = function(id) {
        var item = new LoaderItem(id, this._options);
        this._items.push(item);
        return item;
    };
}, function(module, exports) {
    "use strict";
    var DEFAULT_SUCCESS_LIFETIME_MS = 24 * 60 * 60 * 1e3;
    var DEFAULT_ERROR_LIFETIME_MS = 0;
    var LoaderItem = module.exports = function(id, options) {
        options = options || {};
        this.id = id;
        this._pending = false;
        this._data = null;
        this._callbacks = [];
        this._lastCallTimestamp = 0;
        this._successLifetimeMs = options.successLifetimeMs || DEFAULT_SUCCESS_LIFETIME_MS;
        this._errorLifetimeMs = options.errorLifetimeMs || DEFAULT_ERROR_LIFETIME_MS;
    };
    LoaderItem.prototype.loadAttempt = function(loadMethod) {
        if (this.getData()) this._applyCallbacks(); else if (!this._pending) {
            this._pending = true;
            loadMethod(this._finish.bind(this));
        }
    };
    LoaderItem.prototype.addCallback = function(callback) {
        if ("function" === typeof callback) this._callbacks.push(callback); else throw new TypeError("Сallback is not a function");
    };
    LoaderItem.prototype.getData = function() {
        return this._hasData() && !this.isExpired() ? this._data : null;
    };
    LoaderItem.prototype.isExpired = function() {
        var now = Date.now();
        if (now < this._lastCallTimestamp) return true; else {
            var lifeTime = this._isSuccessData() ? this._successLifetimeMs : this._errorLifetimeMs;
            return now > this._lastCallTimestamp + lifeTime;
        }
    };
    LoaderItem.prototype._finish = function() {
        this._pending = false;
        this._lastCallTimestamp = Date.now();
        this._data = [].slice.call(arguments);
        this._applyCallbacks();
    };
    LoaderItem.prototype._applyCallbacks = function() {
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
            var callback = this._callbacks.pop();
            callback.apply(null, this._data);
        }
    };
    LoaderItem.prototype._isSuccessData = function() {
        return this._data && !this._data[0];
    };
    LoaderItem.prototype._hasData = function() {
        return Array.isArray(this._data);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var urlUtils = __webpack_require__(83);
    var FAVICON_SERVICE_URL = "https://favicon.yandex.net/favicon/";
    exports.getUrl = function(siteUrl) {
        return FAVICON_SERVICE_URL + urlUtils.getNormalDomain(siteUrl);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var loadImage = __webpack_require__(260);
    var FONT_COLOR_THRESHOLD = 170;
    var COLOR_BLACK = 0;
    var COLOR_WHITE = 1;
    var CANVAS_SIZE_THRESHOLD = 800;
    var MAX_THRESHOLD = 238;
    var MIN_THRESHOLD = 20;
    var PASTEL_THRESHOLD = 92;
    var OPACITY_TRESHOLD = 230;
    var WHITE_TRESHOLD = 253;
    var BLACK_TRESHOLD = 10;
    exports.DEFAULT_BGCOLOR = "e5e5e5";
    exports.OVERLAY_COLOR_WHITE = "ffffff";
    exports.OVERLAY_COLOR_BLACK = "000000";
    function toRGB(num) {
        return (num < 16 ? "0" : "") + num.toString(16);
    }
    function isAcidColor(red, green, blue) {
        var sum = red + green + blue;
        if (sum >= 2 * MAX_THRESHOLD && (red <= MIN_THRESHOLD || green <= MIN_THRESHOLD || blue <= MIN_THRESHOLD)) return true;
        if (sum <= MAX_THRESHOLD + 2 * MIN_THRESHOLD && (red >= MAX_THRESHOLD || green >= MAX_THRESHOLD || blue >= MAX_THRESHOLD)) return true;
        return false;
    }
    function isAlmostTransparent(opacity) {
        return opacity < OPACITY_TRESHOLD;
    }
    function isAlmostWhite(rgb) {
        return rgb[0] > WHITE_TRESHOLD && rgb[1] > WHITE_TRESHOLD && rgb[2] > WHITE_TRESHOLD;
    }
    function isAlmostBlack(rgb) {
        return rgb[0] < BLACK_TRESHOLD && rgb[1] < BLACK_TRESHOLD && rgb[2] < BLACK_TRESHOLD;
    }
    function isLightGrey(rgb) {
        var meanValue = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return Math.abs(meanValue - rgb[0]) + Math.abs(meanValue - rgb[1]) + Math.abs(meanValue - rgb[2]) < 15;
    }
    exports.calculateFontColorForImage = function(img) {
        var color = exports.getDominant(img, {
            bottomQuarter: true,
            rightHalf: false,
            minifyCanvas: true,
            preventSkipColors: true
        });
        var fontColorNum = exports.getFontColorByBackgroundColor(color);
        var fontColor = 1 === fontColorNum ? exports.OVERLAY_COLOR_WHITE : exports.OVERLAY_COLOR_BLACK;
        return fontColor;
    };
    exports.getFontOverlayColorForBackgroundColor = function(bgColor) {
        var fontColorNum = exports.getFontColorByBackgroundColor(bgColor);
        return fontColorNum === COLOR_WHITE ? exports.OVERLAY_COLOR_WHITE : exports.OVERLAY_COLOR_BLACK;
    };
    function getRGBValues(colorString) {
        return {
            red: parseInt(colorString.substr(0, 2), 16),
            green: parseInt(colorString.substr(2, 2), 16),
            blue: parseInt(colorString.substr(4, 2), 16)
        };
    }
    var COLOR_NAMES = __webpack_require__(261);
    exports.normalize = function(str) {
        if (!str) return null;
        str = String(str).trim().toLowerCase();
        return str in COLOR_NAMES ? COLOR_NAMES[str] : normalizeHexValue(str);
    };
    var HEX_COLOR_RX = /^#?([\da-f]{3}(?:[\da-f]{3})?)/;
    function normalizeHexValue(val) {
        if (!HEX_COLOR_RX.test(val)) return null;
        val = HEX_COLOR_RX.exec(val)[1];
        return 3 === val.length ? color3to6(val) : val;
    }
    function color3to6(str) {
        return str[0] + str[0] + str[1] + str[1] + str[2] + str[2];
    }
    exports.calculateDominantColorByUrl = function(imageUrl, options, callback) {
        loadImage({
            url: imageUrl
        }, function(err, img) {
            var color = err ? null : exports.getDominant(img, options);
            callback(color);
        });
    };
    exports.calculateFontColorByUrl = function(imageUrl, callback) {
        loadImage({
            url: imageUrl
        }, function(err, img) {
            if (err) return callback(null);
            var color = exports.calculateFontColorForImage(img);
            callback(color);
        });
    };
    exports.getFontColorByBackgroundColor = function(bgColor) {
        bgColor = bgColor || exports.DEFAULT_BGCOLOR;
        var rgb = getRGBValues(bgColor);
        var tone = (rgb.red + rgb.green + rgb.blue) / 3;
        if (tone < FONT_COLOR_THRESHOLD && (rgb.red < FONT_COLOR_THRESHOLD || rgb.green < FONT_COLOR_THRESHOLD)) return COLOR_WHITE; else return COLOR_BLACK;
    };
    exports.getDominant = function(img, options) {
        options = options || {};
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        var canvasWidth = img.width;
        var canvasHeight = img.height;
        if (img.width > img.height) {
            if (options.minifyCanvas && img.width > CANVAS_SIZE_THRESHOLD) {
                canvasWidth = CANVAS_SIZE_THRESHOLD;
                canvasHeight = Math.round(canvasWidth * img.height / img.width);
            }
        } else if (options.minifyCanvas && img.height > CANVAS_SIZE_THRESHOLD) {
            canvasHeight = CANVAS_SIZE_THRESHOLD;
            canvasWidth = Math.round(canvasHeight * img.width / img.height);
        }
        canvas.setAttribute("width", canvasWidth);
        canvas.setAttribute("height", canvasHeight);
        ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
        var imgPixels;
        try {
            imgPixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
        } catch (e) {
            return "";
        }
        var maxValueKey = null;
        var colorsContainer = {};
        var pixelColorData = new Array(4);
        var startY = options.bottomQuarter ? Math.round(.75 * imgPixels.height) : 0;
        var startX = options.rightHalf ? Math.round(imgPixels.width / 2) : 0;
        for (var y = startY; y < imgPixels.height; y++) for (var x = startX; x < imgPixels.width; x++) {
            var index = 4 * y * imgPixels.width + 4 * x;
            if (isAlmostTransparent(imgPixels.data[index + 3])) continue;
            pixelColorData[0] = imgPixels.data[index];
            pixelColorData[1] = imgPixels.data[index + 1];
            pixelColorData[2] = imgPixels.data[index + 2];
            pixelColorData[3] = imgPixels.data[index + 3];
            if (255 !== pixelColorData[3]) for (var z = 0; z < 3; z++) {
                var colorStep = (255 - pixelColorData[z]) / 255;
                pixelColorData[z] = Math.round(255 - colorStep * pixelColorData[3]);
            }
            if (!options.preventSkipColors && (isAlmostWhite(pixelColorData) || isAlmostBlack(pixelColorData) || isLightGrey(pixelColorData))) continue;
            var color = toRGB(pixelColorData[0]) + toRGB(pixelColorData[1]) + toRGB(pixelColorData[2]);
            colorsContainer[color] = colorsContainer[color] || 0;
            colorsContainer[color] += 1;
            if (null === maxValueKey || colorsContainer[maxValueKey] < colorsContainer[color]) maxValueKey = color;
        }
        if (maxValueKey) {
            var rgb = getRGBValues(maxValueKey);
            if (isAcidColor(rgb.red, rgb.green, rgb.blue)) {
                rgb.red = Math.max(rgb.red, PASTEL_THRESHOLD);
                rgb.green = Math.max(rgb.green, PASTEL_THRESHOLD);
                rgb.blue = Math.max(rgb.blue, PASTEL_THRESHOLD);
                maxValueKey = toRGB(rgb.red) + toRGB(rgb.green) + toRGB(rgb.blue);
            }
        }
        return maxValueKey || exports.DEFAULT_BGCOLOR;
    };
    function getIndexByXY(x, y, imgPixels) {
        return 4 * (imgPixels.width * y + x);
    }
    exports.isBlack = function(imgPixels) {
        var halfX = Math.floor(imgPixels.width / 2);
        var halfY = Math.floor(imgPixels.height / 2);
        var listToCheck = [];
        for (var x = 0; x < imgPixels.width - 1; x++) listToCheck.push(getIndexByXY(x, halfY, imgPixels));
        for (var y = 0; y < imgPixels.height - 1; y++) listToCheck.push(getIndexByXY(halfX, y, imgPixels));
        listToCheck.push(getIndexByXY(0, 0, imgPixels));
        listToCheck.push(getIndexByXY(imgPixels.width - 1, 0, imgPixels));
        listToCheck.push(getIndexByXY(0, imgPixels.height - 1, imgPixels));
        listToCheck.push(getIndexByXY(imgPixels.width - 1, imgPixels.height - 1, imgPixels));
        return listToCheck.every(function(index) {
            var red = imgPixels.data[index];
            var green = imgPixels.data[index + 1];
            var blue = imgPixels.data[index + 2];
            var opacity = imgPixels.data[index + 3];
            return 0 === red && 0 === green && 0 === blue && (255 === opacity || 0 === opacity);
        });
    };
    __webpack_require__(262).override(exports);
}, function(module, exports) {
    "use strict";
    module.exports = function(options, callback) {
        var img = new window.Image();
        img.onload = onLoad.bind(null, img, callback);
        img.onerror = onError.bind(null, img, callback);
        img.src = options.url;
        return img;
    };
    function onLoad(img, callback) {
        setTimeout(function() {
            callback(null, img);
        }, 0);
    }
    function onError(img, callback) {
        callback(new Error("Image load error: " + img.src), img);
    }
}, function(module, exports) {
    "use strict";
    module.exports = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "778899",
        lightslategrey: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var events = __webpack_require__(69);
    var offscreenManager = __webpack_require__(70);
    exports.override = function(colors) {
        if ("object" !== ("undefined" === typeof colors ? "undefined" : _typeof(colors))) return;
        colors.calculateDominantColorByUrlOriginal = colors.calculateDominantColorByUrl.bind({});
        colors.calculateFontColorByUrlOriginal = colors.calculateFontColorByUrl.bind({});
        colors.calculateDominantColorByUrl = function(imgUrl, options, successCallback) {
            var callback = function(message) {
                var errObj = message.errObj, color = message.color;
                if (errObj) throw new Error(errObj.message); else return successCallback(color);
            };
            var msgBody = {
                type: events.backend.COLORS_DOMINANT_COLOR_BY_URL,
                data: {
                    imgUrl: imgUrl,
                    options: options
                }
            };
            return offscreenManager.sendMessage(msgBody, "Colors calculateDominantColorByUrl timed out", callback);
        };
        colors.calculateFontColorByUrl = function(imgUrl, successCallback) {
            var callback = function(message) {
                var errObj = message.errObj, color = message.color;
                if (errObj) throw new Error(errObj.message); else return successCallback(color);
            };
            var msgBody = {
                type: events.backend.COLORS_FONT_COLOR_BY_URL,
                data: {
                    imgUrl: imgUrl
                }
            };
            return offscreenManager.sendMessage(msgBody, "Colors calculateFontColorByUrl timed out", callback);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var fs = __webpack_require__(264);
    var fileUtils = __webpack_require__(266);
    var urlUtils = __webpack_require__(83);
    var asyncLib = __webpack_require__(209);
    function FileStorage(directory) {
        if (!directory) throw new Error("Directory must be specified");
        this.directory = fileUtils.wrapSeparator(directory);
    }
    FileStorage.prototype.getAll = function(callback) {
        asyncLib.waterfall([ this._getFileList.bind(this), this._getLocalUrls.bind(this), this._createFilesMap.bind(this) ], callback);
    };
    FileStorage.prototype.download = function(url, name, callback) {
        var filePath = this.getFilePath(name || url);
        fs.download(url, filePath, function(error) {
            if (error) callback(error); else this._getFileUrl(filePath, callback);
        }.bind(this));
    };
    FileStorage.prototype.getLocalUrl = function(fileName, callback) {
        var filePath = this.getFilePath(fileName);
        this._getFileUrl(filePath, callback);
    };
    FileStorage.prototype.remove = function(fileName, callback) {
        var filePath = this.getFilePath(fileName);
        fs.remove(filePath, callback);
    };
    FileStorage.prototype.copy = function(srcPath, newName, callback) {
        var newFilePath = this.getFilePath(newName);
        fs.copy(srcPath, newFilePath, function(error) {
            if (error) callback(error); else this._getFileUrl(newFilePath, callback);
        }.bind(this));
    };
    FileStorage.prototype.saveDataURI = function(dataURI, fileName, callback) {
        var newFilePath = this.getFilePath(fileName);
        fs.saveDataURI(dataURI, newFilePath, function(error) {
            if (error) callback(error); else this._getFileUrl(newFilePath, callback);
        }.bind(this));
    };
    FileStorage.prototype.saveAnyUrl = function(url, fileName, callback) {
        return urlUtils.isDataUri(url) ? this.saveDataURI(url, fileName, callback) : this.download(url, fileName, callback);
    };
    FileStorage.prototype.move = function(oldPath, newPath, callback) {
        fs.copy(oldPath, newPath, function(error) {
            if (error) callback(error); else this.remove(oldPath, callback);
        }.bind(this));
    };
    FileStorage.prototype._getFileUrl = function(filePath, callback) {
        fs.getFileUrl(filePath, function(error, fileURL) {
            callback(error, {
                url: fileURL,
                path: filePath
            });
        });
    };
    FileStorage.prototype.getFilePath = function(fileName) {
        return this.directory + fileName;
    };
    FileStorage.prototype._getFileList = function(callback) {
        fs.list(this.directory, callback);
    };
    FileStorage.prototype._getLocalUrls = function(list, callback) {
        asyncLib.parallel(list.map(function(filePath) {
            return function(next) {
                fs.getFileUrl(filePath, next);
            };
        }), callback);
    };
    FileStorage.prototype._createFilesMap = function(list, callback) {
        var result = list.reduce(function(res, filePath) {
            var fileName = fileUtils.extractName(filePath);
            res[fileName] = filePath;
            return res;
        }, {});
        callback(null, result);
    };
    module.exports = FileStorage;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Filer = __webpack_require__(265);
    var fileUtils = __webpack_require__(266);
    var _readAsText = __webpack_require__(267).readAsText;
    var filer = new Filer();
    var NOT_FOUND_ERR_NAME = "NotFoundError";
    var fileStorage = {
        init: function(callback) {
            return filer.init({
                persistent: true,
                size: 0
            }, function() {
                callback();
            }, function(err) {
                callback(err);
            });
        },
        get isInitialized() {
            return Boolean(filer);
        },
        download: function() {
            throw new Error("platform.fileStorage.download should be overwritten by file-downloader");
        },
        saveDataURI: function(dataURI, fileName, callback) {
            var objectUrl = window.URL.createObjectURL(dataUrlToBlob(dataURI));
            this.download(objectUrl, fileName, function(error) {
                window.URL.revokeObjectURL(objectUrl);
                callback(error);
            });
        },
        remove: function(fileName, callback) {
            filer.rm(fileName, callback.bind(null, null), callback);
        },
        list: function(path, callback) {
            filer.ls(path, function(entries) {
                callback(null, entries.map(function(entry) {
                    return entry.fullPath;
                }));
            }, this._onListError.bind(this, callback));
        },
        _onListError: function(callback, error) {
            if (error.name === NOT_FOUND_ERR_NAME) callback(null, []); else callback(error);
        },
        write: function(fileName, data, callback) {
            filer.write(fileName, data, function(fileEntry, fileWriter) {
                callback(null, fileEntry, fileWriter);
            }, callback);
        },
        readAsText: function(fileName, callback) {
            filer.open(fileName, function(file) {
                _readAsText(file).then(function(result) {
                    return callback(null, result);
                }).catch(function(error) {
                    return callback(error);
                });
            }, callback);
        },
        move: function(srcFile, destDir, destFileName, callback) {
            filer.mv(srcFile, destDir, destFileName, function(fileEntry) {
                callback(null, fileEntry);
            }, callback);
        },
        copy: function(srcFile, destFile, callback) {
            this.createDirectory(destFile, function() {
                var dirPath = fileUtils.extractDirectoryName(destFile) || ".";
                var fileName = fileUtils.extractName(destFile);
                filer.cp(srcFile, dirPath, fileName, callback.bind(null, null), callback);
            }.bind(this), callback);
        },
        getFileUrl: function(fileName, callback) {
            return filer.getEntry(fileName, function(entry) {
                callback(null, entry);
            }, callback);
        },
        createDirectory: function(fileName, callback, errback) {
            var dirName = fileUtils.extractDirectoryName(fileName);
            if (dirName) filer.mkdir(dirName, false, callback, errback); else callback();
        }
    };
    function dataUrlToBlob(dataUrl) {
        var byteString;
        if (dataUrl.split(",")[0].indexOf("base64") >= 0) byteString = window.atob(dataUrl.split(",")[1]); else byteString = window.unescape(dataUrl.split(",")[1]);
        var mimeString = dataUrl.split(",")[0].split(":")[1].split(";")[0];
        var ia = new Uint8Array(byteString.length);
        for (var i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
        return new window.Blob([ ia ], {
            type: mimeString
        });
    }
    module.exports = fileStorage;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var events = __webpack_require__(69);
    var offscreenManager = __webpack_require__(70);
    var Filer = function() {
        function Filer() {
            _classCallCheck(this, Filer);
        }
        _createClass(Filer, [ {
            key: "pathToFilesystemURL",
            value: function(path) {
                return chrome.runtime.getURL(path);
            }
        }, {
            key: "init",
            value: function(opt_initObj, opt_successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else opt_successCallback && opt_successCallback();
                };
                var msgBody = {
                    type: events.backend.FILER_INIT,
                    data: {
                        opt_initObj: opt_initObj
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer init timed out", callback, opt_errorHandler);
            }
        }, {
            key: "ls",
            value: function(dirEntryOrPath, successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else successCallback(message.entries);
                };
                var msgBody = {
                    type: events.backend.FILER_LS,
                    data: {
                        dirEntryOrPath: dirEntryOrPath
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer ls timed out", callback, opt_errorHandler);
            }
        }, {
            key: "mkdir",
            value: function(path, opt_exclusive, opt_successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj, entry = message.entry;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else opt_successCallback && opt_successCallback(entry);
                };
                var msgBody = {
                    type: events.backend.FILER_MKDIR,
                    data: {
                        path: path,
                        opt_exclusive: opt_exclusive
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer mkdir timed out", callback, opt_errorHandler);
            }
        }, {
            key: "open",
            value: function(entryOrPath, successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj, file = message.file;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else successCallback(file);
                };
                var msgBody = {
                    type: events.backend.FILER_OPEN,
                    data: {
                        entryOrPath: entryOrPath
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer open timed out", callback, opt_errorHandler);
            }
        }, {
            key: "create",
            value: function(path, opt_exclusive, successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else successCallback();
                };
                var msgBody = {
                    type: events.backend.FILER_CREATE,
                    data: {
                        path: path,
                        opt_exclusive: opt_exclusive
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer create timed out", callback, opt_errorHandler);
            }
        }, {
            key: "mv",
            value: function(src, dest, opt_newName, opt_successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj, entry = message.entry;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else opt_successCallback && opt_successCallback(entry);
                };
                var msgBody = {
                    type: events.backend.FILER_MV,
                    data: {
                        src: src,
                        dest: dest,
                        opt_newName: opt_newName
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer mv timed out", callback, opt_errorHandler);
            }
        }, {
            key: "rm",
            value: function(entryOrPath, successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else successCallback();
                };
                var msgBody = {
                    type: events.backend.FILER_RM,
                    data: {
                        entryOrPath: entryOrPath
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer rm timed out", callback, opt_errorHandler);
            }
        }, {
            key: "cd",
            value: function(dirEntryOrPath, opt_successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj, entry = message.entry;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else opt_successCallback && opt_successCallback(entry);
                };
                var msgBody = {
                    type: events.backend.FILER_CD,
                    data: {
                        dirEntryOrPath: dirEntryOrPath
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer cd timed out", callback, opt_errorHandler);
            }
        }, {
            key: "cp",
            value: function(src, dest, opt_newName, opt_successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj, entry = message.entry;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else opt_successCallback && opt_successCallback(entry);
                };
                var msgBody = {
                    type: events.backend.FILER_CP,
                    data: {
                        src: src,
                        dest: dest,
                        opt_newName: opt_newName
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer cp timed out", callback, opt_errorHandler);
            }
        }, {
            key: "write",
            value: function(entryOrPath, writeData, opt_successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj, entry = message.entry;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else opt_successCallback && opt_successCallback(entry);
                };
                var msgBody = {
                    type: events.backend.FILER_WRITE,
                    data: {
                        entryOrPath: entryOrPath,
                        writeData: writeData
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer write timed out", callback, opt_errorHandler);
            }
        }, {
            key: "df",
            value: function() {}
        }, {
            key: "getEntry",
            value: function(fileName, opt_successCallback, opt_errorHandler) {
                var callback = function(message) {
                    var errObj = message.errObj, entry = message.entry;
                    if (errObj) {
                        var err = new Error(errObj.message);
                        opt_errorHandler && opt_errorHandler(err);
                    } else opt_successCallback && opt_successCallback(entry);
                };
                var msgBody = {
                    type: events.backend.FILER_GET_ENTRY,
                    data: {
                        fileName: fileName
                    }
                };
                return offscreenManager.sendMessage(msgBody, "Filer getEntry timed out", callback, opt_errorHandler);
            }
        } ]);
        return Filer;
    }();
    module.exports = Filer;
}, function(module, exports) {
    "use strict";
    var FIRST_SLASH_REG = /^\//;
    var SLASH_BACKSLASH_REG = /\\+|\/+/g;
    var fileUtils = {
        extractName: function(filePath) {
            var slashIndex = filePath.lastIndexOf("/");
            return filePath.slice(slashIndex + 1);
        },
        extractExtension: function(filePath) {
            var dotIndex = (filePath || "").lastIndexOf(".");
            return dotIndex >= 0 ? filePath.slice(dotIndex + 1) : "";
        },
        extractDirectoryName: function(filePath) {
            var slashIndex = filePath.lastIndexOf("/");
            if (slashIndex > 0) return filePath.slice(0, slashIndex);
            return null;
        },
        wrapSeparator: function(path) {
            if ("string" !== typeof path) throw new Error("Invalid path");
            if ("" === path) return "/";
            return "/" + path.replace(/^\/+|\/+$/g, "") + "/";
        },
        normalizePath: function(path) {
            if (path) return path.replace(SLASH_BACKSLASH_REG, "/").replace(FIRST_SLASH_REG, ""); else return "";
        }
    };
    module.exports = fileUtils;
}, function(module, exports) {
    "use strict";
    var blobUtils = {
        readAsJson: function(file) {
            return blobUtils.readAsText(file).then(JSON.parse);
        },
        readAsText: readAsFactory("readAsText"),
        readAsArrayBuffer: readAsFactory("readAsArrayBuffer"),
        readAsBinaryString: readAsFactory("readAsBinaryString"),
        readAsDataURL: readAsFactory("readAsDataURL")
    };
    function readAsFactory(as) {
        return function(file) {
            return new Promise(function(resolve, reject) {
                var reader = new FileReader();
                reader.addEventListener("load", function() {
                    return resolve(reader.result);
                });
                reader.addEventListener("error", reject);
                reader.addEventListener("abort", reject);
                reader[as](file);
            });
        };
    }
    module.exports = blobUtils;
}, function(module, exports) {
    "use strict";
    module.exports = {
        frontend: {
            INIT: "init",
            LOG_FRONTEND_DATA: "logFrontendData",
            ADV_REFUSE: "Advertisement.refuse",
            ADV_ACCEPT: "Advertisement.accept",
            REQUEST_APPS_LIST: "requestAppsList",
            AUTH_LOGIN: "Auth.login",
            AUTH_LOGOUT: "Auth.logout",
            AUTH_NAVIGATE: "Auth.navigate",
            SET_BACKGROUND_IMAGE: "setBackgroundImage",
            UPLOAD_USER_BACKGROUND: "uploadUserBackground",
            REQUEST_BOOKMARKS_BRANCH: "requestBookmarksBranch",
            DEBUG_COMMAND: "debugCommand",
            DEBUG_SHOW: "debugShow",
            ADD_THUMB: "addThumbClick",
            PIN_THUMB: "pinThumb",
            UNPIN_THUMB: "unpinThumb",
            REQUEST_LAST_VISITED: "requestLastVisited",
            REQUEST_POPULAR_SITES: "requestPopularSites",
            REQUEST_THUMB_DATA: "requestThumbData",
            SAVE_THUMB: "saveThumb",
            REMOVE_THUMB: "removeThumb",
            SWAP_THUMB: "swapThumbs",
            APPLY_SETTING: "applySetting",
            REQUEST_SETTINGS: "requestSettings",
            MAKE_BACKUP: "makeBackup",
            LOAD_BACKUP: "loadBackup",
            RESTORE_TAB: "restoreTab",
            REQUEST_CLOSED_PAGES_LIST: "requestClosedPagesList",
            SEND_FRONTEND_STAT: "sendFrontendStat",
            SET_SCROLL_STATE: "setScrollState",
            SEARCH_MAIN: "searchMain",
            SEARCH_WEB: "searchWeb",
            SEARCH_HISTORY: "searchHistory",
            SEARCH_BOOKMARKS: "searchBookmarks",
            SEARCH_OPENED_TABS: "searchOpenedTabs",
            NAVIGATE_URL: "navigateURL",
            OPEN_EXTERNAL_WINDOW: "openExternalWindow",
            DRAW_FINISHED: "system.drawFinished",
            VOICE_INIT: "voice.init",
            VOICE_STOP: "voice.stop",
            PAGE_VBNAVIGATE: "vb-navigate"
        },
        backend: {
            INIT: "init",
            BOOKMARKS_CHANGED: "bookmarksStateChanged",
            BACKGROUND_CHANGED: "backgroundChanged",
            DEBUG_PANEL: "debug",
            AUTH: "auth",
            INFORMERS: "informers",
            CLOSED_TABS_LIST_CHANGED: "closedTabsListChanged",
            ACTION: "action",
            POST: "post",
            CLOSE_POPUPS: "closePopups",
            ADVERTISEMENT: "advertisement",
            ADVERTISEMENT_ATOM: "advertisement.atom",
            SETTING_CHANGE: "settingChanged",
            OPEN_SETTINGS: "openSettings",
            CLOSE_SETTINGS: "closeSettings",
            START_PAGE_CHANGED: "startPageChanged",
            HISTORY_THUMB_CHANGED: "historyThumbChanged",
            THUMB_CHANGED: "thumbChanged",
            EDIT_THUMB: "editThumb",
            REMOVE_THUMB: "removeThumb",
            VOICE_START: "voice.start",
            VOICE_PROGRESS: "voice.progress",
            VOICE_FINISH: "voice.finish",
            VOICE_ERROR: "voice.error",
            VOICE_CLOSE: "voice.close",
            ZEN_CONFIG: "zen.config"
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var collection = __webpack_require__(270);
    var settings = __webpack_require__(216);
    var colorUtils = __webpack_require__(259);
    var urlUtils = __webpack_require__(83);
    var events = __webpack_require__(268);
    module.exports = {
        sendAll: function() {
            var positions = Object.keys(collection.items);
            messaging.send(events.backend.THUMB_CHANGED, getDataByPositions(positions));
        },
        sendThumbData: function(thumb, tabId) {
            messaging.send(events.backend.HISTORY_THUMB_CHANGED, formatThumbForFrontend(thumb), tabId);
        },
        getAll: function() {
            return getDataByPositions(Object.keys(collection.items));
        },
        formatThumbForFrontend: formatThumbForFrontend
    };
    function getDataByPositions(positions) {
        return (positions || []).reduce(function(data, position) {
            var thumb = collection.getItem(position);
            data[position] = formatThumbForFrontend(thumb);
            return data;
        }, {});
    }
    function formatThumbForFrontend(item) {
        if (!item) return null;
        var frontendThumb = {
            pinned: Boolean(item.pinned),
            url: urlUtils.getReadableUrl(item.url),
            isIndexPage: urlUtils.isIndexPage(item.url),
            title: item.title
        };
        frontendThumb.favicon = item.faviconUrl;
        frontendThumb.backgroundColor = item.faviconColor;
        if (item.cloudImage) {
            frontendThumb.backgroundImage = frontendThumb.isIndexPage ? item.cloudImage : item.cloudImageSub || item.cloudImage;
            frontendThumb.backgroundColor = item.cloudColor;
        }
        if (item.tableauImage) {
            frontendThumb.backgroundImage = item.tableauImage;
            frontendThumb.backgroundColor = item.tableauColor;
        }
        if (!frontendThumb.backgroundColor || frontendThumb.backgroundColor.length < 6) frontendThumb.backgroundColor = colorUtils.DEFAULT_BGCOLOR;
        frontendThumb.fontColor = colorUtils.getFontColorByBackgroundColor(frontendThumb.backgroundColor);
        if (item.screenshotImage) {
            var uiThumbsType = settings.get("uiThumbsType");
            if (2 === uiThumbsType && !frontendThumb.backgroundImage || 3 === uiThumbsType) frontendThumb.screenshot = {
                url: item.screenshotImage,
                color: item.screenshotBgColor,
                fontColor: item.screenshotFontColor
            };
        }
        return frontendThumb;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var Thumb = __webpack_require__(271);
    var storage = __webpack_require__(294);
    var channel = __webpack_require__(27);
    var assert = __webpack_require__(293);
    var settings = __webpack_require__(216);
    var logger = __webpack_require__(5).create("Thumbs collection");
    var MAX_THUMBS_COUNT = 25;
    var MAX_THUMBS_COUNT_INCREASED = 49;
    var items = [];
    var collection = module.exports = {
        init: function() {
            storage.init(this);
            return this;
        },
        onChanged: channel.create(),
        onLoaded: channel.create(),
        onUpdateError: channel.create(),
        loadFromDB: function(callback) {
            storage.load(function(err, thumbs) {
                if (err) {
                    logger.error("Can not load from db %j", err);
                    callback(err);
                } else {
                    logger.info("Loaded thumbs from db: %i", thumbs.length);
                    collection.onChanged.mute();
                    var logData = thumbs.map(function(thumb, position) {
                        collection.setItem(position, thumb);
                        return position + " " + thumb.url + (thumb.pinned ? " (pinned)" : "");
                    }).join("; ");
                    logger.info(logData);
                    collection.onChanged.unmute();
                    collection.onLoaded.dispatch(collection);
                    callback();
                }
            }.bind(this));
        },
        toArray: function() {
            return items.map(function(thumb, position) {
                return {
                    position: position,
                    thumb: thumb
                };
            });
        },
        get items() {
            return items;
        },
        get length() {
            return items.length;
        },
        get maxLength() {
            return settings.get("maxAvailableIncreased") ? MAX_THUMBS_COUNT_INCREASED : MAX_THUMBS_COUNT;
        },
        clear: function() {
            logger.info("Cleared");
            items.length = 0;
            return this;
        },
        getItem: function(position) {
            return items[position];
        },
        setItem: function(position, thumb) {
            return this._appendItem(position, thumb, function() {
                items[position] = thumb;
            });
        },
        insertItem: function(position, thumb) {
            return this._appendItem(position, thumb, function() {
                items.splice(position, 0, thumb);
            });
        },
        removeItem: function(position) {
            if (position >= 0 && position < this.length) {
                var removedThumbs = items.splice(position, 1);
                if (removedThumbs.length) removeListenersFromThumb(removedThumbs[0]);
                this.onChanged.dispatch(this);
            } else logger.warn("Try to remove nonexistent position %i", position);
            return this;
        },
        loadMissingData: function(options) {
            options = options || {};
            logger.info("Loading missing data with options %j", options);
            var positions = Array.isArray(options.positions) ? options.positions : Object.keys(this.items);
            positions.forEach(function(position) {
                var thumb = this.getItem(position);
                if (thumb) thumb.update(Boolean(options.force));
            }, this);
        },
        hasDomain: function(normalDomain) {
            return items.some(function(thumb) {
                return utils.url.getNormalDomain(thumb.url) === normalDomain;
            });
        },
        hasUrl: function(url) {
            return items.some(function(thumb) {
                return utils.url.isEqualUrls(thumb.url, url);
            });
        },
        _appendItem: function(position, thumb, appendAction) {
            assert.type(thumb, Thumb, "Thumb param should be instance of Thumb!");
            if (position >= 0) {
                appendAction();
                addListenersToThumb(thumb);
                this.onChanged.dispatch(this);
            } else logger.warn("Try to append item to incorrect position %i", position);
            return this;
        }
    };
    function addListenersToThumb(thumb) {
        if (!thumb.onChanged.hasListener(onItemChanged)) thumb.onChanged.addListener(onItemChanged);
    }
    function removeListenersFromThumb(thumb) {
        thumb.onChanged.removeListener(onItemChanged);
    }
    function onItemChanged() {
        collection.onChanged.dispatch(collection);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var asyncLib = __webpack_require__(209);
    var utils = __webpack_require__(30);
    var channel = __webpack_require__(27);
    var pick = __webpack_require__(75);
    var merge = __webpack_require__(157);
    var pluck = __webpack_require__(156);
    var titleLoader = __webpack_require__(272);
    var faviconLoader = __webpack_require__(222);
    var tableauLoader = __webpack_require__(273);
    var cloudLogo = __webpack_require__(274);
    var screenshotsCache = __webpack_require__(292);
    var assert = __webpack_require__(293);
    var dateUtils = __webpack_require__(4);
    var logger = __webpack_require__(5).create("Thumb");
    var urlUtils = utils.url;
    var DOMAIN_LEVEL = 0;
    var URL_LEVEL = 1;
    var THUMB_FIELDS_DESCRIPTORS = [ {
        name: "url",
        level: DOMAIN_LEVEL
    }, {
        name: "pinned",
        level: DOMAIN_LEVEL,
        default: 0
    }, {
        name: "title",
        level: URL_LEVEL
    }, {
        name: "visits",
        level: DOMAIN_LEVEL,
        default: 0
    }, {
        name: "faviconUrl",
        level: DOMAIN_LEVEL
    }, {
        name: "faviconColor",
        level: DOMAIN_LEVEL
    }, {
        name: "faviconFsPath",
        level: DOMAIN_LEVEL
    }, {
        name: "tableauImage",
        level: DOMAIN_LEVEL
    }, {
        name: "tableauColor",
        level: DOMAIN_LEVEL
    }, {
        name: "tableauFsPath",
        level: DOMAIN_LEVEL
    }, {
        name: "tableauUpdateTime",
        level: DOMAIN_LEVEL
    }, {
        name: "cloudColor",
        level: DOMAIN_LEVEL
    }, {
        name: "cloudImage",
        level: DOMAIN_LEVEL
    }, {
        name: "cloudImageSub",
        level: DOMAIN_LEVEL
    }, {
        name: "cloudImageFsPath",
        level: DOMAIN_LEVEL
    }, {
        name: "cloudImageSubFsPath",
        level: DOMAIN_LEVEL
    }, {
        name: "screenshotImage",
        level: URL_LEVEL
    }, {
        name: "screenshotBgColor",
        level: URL_LEVEL
    }, {
        name: "screenshotFontColor",
        level: URL_LEVEL
    }, {
        name: "screenshotUpdateTime",
        level: URL_LEVEL
    }, {
        name: "screenshotFsPath",
        level: URL_LEVEL
    } ];
    var THUMB_FIELDS = pluck(THUMB_FIELDS_DESCRIPTORS, "name");
    function Thumb(url) {
        this._resetProps(DOMAIN_LEVEL);
        if (url) this.url = url;
        this.onChanged = channel.create();
    }
    Thumb.prototype = {
        set url(newUrl) {
            assert.notEmpty(newUrl, "Can not set empty url");
            newUrl = urlUtils.getNormalUrl(newUrl);
            if (this._url && !urlUtils.isEqualUrls(this._url, newUrl)) {
                logger.info("Url %s changed to %s", this._url, newUrl);
                if (this._checkForNewDomain(newUrl)) this._resetProps(DOMAIN_LEVEL); else this._resetProps(URL_LEVEL);
            }
            this._url = newUrl;
        },
        get url() {
            return this._url;
        },
        set pinned(value) {
            this._pinned = value ? 1 : 0;
            if (this.onChanged) this.onChanged.dispatch(this);
        },
        get pinned() {
            return this._pinned;
        }
    };
    Thumb.fromJSON = function(json) {
        if (!json || !json.url) throw new Error("Invalid json");
        var thumb = new Thumb();
        var allowedFields = pick(json, THUMB_FIELDS);
        return merge(thumb, allowedFields);
    };
    Thumb.prototype.toJSON = function() {
        if (!this.url) throw new Error("Cant get json for thumb without url");
        return pick(this, THUMB_FIELDS);
    };
    Thumb.prototype.update = function(force, callback) {
        callback = callback || utils.noop;
        if (urlUtils.isAllowedForDownload(this.url)) this._runUpdateTasks(force, callback); else {
            var err = new Error("Can not update thumb using bad url: " + this.url);
            logger.info("Update error: %s", err.message);
            callback(err);
        }
    };
    Thumb.prototype._runUpdateTasks = function(force, callback) {
        var _this = this;
        asyncLib.parallel([ this._updateCloud.bind(this, force), this._updateTableau.bind(this, force), this._updateTitle.bind(this, force), this._updateFavicon.bind(this, force), this._updateScreenshot.bind(this, force) ], function(error, results) {
            var errors = [];
            var msgs = [];
            results.forEach(function() {
                var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], _ref2 = _slicedToArray(_ref, 2), error = _ref2[0], msg = _ref2[1];
                if (error) errors.push(error);
                if (msg) msgs.push(msg);
            });
            if (msgs.length) logger.info("Fields %s were updated for %s", msgs.join(", "), _this.url);
            callback(errors);
        });
    };
    Thumb.prototype._updateCloud = function(force, callback) {
        if (force || !this.cloudImage || !this.cloudColor) this._loadCloudData(callback); else callback();
    };
    Thumb.prototype._loadCloudData = function(callback) {
        cloudLogo.get(this.url, function(err, data) {
            var changed = this._batchChange(data, [ {
                dest: "cloudImage",
                src: "logo"
            }, {
                dest: "cloudImageSub",
                src: "logoSub"
            }, {
                dest: "cloudImageFsPath",
                src: "logoPath"
            }, {
                dest: "cloudImageSubFsPath",
                src: "logoSubPath"
            }, {
                dest: "cloudColor",
                src: "color"
            } ]);
            callback(null, [ err, changed ? "cloud data" : "" ]);
        }.bind(this));
    };
    Thumb.prototype._updateTableau = function(force, callback) {
        if (force || this._isTableauNeedUpdate()) this._loadTableauData(callback); else callback();
    };
    Thumb.prototype._isTableauNeedUpdate = function() {
        return !this.tableauUpdateTime || Math.abs(Date.now() - this.tableauUpdateTime) > dateUtils.WEEK_MS;
    };
    Thumb.prototype._loadTableauData = function(callback) {
        tableauLoader.getManifest(this.url, function(err, data) {
            this.tableauUpdateTime = Date.now();
            var changed = this._batchChange(data, [ {
                dest: "tableauImage",
                src: "url"
            }, {
                dest: "tableauColor",
                src: "color"
            }, {
                dest: "tableauFsPath",
                src: "filePath"
            } ]);
            callback(null, [ err, changed ? "tablo data" : "" ]);
        }.bind(this));
    };
    Thumb.prototype._updateFavicon = function(force, callback) {
        if (force || !this.faviconUrl) this._loadFaviconData(callback); else callback();
    };
    Thumb.prototype._loadFaviconData = function(callback) {
        faviconLoader.getFavicon(this.url, function(err, data) {
            var changed = this._batchChange(data, [ {
                dest: "faviconUrl",
                src: "url"
            }, {
                dest: "faviconColor",
                src: "color"
            }, {
                dest: "faviconFsPath",
                src: "filePath"
            } ]);
            callback(null, [ err, changed ? "favicon" : "" ]);
        }.bind(this));
    };
    Thumb.prototype._updateTitle = function(force, callback) {
        if (void 0 === this.title) this._loadTitleData(callback); else callback();
    };
    Thumb.prototype._loadTitleData = function(callback) {
        titleLoader.getTitle(this.url, function(err, data) {
            var changed = this._batchChange(data, [ {
                dest: "title"
            } ]);
            callback(null, [ err, changed ? "title" : "" ]);
        }.bind(this));
    };
    Thumb.prototype._updateScreenshot = function(force, callback) {
        if (force || !this.screenshotImage) this._loadScreenshotData(callback); else callback();
    };
    Thumb.prototype._loadScreenshotData = function(callback) {
        var cache = screenshotsCache.get(this.url);
        var changed = this._batchChange(cache, [ {
            dest: "screenshotImage"
        }, {
            dest: "screenshotBgColor"
        }, {
            dest: "screenshotFontColor"
        }, {
            dest: "screenshotUpdateTime"
        }, {
            dest: "screenshotFsPath"
        } ]);
        callback(null, [ null, changed ? "screenshot" : "" ]);
    };
    Thumb.prototype._checkForNewDomain = function(newUrl) {
        var oldDomain = this.url ? urlUtils.getNormalDomain(this.url) : "";
        var newDomain = urlUtils.getNormalDomain(newUrl);
        return newDomain !== oldDomain;
    };
    Thumb.prototype._resetProps = function(level) {
        THUMB_FIELDS_DESCRIPTORS.forEach(function(fieldDescriptor) {
            if (fieldDescriptor.level >= level) this._resetProperty(fieldDescriptor);
        }, this);
    };
    Thumb.prototype._resetProperty = function(fieldDescriptor) {
        if (void 0 !== fieldDescriptor.default) this[fieldDescriptor.name] = fieldDescriptor.default; else delete this[fieldDescriptor.name];
    };
    Thumb.prototype._batchChange = function(srcObj, fieldsMap) {
        if (!srcObj) return false;
        var changed = false;
        fieldsMap.forEach(function(item) {
            var destKey = item.dest;
            var srcKey = item.src || destKey;
            var srcValue = srcObj[srcKey];
            if (this[destKey] !== srcValue) {
                this[destKey] = srcValue;
                changed = true;
            }
        }, this);
        if (changed) this.onChanged.dispatch(this);
        return changed;
    };
    module.exports = Thumb;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var siteLoader = __webpack_require__(226);
    var asyncLib = __webpack_require__(209);
    var find = __webpack_require__(197);
    var get = __webpack_require__(193);
    var urlUtils = __webpack_require__(83);
    var ResourceLoader = __webpack_require__(256);
    var resourceLoader;
    var findMethods = {
        openTabs: function(normalUrl, callback) {
            chrome.windows.getAll({
                populate: true
            }, function(windows) {
                var title = null;
                windows.some(function(windowItem) {
                    title = findTitle(windowItem.tabs, normalUrl);
                    return Boolean(title);
                });
                callback(null, title);
            });
        },
        history: function(normalUrl, callback) {
            chrome.history.search({
                text: normalUrl
            }, function(items) {
                var title = findTitle(items, normalUrl);
                callback(null, title);
            });
        }
    };
    module.exports = {
        init: function() {
            resourceLoader = new ResourceLoader();
        },
        getTitle: function(siteUrl, callback) {
            resourceLoader.load({
                id: siteUrl,
                loadMethod: loadMethod.bind(null, siteUrl),
                callback: callback
            });
        },
        clearExpired: function() {
            resourceLoader.clearExpired();
        }
    };
    function loadMethod(siteUrl, callback) {
        var normalUrl = urlUtils.getNormalUrl(siteUrl);
        asyncLib.parallel({
            tabs: findMethods.openTabs.bind(null, normalUrl),
            history: findMethods.history.bind(null, normalUrl)
        }, function(error, results) {
            var title = results.tabs || results.history;
            if (title) callback(null, {
                title: title
            }); else siteLoader.load(siteUrl, function(err, rootNode) {
                callback(err, {
                    title: parseTitle(rootNode)
                });
            });
        });
    }
    function parseTitle(data) {
        return get(data, "title[0].value", void 0);
    }
    function findTitle(items, normalUrl) {
        var item = find(items, function(item) {
            return urlUtils.getNormalUrl(item.url) === normalUrl;
        });
        return item && item.title || "";
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    function _toArray(arr) {
        return Array.isArray(arr) ? arr : Array.from(arr);
    }
    var siteLoader = __webpack_require__(226);
    var urlUtils = __webpack_require__(83);
    var colorUtil = __webpack_require__(259);
    var xhr = __webpack_require__(32);
    var logger = __webpack_require__(5).create("site-info/tableau");
    var asyncLib = __webpack_require__(209);
    var find = __webpack_require__(197);
    var get = __webpack_require__(193);
    var colorUtils = __webpack_require__(259);
    var FileStorage = __webpack_require__(263);
    var ResourceLoader = __webpack_require__(256);
    var fileStorage;
    var resourceLoader;
    var MANIFEST_LINK_REL = "yandex-tableau-widget";
    var VALID_KEYS = [ "logo", "color", "feed" ];
    module.exports = {
        TABLEAU_DIR: "tableau",
        init: function() {
            fileStorage = new FileStorage(module.exports.TABLEAU_DIR);
            resourceLoader = new ResourceLoader();
        },
        getManifest: function(siteUrl, callback) {
            siteUrl = urlUtils.getIndexPart(siteUrl);
            resourceLoader.load({
                id: siteUrl,
                loadMethod: loadMethod.bind(null, siteUrl),
                callback: callback
            });
        },
        clearExpired: function() {
            resourceLoader.clearExpired();
        }
    };
    function loadMethod(siteUrl, callback) {
        siteLoader.load(siteUrl, function(err, rootNode) {
            if (err) callback(err); else parseSite(siteUrl, rootNode, callback);
        });
    }
    function parseSite(siteUrl, rootNode, callback) {
        asyncLib.waterfall([ function(next) {
            next(null, {
                doWarn: false,
                siteUrl: siteUrl,
                domain: urlUtils.getNormalDomain(siteUrl),
                fileUrl: null,
                remoteUrl: null,
                color: null,
                rootNode: rootNode,
                manifestUrl: null,
                text: null,
                remoteColor: null
            });
        }, function(data, next) {
            var err = !data.rootNode ? new Error("Root node is missing") : null;
            next(err, data);
        }, function(data, next) {
            data.manifestUrl = getUrlToManifestJson(data.rootNode, data.siteUrl);
            data.metaContent = getMetaContent(data.rootNode);
            var err = !data.manifestUrl && !data.metaContent ? new Error("No tableau manifest") : null;
            next(err, data);
        }, function(data, next) {
            if (data.manifestUrl) xhr({
                url: data.manifestUrl,
                ignoreParseError: true,
                parse: "json"
            }, function(err, responseJson) {
                if (err) data.doWarn = true; else data.json = responseJson;
                next(err, data);
            }); else {
                data.json = parseMetaContent(data.metaContent);
                next(null, data);
            }
        }, function(data, next) {
            var layout = data.json && data.json.layout || {};
            if (!layout.logo) next(new Error("No logo in tableau manifest"), data); else {
                var uri = urlUtils.createURI(layout.logo);
                if (!uri) next(new Error("Invalid url " + layout.logo), data); else {
                    data.remoteUrl = uri.absoluteTo(data.siteUrl);
                    data.remoteColor = layout.color;
                    next(null, data);
                }
            }
        }, function(data, next) {
            fileStorage.download(data.remoteUrl, data.domain, function(err, storageData) {
                data.doWarn = Boolean(err) || !storageData || !storageData.url;
                if (storageData) {
                    data.fileUrl = storageData.url;
                    data.filePath = storageData.path;
                }
                next(err, data);
            });
        }, function(data, next) {
            if (data.remoteColor) {
                data.color = colorUtil.normalize(data.remoteColor);
                next(null, data);
            } else colorUtils.calculateDominantColorByUrl(data.fileUrl, null, function(color) {
                data.color = color;
                next(null, data);
            });
        } ], function(err, data) {
            if (err) {
                if (data.doWarn) logger.warn("Error with tableau manifest domain: %s; url: %s %s", data.domain, data.siteUrl, err.message);
                callback(err);
            } else callback(null, {
                url: data.fileUrl,
                remoteUrl: data.remoteUrl,
                color: data.color,
                filePath: data.filePath
            });
        });
    }
    function getUrlToManifestJson(data, siteUrl) {
        var manifestHref = extractManifestHref(data);
        var baseUrl = get(data, "base[0].attributes.href");
        return urlUtils.resolve(siteUrl, baseUrl, manifestHref);
    }
    function extractManifestHref(data) {
        data = data || {};
        var link = find(data.link, function(linkData) {
            return get(linkData, "attributes.rel") === MANIFEST_LINK_REL;
        });
        return get(link, "attributes.href", null);
    }
    function getMetaContent(data) {
        data = data || {};
        var meta = find(data.meta, function(metaData) {
            return get(metaData, "attributes.name") === MANIFEST_LINK_REL;
        });
        return get(meta, "attributes.content", null);
    }
    function parseMetaContent(content) {
        var parts = content.split(",");
        var params = Object.create(null);
        parts.forEach(function(part) {
            var _part$trim$split = part.trim().split("="), _part$trim$split2 = _toArray(_part$trim$split), key = _part$trim$split2[0], value = _part$trim$split2.slice(1);
            if (key && VALID_KEYS.indexOf(key) >= 0) params[key] = value.join("=");
        });
        return {
            api_version: 4,
            layout: {
                logo: params.logo || void 0,
                color: params.color || void 0
            },
            feed: params.feed || void 0
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var saver = __webpack_require__(275);
    var urlUtils = __webpack_require__(83);
    var cloudLogoLoader = __webpack_require__(276);
    var ResourceLoader = __webpack_require__(256);
    var resourceLoader;
    module.exports = {
        get: function(url, callback) {
            var domain = urlUtils.getNormalDomain(url);
            resourceLoader = resourceLoader || new ResourceLoader();
            resourceLoader.load({
                id: domain,
                loadMethod: loadCloudLogo.bind(null, domain),
                callback: callback
            });
        },
        clearExpired: function() {
            if (resourceLoader) resourceLoader.clearExpired();
        }
    };
    function loadCloudLogo(domain, callback) {
        cloudLogoLoader.loadFromServer(domain, function(err, loaderRes) {
            if (err) callback(err); else if (!loaderRes) callback(); else saveCloudLogo(loaderRes, domain, callback);
        });
    }
    function saveCloudLogo(cloudData, domain, callback) {
        saver.save(cloudData.logo, cloudData.logoSub, domain, function(err, localData) {
            if (err) callback(err); else {
                var result = constructResult(localData.logoData, localData.logoSubData, cloudData.color);
                callback(null, result);
            }
        });
    }
    function constructResult(logoData, logoSubData, color) {
        return {
            logo: logoData.url,
            logoPath: logoData.path,
            logoSub: logoSubData.url,
            logoSubPath: logoSubData.path,
            color: color
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var FileStorage = __webpack_require__(263);
    var asyncLib = __webpack_require__(209);
    var logger = __webpack_require__(5).create("Cloud-logo/saver");
    exports.CLOUD_LOGO_DIR = "logo";
    exports.CLOUD_LOGO_SUB_DIR = "logo-sub";
    var storage = {
        get main() {
            return this._main || (this._main = new FileStorage(exports.CLOUD_LOGO_DIR));
        },
        get sub() {
            return this._sub || (this._sub = new FileStorage(exports.CLOUD_LOGO_SUB_DIR));
        }
    };
    exports.save = function(remoteUrl, remoteUrlSub, domain, callback) {
        if (!remoteUrl) {
            callback(new Error("Empty remoteURL"));
            return;
        }
        var tasks = {};
        tasks.logoData = function(callback) {
            storage.main.download(remoteUrl, domain, callback);
        };
        if (remoteUrlSub) tasks.logoSubData = function(callback) {
            storage.sub.download(remoteUrlSub, domain, callback);
        };
        asyncLib.parallel(tasks, function(err, res) {
            if (err) {
                logger.error("Error while downloading logos: %s, %s", remoteUrl, remoteUrlSub);
                callback(err);
            } else {
                logger.info("Logo downloaded for domain: %s", domain);
                res.logoSubData = res.logoSubData || {};
                callback(null, res);
            }
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var utils = __webpack_require__(30);
    var branding = __webpack_require__(277);
    var curly = __webpack_require__(207);
    var i18n = __webpack_require__(280);
    var logger = __webpack_require__(5).create("Cloud-logo/loader");
    var URL_TPL = "https://api.browser.yandex.ru/dashboard3/get/?nodes={nodes}&brandID={brandId}&lang={lang}&scale=0.43";
    module.exports = {
        loadFromServer: function(domain, callback) {
            var url = curly.insertUrlVars(URL_TPL, {
                nodes: domain,
                brandId: branding.vars.regionId,
                lang: i18n.locale
            });
            logger.info("Loading logo for domain: %s", domain);
            utils.xhr({
                url: url,
                logError: true,
                parse: "json"
            }, function(err, json) {
                callback(err, err ? null : parseResponse(json, url));
            });
        }
    };
    function parseResponse(json, url) {
        if (!json || !Array.isArray(json)) {
            logger.warn("JSON for url %s is not array %j", url, json);
            return null;
        }
        var item = json[0];
        if (!item) return null;
        var res = "object" === ("undefined" === typeof item ? "undefined" : _typeof(item)) ? item.resources : null;
        var hasRequiredFields = res && "object" === ("undefined" === typeof res ? "undefined" : _typeof(res)) && res.logo_main && "string" === typeof res.logo_main && item.bgcolor && "string" === typeof item.bgcolor;
        if (!hasRequiredFields) {
            logger.warn("JSON for url %s does not contain required fields %j", url, json);
            return null;
        }
        return {
            logo: res.logo_main,
            logoSub: res.logo_sub !== res.logo_main ? res.logo_sub : null,
            color: item.bgcolor.replace(/^#/, "")
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var platformBranding = __webpack_require__(278);
    var blocks = __webpack_require__(289);
    var i18n = __webpack_require__(280);
    var logger = __webpack_require__(5).create("Branding");
    var platformClid = __webpack_require__(288);
    var curly = __webpack_require__(207);
    var _ = __webpack_require__(91);
    var remoteBrandingStorage = __webpack_require__(291);
    var channel = __webpack_require__(27);
    var cache = {};
    exports.REGION_BRANDINGS = {
        YANDEX: "yandex",
        UA: "ua",
        TB: "tb"
    };
    exports.init = function(callback) {
        platformBranding.init().then(function() {
            reset();
            logger.info("Branding initialized. Regional = %s, custom = %s, available = [%s]", exports.getRegionBrandId(), exports.getCustomBrandId() || "(empty)", platformBranding.getAvailableBrandIds().join(", "));
            remoteBrandingStorage.onUpdated.addListener(onRemoteBrandingLoaded);
            callback();
        });
    };
    exports.getBlock = function(name) {
        if (!cache[name]) cache[name] = blocks.getMerged(name, {
            i18n: cache.i18n,
            expandUrl: exports.expandUrl
        });
        return cache[name];
    };
    exports.getRegionBrandId = function() {
        return platformBranding.getData().vars.brandId;
    };
    exports.getCustomBrandId = function() {
        var regionBrandId = exports.getRegionBrandId();
        return exports.vars.brandId !== regionBrandId ? exports.vars.brandId : "";
    };
    exports.getFileUrl = function(path) {
        if ("string" !== typeof path || !path) return path;
        path = path.replace(/^\/+/, "");
        var regionBrandId = exports.getRegionBrandId();
        return platformBranding.getFileUrl(regionBrandId + "/" + path);
    };
    exports.expandUrl = function(url, vars) {
        vars = _.merge({
            regionId: exports.vars.regionId,
            regionTld: exports.vars.regionTld,
            locale: i18n.locale,
            localeTld: i18n.localeTld
        }, vars);
        return curly.insertUrlVars(url, vars, {
            getter: urlVarGetter
        });
    };
    exports.onRemoteLoaded = channel.create("branding.onRemoteLoaded");
    function initBaseBlocks() {
        cache.i18n = blocks.getMerged("i18n");
        cache.vars = blocks.getMerged("vars");
    }
    function makeGetters() {
        blocks.getNames().forEach(makeGetter);
    }
    function makeGetter(blockName) {
        Object.defineProperty(exports, blockName, {
            configurable: true,
            get: function() {
                return exports.getBlock(blockName);
            }
        });
    }
    function urlVarGetter(obj, path) {
        return 0 === path.indexOf("clid") ? platformClid.getByName(path) : _.get(obj, path);
    }
    function reset() {
        cache = {};
        initBaseBlocks();
        makeGetters();
    }
    function onRemoteBrandingLoaded() {
        reset();
        exports.onRemoteLoaded.dispatch();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var buildInfo = __webpack_require__(20);
    var settings = __webpack_require__(216);
    var logger = __webpack_require__(5).create("Platform/branding");
    var browserInfo = __webpack_require__(22);
    var brandingSuggestor = __webpack_require__(279);
    var platformClid = __webpack_require__(288);
    var SETTING_BRANDING_MIGRATION_NAME = "brandingFirefoxTasteMigrated";
    var REGION_BRANDING_SETTING_NAME = "brandingPackage";
    var BRANDINGS_DIR = "brandings";
    var vbBrandings = window.vbBrandings;
    module.exports = {
        init: function() {
            return Promise.resolve().then(function() {
                if (browserInfo.isFirefox()) {
                    var regionalBranding = getRegionBranding();
                    logger.info("regionalBranding = %s", regionalBranding);
                    if (!regionalBranding) return brandingSuggestor.suggest().then(setRegionBranding);
                    if (!settings.get(SETTING_BRANDING_MIGRATION_NAME)) {
                        settings.set(SETTING_BRANDING_MIGRATION_NAME, true);
                        if ([ "yandex", "ua" ].indexOf(regionalBranding) !== -1) {
                            var clid8 = platformClid.getByNumber(8);
                            logger.info("clid8 = %s", clid8);
                            if ("1929745" === clid8) return brandingSuggestor.ensureBrowserDistribution().then(function(brandId) {
                                if (brandId) setRegionBranding(brandId);
                            });
                        }
                    }
                }
            }).then(initRegionBranding, initRegionBranding);
        },
        getData: function(brandId) {
            brandId = brandId || getRegionBranding();
            return vbBrandings[brandId];
        },
        getAvailableBrandIds: function() {
            return Object.keys(vbBrandings);
        },
        getFileUrl: function(path) {
            if ("string" !== typeof path) {
                logger.error("Invalid path to branding file: %j", path);
                return "";
            } else path = path.replace(/^\/+/, "");
            return chrome.runtime.getURL([ BRANDINGS_DIR, path ].join("/"));
        }
    };
    function initRegionBranding() {
        if (!getRegionBranding()) setRegionBranding(buildInfo.getRegionBrandId()); else migrateToNewBrandingNames();
        var availableRegionalBrandIds = Object.keys(vbBrandings).filter(function(brandId) {
            return Boolean(vbBrandings[brandId].vars && vbBrandings[brandId].vars.regionId);
        });
        if (availableRegionalBrandIds.indexOf(getRegionBranding()) === -1) {
            var fallbackBrandId = availableRegionalBrandIds[0];
            logger.error("Regional branding (%s) not found in build. Available brandings: %s. Fallback to %s", getRegionBranding(), availableRegionalBrandIds.join(", "), fallbackBrandId);
            setRegionBranding(fallbackBrandId);
        }
        buildInfo.ensureBrandedBuildInfo(getRegionBranding());
    }
    function setRegionBranding(value) {
        logger.info("Set regional branding: %s", value);
        settings.set(REGION_BRANDING_SETTING_NAME, value);
    }
    function getRegionBranding() {
        return settings.get(REGION_BRANDING_SETTING_NAME);
    }
    function migrateToNewBrandingNames() {
        var regionalBranding = getRegionBranding();
        if ([ "turkey-elements", "turkey_elements" ].indexOf(regionalBranding) >= 0) {
            logger.info("Migrate brandId: %s --> tb", regionalBranding);
            setRegionBranding("tb");
        }
        if ("default" === regionalBranding) {
            logger.info("Migrate brandId: %s --> yandex", regionalBranding);
            setRegionBranding("yandex");
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var i18n = __webpack_require__(280);
    var tabUtils = __webpack_require__(282);
    var platformClid = __webpack_require__(288);
    var logger = __webpack_require__(5).create("Platform/branding-suggestor");
    module.exports = {
        suggest: function() {
            return _suggest();
        },
        ensureBrowserDistribution: function() {
            return _ensureBrowserDistribution();
        }
    };
    function _ensureBrowserDistribution() {
        return new Promise(function(resolve) {
            onTabsReady().then(function() {
                suggestBrandIdByBrowserDistribution().then(function(brandId) {
                    if ("firefox-taste-ru" === brandId || "firefox-taste-ua" === brandId) chrome.storage.local.set({
                        "yandex.statistics.clid.1": "1923014",
                        "yandex.statistics.clid.2": "1923015",
                        "yandex.statistics.clid.4": "1923016",
                        "yandex.statistics.clid.5": "1923017",
                        "yandex.statistics.clid.6": "1923018",
                        "yandex.statistics.clid.7": "1923019",
                        "yandex.statistics.clid.8": "1923020",
                        "yandex.statistics.clid.9": "1923021",
                        "yandex.statistics.clid.10": "1923022",
                        "yandex.statistics.clid.11": "1923023",
                        "yandex.statistics.clid.12": "1923024",
                        "yandex.statistics.clid.13": "1923025",
                        "yandex.statistics.clid.14": "1923026",
                        "yandex.statistics.clid.15": "2164525",
                        "yandex.statistics.clid.17": "2164526",
                        "yandex.statistics.clid.18": "2164527",
                        "yandex.statistics.clid.20": "2161617"
                    }, function() {
                        platformClid.init(function() {
                            resolve(brandId);
                        });
                    }); else if ("firefox-taste-mz" === brandId) chrome.storage.local.set({
                        "yandex.statistics.clid.1": "2320516",
                        "yandex.statistics.clid.2": "2320517",
                        "yandex.statistics.clid.4": "2320518",
                        "yandex.statistics.clid.5": "2320519",
                        "yandex.statistics.clid.6": "2320520",
                        "yandex.statistics.clid.7": "2320521",
                        "yandex.statistics.clid.8": "2320522",
                        "yandex.statistics.clid.9": "2320523",
                        "yandex.statistics.clid.10": "2320524",
                        "yandex.statistics.clid.11": "2320525",
                        "yandex.statistics.clid.12": "2320526",
                        "yandex.statistics.clid.13": "2320527",
                        "yandex.statistics.clid.14": "2320528",
                        "yandex.statistics.clid.15": "2320529",
                        "yandex.statistics.clid.17": "2320530",
                        "yandex.statistics.clid.18": "2320531",
                        "yandex.statistics.clid.20": "2320532"
                    }, function() {
                        platformClid.init(function() {
                            resolve(brandId);
                        });
                    }); else resolve(brandId);
                });
            });
        });
    }
    function _suggest() {
        return new Promise(function(resolve) {
            var suggestor = function() {
                suggestBrandIdByBrowserDistribution().then(function(brandId) {
                    if (brandId) {
                        logger.info('Suggested brandId (browser distribution) - "%s"', brandId);
                        resolve(brandId);
                        return;
                    }
                    suggestBrandIdByCookies().then(function(brandId) {
                        if (brandId) logger.info('Suggested brandId (cookies) - "%s"', brandId); else {
                            brandId = suggestBrandIdByLocale();
                            logger.info('Suggested brandId (locale) - "%s"', brandId);
                        }
                        resolve(brandId);
                    });
                });
            };
            onTabsReady().then(suggestor);
        });
    }
    function onTabsReady() {
        return new Promise(function(resolve) {
            var i = 0;
            var tabsStatusCheckerInterval = setInterval(function() {
                tabUtils.getOpen(function(error, tabs) {
                    var loaded = !error && tabs.some(function(tab) {
                        return "complete" === tab.status;
                    });
                    if (loaded || i++ > 20) {
                        clearInterval(tabsStatusCheckerInterval);
                        setTimeout(function() {
                            logger.info("On tabs ready");
                            resolve();
                        }, 1e3);
                    }
                });
            }, 500);
        });
    }
    function suggestBrandIdByBrowserDistribution() {
        return new Promise(function(resolve) {
            suggestBrandIdByBrowserHomepage().then(function(brandId) {
                if (brandId) {
                    logger.info('Suggested brandId (browser distribution; homepage) - "%s"', brandId);
                    resolve(brandId);
                    return;
                }
                suggestBrandIdByBrowserBookmarks().then(function(brandId) {
                    if (brandId) {
                        logger.info('Suggested brandId (browser distribution; bookmarks) - "%s"', brandId);
                        resolve(brandId);
                        return;
                    }
                    resolve(null);
                });
            });
        });
    }
    function suggestBrandIdByBrowserHomepage() {
        return new Promise(function(resolve) {
            try {
                browser.browserSettings.homepageOverride.get({}).then(function(result) {
                    if (result && String(result.value).indexOf("clid=2320518") !== -1) resolve("firefox-taste-mz"); else resolve(null);
                });
            } catch (e) {
                logger.error(e);
                resolve(null);
            }
        });
    }
    function suggestBrandIdByBrowserBookmarks() {
        return new Promise(function(resolve) {
            chrome.bookmarks.getSubTree("toolbar_____", function(tree) {
                var brandId = null;
                var yandexRuFlagsCount = 0;
                var yandexUaFlagsCount = 0;
                if (tree && 1 === tree.length) {
                    var toolbarBookmarks = tree[0].children;
                    if (Array.isArray(toolbarBookmarks)) toolbarBookmarks.forEach(function(treeNode) {
                        if ("bookmark" === treeNode.type) {
                            if ("Главная страница Яндекса" === treeNode.title) yandexRuFlagsCount++; else if ("Головна сторінка Яндекса" === treeNode.title) yandexUaFlagsCount++;
                        } else if ("folder" === treeNode.type) if ("Сервисы Яндекса" === treeNode.title) yandexRuFlagsCount++; else if ("Сервіси Яндекса" === treeNode.title) yandexUaFlagsCount++;
                    });
                }
                if (2 === yandexRuFlagsCount) brandId = "firefox-taste-ru"; else if (2 === yandexUaFlagsCount) brandId = "firefox-taste-ua";
                resolve(brandId);
            });
        });
    }
    function suggestBrandIdByCookies() {
        var cookiesData = [ {
            brandId: "yandex",
            cookieDesc: {
                domain: "yandex.ru"
            }
        }, {
            brandId: "ua",
            cookieDesc: {
                domain: "yandex.ua"
            }
        }, {
            brandId: "tb",
            cookieDesc: {
                domain: "yandex.com.tr"
            }
        } ];
        var brandIdWithMaxCookies = null;
        var count = 7;
        return Promise.all(cookiesData.map(function(_ref) {
            var brandId = _ref.brandId, cookieDesc = _ref.cookieDesc;
            return new Promise(function(resolve) {
                chrome.cookies.getAll(cookieDesc, function(cookies) {
                    if (Array.isArray(cookies) && cookies.length > count) {
                        brandIdWithMaxCookies = brandId;
                        count = cookies.length;
                    }
                    resolve();
                });
            });
        })).then(function() {
            return brandIdWithMaxCookies;
        });
    }
    function suggestBrandIdByLocale() {
        var brandId = "yandex";
        switch (i18n.browserLocale) {
          case "uk":
            brandId = "ua";
            break;

          case "tr":
            brandId = "tb";
        }
        return brandId;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var platformLocale = __webpack_require__(281);
    var logger = __webpack_require__(5).create("I18n");
    var AVAILABLE_LOCALES = {
        be: {
            tld: "by"
        },
        en: {
            tld: "com"
        },
        ru: {
            tld: "ru"
        },
        tr: {
            tld: "com.tr"
        },
        uk: {
            tld: "ua"
        }
    };
    var FALLBACK_LOCALE = "ru";
    var locale;
    var i18n = module.exports = {
        init: function(defaultLocale) {
            if (!defaultLocale) {
                logger.error("No default locale passed! Fallback to: %s", FALLBACK_LOCALE);
                defaultLocale = FALLBACK_LOCALE;
            }
            var browserLocale = i18n.browserLocale;
            locale = AVAILABLE_LOCALES[browserLocale] ? browserLocale : defaultLocale;
            logger.info("Platform locale: %s, app locale: %s", browserLocale, locale);
        },
        get browserLocale() {
            return platformLocale.get();
        },
        get locale() {
            return locale;
        },
        get localeTld() {
            return AVAILABLE_LOCALES[locale].tld;
        }
    };
}, function(module, exports) {
    "use strict";
    module.exports = {
        get: function() {
            return chrome.i18n.getMessage("@@ui_locale").split("_")[0];
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _require = __webpack_require__(23), visbookmarksUrl = _require.visbookmarksUrl;
    var thenChrome = __webpack_require__(283);
    exports.getFrontendTabs = function() {
        return thenChrome.windows.getAll({
            populate: true
        }).then(function(windows) {
            return windows.reduce(function(windowsMap, _ref) {
                var windowId = _ref.id, tabs = _ref.tabs;
                tabs = tabs.filter(function(tab) {
                    return visbookmarksUrl === tab.url;
                });
                if (tabs.length) windowsMap.set(windowId, tabs);
                return windowsMap;
            }, new Map());
        });
    };
    exports.getOpen = function(callback) {
        chrome.windows.getAll({
            populate: true
        }, function(windows) {
            if (chrome.runtime.lastError) callback(chrome.runtime.lastError); else callback(null, getTabsFromWindows(windows));
        });
    };
    function getTabsFromWindows(windows) {
        return windows.reduce(function(tabList, windowElem) {
            return tabList.concat(windowElem.tabs);
        }, []);
    }
}, function(module, exports, __webpack_require__) {
    (function(global) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var _api = __webpack_require__(284);
        var _api2 = _interopRequireDefault(_api);
        var Thenable = getNativePromise();
        function getNativePromise() {
            if ("undefined" !== typeof window && window.Promise) return window.Promise;
            if ("undefined" !== typeof global && global.Promise) return global.Promise;
        }
        if (!Thenable) throw new TypeError("Native promise does not support in your environment. Use /out/api function directly");
        exports["default"] = (0, _api2["default"])(Thenable);
        module.exports = exports["default"];
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports["default"] = create;
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var _config = __webpack_require__(285);
    var _config2 = _interopRequireDefault(_config);
    var _wrapper = __webpack_require__(286);
    var _object = __webpack_require__(287);
    function create(Thenable) {
        return Object.keys(_config2["default"]).reduce(function(result, namespace) {
            createNamespace(result, namespace);
            return wrapMethods(result, namespace, _config2["default"][namespace], Thenable);
        }, {});
    }
    function createNamespace(obj, namespace) {
        var chromeNamespace = (0, _object.get)(obj, namespace);
        if (!chromeNamespace) (0, _object.set)(obj, namespace);
        return obj;
    }
    function wrapMethods(obj, namespace, data, Promise) {
        (0, _wrapper.wrapAsyncMethods)(obj, namespace, data.async, Promise);
        (0, _wrapper.wrapSyncMethods)(obj, namespace, data.sync, Promise);
        return obj;
    }
    module.exports = exports["default"];
}, function(module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports["default"] = {
        alarms: {
            async: [ "get", "getAll", "clear", "clearAll" ],
            sync: [ "create" ]
        },
        bookmarks: {
            async: [ "get", "getChildren", "getRecent", "getTree", "getSubTree", "search", "create", "move", "update", "remove", "removeTree" ]
        },
        browserAction: {
            async: [ "getTitle", "setIcon", "getPopup", "getBadgeText", "getBadgeBackgroundColor" ],
            sync: [ "setTitle", "setPopup", "setBadgeText", "setBadgeBackgroundColor", "enable", "disable" ]
        },
        browsingData: {
            async: [ "settings", "remove", "removeAppcache", "removeCache", "removeCookies", "removeDownloads", "removeFileSystems", "removeFormData", "removeHistory", "removeIndexedDB", "removeLocalStorage", "removePluginData", "removePasswords", "removeWebSQL" ]
        },
        commands: {
            async: [ "getAll" ]
        },
        contextMenus: {
            async: [ "create", "update", "remove", "removeAll" ]
        },
        cookies: {
            async: [ "get", "getAll", "set", "remove", "getAllCookieStores" ]
        },
        debugger: {
            async: [ "attach", "detach", "sendCommand", "getTargets" ]
        },
        desktopCapture: {
            async: [ "chooseDesktopMedia" ],
            sync: [ "cancelChooseDesktopMedia" ]
        },
        "devtools.inspectedWindow": {
            async: [ "eval", "getResources" ],
            sync: [ "reload" ]
        },
        "devtools.network": {
            async: [ "getHAR" ]
        },
        "devtools.panels": {
            async: [ "create", "setOpenResourceHandler", "openResource" ]
        },
        dial: {
            async: [ "discoverNow", "fetchDeviceDescription" ]
        },
        downloads: {
            async: [ "download", "search", "pause", "resume", "cancel", "getFileIcon", "erase", "removeFile", "acceptDanger" ],
            sync: [ "open", "show", "showDefaultFolder", "drag", "setShelfEnabled" ]
        },
        extension: {
            async: [ "isAllowedIncognitoAccess", "isAllowedFileSchemeAccess" ],
            sync: [ "getURL", "getViews", "getBackgroundPage", "getExtensionTabs", "setUpdateUrlData" ]
        },
        fontSettings: {
            async: [ "clearFont", "getFont", "setFont", "getFontList", "clearDefaultFontSize", "getDefaultFontSize", "setDefaultFontSize", "clearDefaultFixedFontSize", "getDefaultFixedFontSize", "setDefaultFixedFontSize", "clearMinimumFontSize", "getMinimumFontSize", "setMinimumFontSize" ]
        },
        gcm: {
            async: [ "register", "unregister", "send" ]
        },
        history: {
            async: [ "search", "getVisits", "addUrl", "deleteUrl", "deleteRange", "deleteAll" ]
        },
        i18n: {
            async: [ "getAcceptLanguages", "detectLanguage" ],
            sync: [ "getMessage", "getUILanguage" ]
        },
        identity: {
            async: [ "getAccounts", "getAuthToken", "getProfileUserInfo", "removeCachedAuthToken", "launchWebAuthFlow" ],
            sync: [ "getRedirectURL" ]
        },
        idle: {
            async: [ "queryState" ],
            sync: [ "setDetectionInterval" ]
        },
        instanceID: {
            async: [ "getID", "getCreationTime", "getToken", "deleteToken", "deleteID" ]
        },
        management: {
            async: [ "getAll", "get", "getSelf", "getPermissionWarningsById", "getPermissionWarningsByManifest", "setEnabled", "uninstall", "uninstallSelf", "launchApp", "createAppShortcut", "setLaunchType", "generateAppForLink" ]
        },
        notifications: {
            async: [ "create", "update", "clear", "getAll", "getPermissionLevel" ]
        },
        omnibox: {
            sync: [ "setDefaultSuggestion" ]
        },
        pageAction: {
            async: [ "getTitle", "setIcon", "getPopup" ],
            sync: [ "show", "hide", "setTitle", "setPopup" ]
        },
        pageCapture: {
            async: [ "saveAsMHTML" ]
        },
        permissions: {
            async: [ "getAll", "contains", "request", "remove" ]
        },
        "privacy.network.networkPredictionEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.services.alternateErrorPagesEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.services.autofillEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.services.passwordSavingEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.services.safeBrowsingEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.services.searchSuggestEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.services.spellingServiceEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.services.translationServiceEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.websites.hyperlinkAuditingEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.websites.referrersEnabled": {
            async: [ "get", "set", "clear" ]
        },
        "privacy.websites.thirdPartyCookiesAllowed": {
            async: [ "get", "set", "clear" ]
        },
        "proxy.settings": {
            async: [ "get", "set", "clear" ]
        },
        runtime: {
            async: [ "getBackgroundPage", "openOptionsPage", "setUninstallURL", "requestUpdateCheck", "sendMessage", "sendNativeMessage", "getPlatformInfo", "getPackageDirectoryEntry" ],
            sync: [ "getManifest", "getURL", "reload", "restart", "connect", "connectNative" ]
        },
        sessions: {
            async: [ "getRecentlyClosed", "getDevices", "restore" ]
        },
        "storage.local": {
            async: [ "clear", "get", "set", "remove", "getBytesInUse" ]
        },
        "storage.managed": {
            async: [ "clear", "get", "set", "remove", "getBytesInUse" ]
        },
        "storage.sync": {
            async: [ "clear", "get", "set", "remove", "getBytesInUse" ]
        },
        "system.cpu": {
            async: [ "getInfo" ]
        },
        "system.memory": {
            async: [ "getInfo" ]
        },
        "system.storage": {
            async: [ "getInfo", "ejectDevice", "getAvailableCapacity" ]
        },
        tabCapture: {
            async: [ "capture", "getCapturedTabs" ]
        },
        tabs: {
            async: [ "get", "getCurrent", "sendRequest", "sendMessage", "getSelected", "getAllInWindow", "create", "duplicate", "query", "highlight", "update", "move", "reload", "remove", "detectLanguage", "captureVisibleTab", "executeScript", "insertCSS", "setZoom", "getZoom", "setZoomSettings", "getZoomSettings" ],
            sync: [ "connect" ]
        },
        topSites: {
            async: [ "get" ]
        },
        tts: {
            async: [ "speak", "isSpeaking", "getVoices" ],
            sync: [ "stop", "pause", "resume" ]
        },
        webNavigation: {
            async: [ "getFrame", "getAllFrames" ]
        },
        webRequest: {
            async: [ "handlerBehaviorChanged" ]
        },
        windows: {
            async: [ "get", "getCurrent", "getLastFocused", "getAll", "create", "update", "remove" ]
        }
    };
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    (function(global) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.wrapAsyncMethods = wrapAsyncMethods;
        exports.wrapSyncMethods = wrapSyncMethods;
        var _object = __webpack_require__(287);
        var chromeApi = getChromeApi();
        function wrapAsyncMethods(obj, namespace, asyncMethods, Thenable) {
            if (void 0 === asyncMethods) asyncMethods = [];
            return asyncMethods.reduce(function(result, method) {
                return appendAsyncMethod(obj, namespace, method, Thenable);
            }, obj);
        }
        function wrapSyncMethods(obj, namespace, syncMethods, Thenable) {
            if (void 0 === syncMethods) syncMethods = [];
            return syncMethods.reduce(function(result, method) {
                return appendSyncMethod(obj, namespace, method, Thenable);
            }, obj);
        }
        function getChromeApi() {
            if ("undefined" !== typeof window && window.chrome) return window.chrome;
            if ("undefined" !== typeof global && global.chrome) return global.chrome;
        }
        function appendAsyncMethod(obj, namespace, method, Thenable) {
            var data = (0, _object.get)(obj, namespace);
            Object.defineProperty(data, method, {
                get: function() {
                    return wrapAsyncMethod(Thenable, namespace, method);
                }
            });
            return obj;
        }
        function wrapAsyncMethod(Thenable, namespace, method) {
            var _this = this;
            return function() {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return new Thenable(function(resolve, reject) {
                    var chromeNamespace = (0, _object.get)(chromeApi, namespace);
                    args.push(getResolver(resolve, reject, _this));
                    apply(chromeNamespace[method], chromeNamespace, args);
                });
            };
        }
        function getResolver(resolve, reject, context) {
            return function() {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                if (chromeApi.runtime.lastError) return reject(chromeApi.runtime.lastError);
                return apply(resolve, context, args);
            };
        }
        function appendSyncMethod(obj, namespace, method, PromiseConstructor) {
            var data = (0, _object.get)(obj, namespace);
            Object.defineProperty(data, method, {
                get: function() {
                    return wrapSyncMethod(PromiseConstructor, namespace, method);
                }
            });
            return obj;
        }
        function wrapSyncMethod(Thenable, namespace, method) {
            return function() {
                for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                return new Thenable(function(resolve, reject) {
                    var chromeNamespace = (0, _object.get)(chromeApi, namespace);
                    try {
                        return resolve(apply(chromeNamespace[method], chromeNamespace, args));
                    } catch (e) {
                        return reject(e);
                    }
                });
            };
        }
        function apply(method, context, args) {
            return Function.prototype.apply.call(method, context, args);
        }
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.get = get;
    exports.set = set;
    function get(object, path) {
        var delimiter = arguments.length <= 2 || void 0 === arguments[2] ? "." : arguments[2];
        var keys = path.split(delimiter);
        var data = object;
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!data[key]) return null;
            data = data[key];
        }
        return data;
    }
    function set(obj, path) {
        var delimiter = arguments.length <= 2 || void 0 === arguments[2] ? "." : arguments[2];
        return createNestedObject(obj, path.split(delimiter));
    }
    function createNestedObject(obj, keys) {
        if (keys.length) {
            var nested = obj[keys[0]] = "undefined" === typeof obj[keys[0]] ? {} : obj[keys[0]];
            createNestedObject(nested, keys.slice(1, keys.length));
        }
        return obj;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var logger = __webpack_require__(5).create("Platform/clid");
    var buildInfo = __webpack_require__(20);
    var browserInfo = __webpack_require__(22);
    var isPlainObject = __webpack_require__(39);
    var ClidStorage = function() {
        function ClidStorage() {
            _classCallCheck(this, ClidStorage);
            this.storage = new Map();
        }
        _createClass(ClidStorage, [ {
            key: "setItem",
            value: function(key, value) {
                this.storage.set(key, String(value));
            }
        }, {
            key: "getItem",
            value: function(key) {
                return this.storage.has(key) ? this.storage.get(key) : null;
            }
        }, {
            key: "removeItem",
            value: function(key) {
                this.storage.delete(key);
            }
        }, {
            key: "clear",
            value: function() {
                this.storage.clear();
            }
        }, {
            key: "key",
            value: function(index) {
                var keys = Array.from(this.storage.keys());
                return keys[index] || null;
            }
        }, {
            key: "length",
            get: function() {
                return this.storage.size;
            }
        } ]);
        return ClidStorage;
    }();
    var clidStorage = new ClidStorage();
    var CLID_STORAGE_KEY_CHROME_PREFIX = "clid";
    var CLID_STORAGE_KEY_PREFIX = "yandex.statistics.clid.";
    exports.init = function(callback) {
        if (browserInfo.isFirefox()) importChromeStorageClids(callback, window.localStorage); else importChromeStorageClids(callback, clidStorage);
    };
    exports.getByName = function(name) {
        var number = getClidNumberByName(name);
        return exports.getByNumber(number);
    };
    exports.getByNumber = function(number) {
        return getClidFromStorage(number) || getClidFromBuild(number);
    };
    exports.getPortalClidByNumber = function(number) {
        var clidFromStorage = getClidFromStorage(number);
        return clidFromStorage ? "" : getClidFromBuild(number);
    };
    function getClidFromBuild(number) {
        var clids = buildInfo.getClids() || {};
        var name = getClidNameByNumber(number);
        return clids[name] || "";
    }
    function getClidFromStorage(number) {
        var keyName = CLID_STORAGE_KEY_PREFIX + number;
        var clid = browserInfo.isChrome() ? clidStorage.getItem(keyName) : window.localStorage.getItem(keyName);
        return filterClidValue(clid, keyName);
    }
    function filterClidValue(clid, keyName) {
        clid = String(clid || "").trim().replace(/["']/g, "");
        if (clid && !/^[a-z0-9-]+$/.test(clid)) {
            logger.error("Invalid clid %s from storage: %s", keyName, clid);
            clid = "";
        }
        return clid;
    }
    function getClidNameByNumber(number) {
        return "clid" + number;
    }
    function getClidNumberByName(name) {
        return String(name).replace("clid", "");
    }
    function importChromeStorageClids(callback, storage) {
        chrome.storage.local.get(null, function(values) {
            if (!isPlainObject(values)) {
                logger.error("values is not an object");
                values = Object.create(null);
            }
            try {
                Object.keys(values).filter(function(key) {
                    return 0 === key.indexOf(CLID_STORAGE_KEY_PREFIX) || storage instanceof ClidStorage && 0 === key.indexOf(CLID_STORAGE_KEY_CHROME_PREFIX);
                }).map(function(key) {
                    var clid = filterClidValue(values[key], key);
                    if (clid && null === storage.getItem(key)) storage.setItem(key, clid);
                });
            } catch (err) {
                logger.error("Error importing clids from chrome storage %s", err);
            }
            callback();
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var traverse = __webpack_require__(290);
    var _ = __webpack_require__(91);
    var i18n = __webpack_require__(280);
    var curly = __webpack_require__(207);
    var platformBuildInfo = __webpack_require__(20);
    var platformBranding = __webpack_require__(278);
    var remoteBrandingStorage = __webpack_require__(291);
    var I18N_REGEXP = /\{@([^}]+)\}/g;
    var ASSETS_PLACEHOLDER = "__assets__";
    var MERGE_INFO_KEY = "mergeInfo";
    exports.getMerged = function(name, options) {
        options = options || {};
        var regionBlock = extractBlock(getRegionData(), name, Boolean(options.i18n));
        var customBlock = extractBlock(getCustomData(), name, Boolean(options.i18n));
        var remoteBlock = extractBlock(remoteBrandingStorage.getData(), name);
        var block = _.assign({}, regionBlock);
        mergeBlocks(block, customBlock);
        mergeBlocks(block, remoteBlock);
        if (options.i18n || options.expandUrl) replacePlaceholders(block, options);
        return block;
    };
    exports.getNames = function() {
        return _.uniq([].concat(Object.keys(getRegionData())).concat(Object.keys(getCustomData())).concat(Object.keys(remoteBrandingStorage.getData())));
    };
    function extractBlock(data, name, hasAssets) {
        var block = data[name];
        if (hasAssets) resolveAssets(block, data);
        return block;
    }
    function getRegionData() {
        return platformBranding.getData() || {};
    }
    function getCustomData() {
        var brandId = platformBuildInfo.getCustomBrandId();
        return brandId ? platformBranding.getData(brandId) || {} : {};
    }
    function replacePlaceholders(block, options) {
        traverse(block).forEach(function(item) {
            if ("string" === typeof item) {
                var newItem = replaceI18n(item, options.i18n);
                if (options.expandUrl && /^https?:\/\//.test(newItem)) newItem = options.expandUrl(newItem);
                if (newItem !== item) this.update(newItem);
            }
        });
    }
    function replaceI18n(str, i18nData) {
        var localeData = i18nData && i18nData[i18n.locale];
        return curly.insertVars(str, localeData, {
            regex: I18N_REGEXP
        });
    }
    function resolveAssets(block, brandingData) {
        if (brandingData.vars && brandingData.vars.brandId) {
            var assetsPath = brandingData.vars.brandId + "/assets";
            traverse(block).forEach(function(item) {
                if ("string" === typeof item && 0 === item.indexOf(ASSETS_PLACEHOLDER)) {
                    var itemPath = item.replace(ASSETS_PLACEHOLDER, assetsPath);
                    var itemUrl = platformBranding.getFileUrl(itemPath);
                    this.update(itemUrl);
                }
            });
        }
    }
    function mergeBlocks(to, from) {
        from = from || {};
        var mergeInfo = from[MERGE_INFO_KEY] || {};
        Object.keys(from).forEach(function(key) {
            if (key === MERGE_INFO_KEY) return;
            var fromValue = from[key];
            if (void 0 === fromValue) return;
            if (fromValue && "object" === ("undefined" === typeof fromValue ? "undefined" : _typeof(fromValue))) if (Array.isArray(fromValue)) {
                var mergeType = mergeInfo[key] || "merge";
                to[key] = combineArrays(to[key] || [], fromValue, mergeType);
            } else to[key] = _.merge(to[key] || {}, fromValue); else to[key] = fromValue;
        });
    }
    function combineArrays(leftValue, rightValue, mergeType) {
        switch (mergeType) {
          case "overwrite":
            return rightValue;

          case "insertFirst":
            return rightValue.concat(leftValue);

          case "insertLast":
            return leftValue.concat(rightValue);

          default:
            return _.assign(leftValue, rightValue);
        }
    }
}, function(module, exports) {
    var traverse = module.exports = function(obj) {
        return new Traverse(obj);
    };
    function Traverse(obj) {
        this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
        var node = this.value;
        for (var i = 0; i < ps.length; i++) {
            var key = ps[i];
            if (!node || !hasOwnProperty.call(node, key)) {
                node = void 0;
                break;
            }
            node = node[key];
        }
        return node;
    };
    Traverse.prototype.has = function(ps) {
        var node = this.value;
        for (var i = 0; i < ps.length; i++) {
            var key = ps[i];
            if (!node || !hasOwnProperty.call(node, key)) return false;
            node = node[key];
        }
        return true;
    };
    Traverse.prototype.set = function(ps, value) {
        var node = this.value;
        for (var i = 0; i < ps.length - 1; i++) {
            var key = ps[i];
            if (!hasOwnProperty.call(node, key)) node[key] = {};
            node = node[key];
        }
        node[ps[i]] = value;
        return value;
    };
    Traverse.prototype.map = function(cb) {
        return walk(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
        this.value = walk(this.value, cb, false);
        return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
        var skip = 1 === arguments.length;
        var acc = skip ? this.value : init;
        this.forEach(function(x) {
            if (!this.isRoot || !skip) acc = cb.call(this, acc, x);
        });
        return acc;
    };
    Traverse.prototype.paths = function() {
        var acc = [];
        this.forEach(function(x) {
            acc.push(this.path);
        });
        return acc;
    };
    Traverse.prototype.nodes = function() {
        var acc = [];
        this.forEach(function(x) {
            acc.push(this.node);
        });
        return acc;
    };
    Traverse.prototype.clone = function() {
        var parents = [], nodes = [];
        return function clone(src) {
            for (var i = 0; i < parents.length; i++) if (parents[i] === src) return nodes[i];
            if ("object" === typeof src && null !== src) {
                var dst = copy(src);
                parents.push(src);
                nodes.push(dst);
                forEach(objectKeys(src), function(key) {
                    dst[key] = clone(src[key]);
                });
                parents.pop();
                nodes.pop();
                return dst;
            } else return src;
        }(this.value);
    };
    function walk(root, cb, immutable) {
        var path = [];
        var parents = [];
        var alive = true;
        return function walker(node_) {
            var node = immutable ? copy(node_) : node_;
            var modifiers = {};
            var keepGoing = true;
            var state = {
                node: node,
                node_: node_,
                path: [].concat(path),
                parent: parents[parents.length - 1],
                parents: parents,
                key: path.slice(-1)[0],
                isRoot: 0 === path.length,
                level: path.length,
                circular: null,
                update: function(x, stopHere) {
                    if (!state.isRoot) state.parent.node[state.key] = x;
                    state.node = x;
                    if (stopHere) keepGoing = false;
                },
                delete: function(stopHere) {
                    delete state.parent.node[state.key];
                    if (stopHere) keepGoing = false;
                },
                remove: function(stopHere) {
                    if (isArray(state.parent.node)) state.parent.node.splice(state.key, 1); else delete state.parent.node[state.key];
                    if (stopHere) keepGoing = false;
                },
                keys: null,
                before: function(f) {
                    modifiers.before = f;
                },
                after: function(f) {
                    modifiers.after = f;
                },
                pre: function(f) {
                    modifiers.pre = f;
                },
                post: function(f) {
                    modifiers.post = f;
                },
                stop: function() {
                    alive = false;
                },
                block: function() {
                    keepGoing = false;
                }
            };
            if (!alive) return state;
            function updateState() {
                if ("object" === typeof state.node && null !== state.node) {
                    if (!state.keys || state.node_ !== state.node) state.keys = objectKeys(state.node);
                    state.isLeaf = 0 == state.keys.length;
                    for (var i = 0; i < parents.length; i++) if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                } else {
                    state.isLeaf = true;
                    state.keys = null;
                }
                state.notLeaf = !state.isLeaf;
                state.notRoot = !state.isRoot;
            }
            updateState();
            var ret = cb.call(state, state.node);
            if (void 0 !== ret && state.update) state.update(ret);
            if (modifiers.before) modifiers.before.call(state, state.node);
            if (!keepGoing) return state;
            if ("object" == typeof state.node && null !== state.node && !state.circular) {
                parents.push(state);
                updateState();
                forEach(state.keys, function(key, i) {
                    path.push(key);
                    if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                    var child = walker(state.node[key]);
                    if (immutable && hasOwnProperty.call(state.node, key)) state.node[key] = child.node;
                    child.isLast = i == state.keys.length - 1;
                    child.isFirst = 0 == i;
                    if (modifiers.post) modifiers.post.call(state, child);
                    path.pop();
                });
                parents.pop();
            }
            if (modifiers.after) modifiers.after.call(state, state.node);
            return state;
        }(root).node;
    }
    function copy(src) {
        if ("object" === typeof src && null !== src) {
            var dst;
            if (isArray(src)) dst = []; else if (isDate(src)) dst = new Date(src.getTime ? src.getTime() : src); else if (isRegExp(src)) dst = new RegExp(src); else if (isError(src)) dst = {
                message: src.message
            }; else if (isBoolean(src)) dst = new Boolean(src); else if (isNumber(src)) dst = new Number(src); else if (isString(src)) dst = new String(src); else if (Object.create && Object.getPrototypeOf) dst = Object.create(Object.getPrototypeOf(src)); else if (src.constructor === Object) dst = {}; else {
                var proto = src.constructor && src.constructor.prototype || src.__proto__ || {};
                var T = function() {};
                T.prototype = proto;
                dst = new T();
            }
            forEach(objectKeys(src), function(key) {
                dst[key] = src[key];
            });
            return dst;
        } else return src;
    }
    var objectKeys = Object.keys || function(obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    };
    function toS(obj) {
        return Object.prototype.toString.call(obj);
    }
    function isDate(obj) {
        return "[object Date]" === toS(obj);
    }
    function isRegExp(obj) {
        return "[object RegExp]" === toS(obj);
    }
    function isError(obj) {
        return "[object Error]" === toS(obj);
    }
    function isBoolean(obj) {
        return "[object Boolean]" === toS(obj);
    }
    function isNumber(obj) {
        return "[object Number]" === toS(obj);
    }
    function isString(obj) {
        return "[object String]" === toS(obj);
    }
    var isArray = Array.isArray || function(xs) {
        return "[object Array]" === Object.prototype.toString.call(xs);
    };
    var forEach = function(xs, fn) {
        if (xs.forEach) return xs.forEach(fn); else for (var i = 0; i < xs.length; i++) fn(xs[i], i, xs);
    };
    forEach(objectKeys(Traverse.prototype), function(key) {
        traverse[key] = function(obj) {
            var args = [].slice.call(arguments, 1);
            var t = new Traverse(obj);
            return t[key].apply(t, args);
        };
    });
    var hasOwnProperty = Object.hasOwnProperty || function(obj, key) {
        return key in obj;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var channel = __webpack_require__(27);
    var REMOTE_BRANDING_SETTING_NAME = "remoteBrandingData";
    exports.getData = function() {
        return settings.get(REMOTE_BRANDING_SETTING_NAME) || {};
    };
    exports.setData = function(config) {
        settings.set(REMOTE_BRANDING_SETTING_NAME, config);
        exports.onUpdated.dispatch(config);
    };
    exports.onUpdated = channel.create("branding.remote.storage.onUpdated");
}, function(module, exports, __webpack_require__) {
    "use strict";
    var pick = __webpack_require__(75);
    var cache = {};
    var screenshotFileds = [ "screenshotImage", "screenshotBgColor", "screenshotFontColor", "screenshotUpdateTime", "screenshotFsPath" ];
    exports.updateFromThumbs = function(thumbs) {
        thumbs.forEach(function(thumb) {
            if (thumb.screenshotImage) exports.set(thumb.url, pick(thumb, screenshotFileds));
        });
    };
    exports.get = function(url) {
        return cache[url];
    };
    exports.set = function(url, data) {
        cache[url] = data;
    };
    exports.remove = function(url) {
        delete cache[url];
    };
    exports.clear = function() {
        cache = {};
    };
    exports.forEach = function(fn) {
        Object.keys(cache).forEach(fn);
    };
    exports.getFirstMatch = function(urls) {
        for (var i = 0; i < urls.length; i++) {
            var cachedData = exports.get(urls[i]);
            if (cachedData) return cachedData;
        }
        return null;
    };
}, function(module, exports) {
    "use strict";
    exports.type = function(instance, Class, message) {
        if (!(instance instanceof Class)) throw new Error(message);
    };
    exports.notEmpty = function(value, message) {
        if (!value) throw new Error(message);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _ = __webpack_require__(91);
    var asyncLib = __webpack_require__(209);
    var database = __webpack_require__(295);
    var Differ = __webpack_require__(298);
    var Thumb = __webpack_require__(271);
    var logger = __webpack_require__(5).create("Сollection storage");
    var TABLE_NAME = "thumbs_shown";
    var DUMP_DELAY_MS = 200;
    var differ;
    module.exports = {
        init: function(collection) {
            collection.onChanged.addListener(_.debounce(this.save.bind(this), DUMP_DELAY_MS));
        },
        load: function(callback) {
            database.get(TABLE_NAME, {}, function(err, records) {
                if (err) callback(err); else {
                    records = records || [];
                    sort(records);
                    differ = new Differ(records);
                    var thumbs = constructThumbs(records);
                    callback(null, thumbs);
                }
            });
        },
        save: function(collection) {
            if (!differ) differ = new Differ([]);
            var items = collection.items.map(function(thumb, position) {
                var json = thumb.toJSON();
                json.position = position;
                return json;
            });
            if (0 === items.length) {
                logger.error("Try save empty array, aborting..");
                return;
            }
            var diff = differ.update(items);
            var upsertPositions = diff.changed.concat(diff.added);
            var tasks = [].concat(diff.removed.length ? [ getDeleteTask(diff.removed) ] : []).concat(upsertPositions.length ? [ getUpsertTask(upsertPositions) ] : []);
            if (tasks.length) {
                logger.info("Saving...");
                asyncLib.waterfall(tasks, function() {
                    logger.info("Save complete");
                });
            }
        }
    };
    function sort(records) {
        records.sort(function(a, b) {
            return a.position - b.position;
        });
    }
    function constructThumbs(records) {
        var thumbs = [];
        records.forEach(function(record) {
            try {
                var thumb = Thumb.fromJSON(record);
                thumbs.push(thumb);
            } catch (e) {
                logger.warn(e.message + " for db record: %i %j", record.position, record);
            }
        });
        return thumbs;
    }
    function getUpsertTask(positions) {
        return function(callback) {
            var items = positions.map(function(position) {
                return differ.collection[position];
            });
            database.upsert(TABLE_NAME, items, function(err) {
                if (err) logger.warn("Can not upsert thumbs %s", err.message); else logger.info("Thumbs were upserted to %s", positions.join(", "));
                callback();
            });
        };
    }
    function getDeleteTask(positions) {
        return function(callback) {
            database.delete(TABLE_NAME, positions, function(err) {
                if (err) logger.warn("Can not delete thumbs %s", err.message); else logger.info("Thumbs were deleted from %s", positions.join(", "));
                callback();
            });
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var sklad = __webpack_require__(296);
    var utils = __webpack_require__(30);
    var structure = __webpack_require__(297);
    var pluck = __webpack_require__(156);
    var logger = __webpack_require__(5).create("Database");
    var db;
    var DbError = function(err) {
        this.message = err.name + ": " + err.message;
    };
    DbError.prototype = new Error();
    function ensureDb() {
        if (!db) throw new Error("Database not available");
    }
    var api = module.exports = {
        open: function(callback) {
            logger.info("Opening %s...", structure.name);
            sklad.open(structure.name, structure).then(function(database) {
                if (!database) {
                    logger.error("Opened db object is empty %s", structure.name);
                    callback(new Error());
                } else {
                    logger.info("Successfully opened %s", structure.name);
                    db = database;
                    callback(null, db);
                }
            }).catch(function(err) {
                logger.error("Error while opening db %s %s", err.message, structure.name);
                callback(err);
            });
        },
        conn: function() {
            ensureDb();
            return db;
        },
        deleteDatabase: function(callback) {
            callback = callback || utils.noop;
            return sklad.deleteDatabase(structure.name).then(utils.noargs(callback), callback);
        },
        clearAndInsert: function(table, items, callback) {
            ensureDb();
            callback = callback || utils.noop;
            db.clear(table).then(function() {
                api.upsert(table, items, callback);
            }).catch(callback);
        },
        upsert: function(table, items, callback) {
            ensureDb();
            callback = callback || utils.noop;
            var data = prepareData(table, items);
            db.upsert(data).then(utils.noargs(callback), callback);
        },
        delete: function(table, keys, callback) {
            ensureDb();
            callback = callback || utils.noop;
            var data = prepareData(table, keys);
            db.delete(data).then(utils.noargs(callback), callback);
        },
        get: function(table, options, callback) {
            ensureDb();
            db.get(table, options).then(function(records) {
                var result = pluck(records, "value");
                callback(null, result);
            }).catch(callback);
        },
        DbError: DbError
    };
    function prepareData(table, items) {
        var data = {};
        data[table] = Array.isArray(items) ? items : [ items ];
        return data;
    }
}, function(module, exports, __webpack_require__) {
    !function(t, n) {
        true ? module.exports = n() : "function" == typeof define && define.amd ? define([], n) : "object" == typeof exports ? exports.sklad = n() : t.sklad = n();
    }(this, function() {
        return function(t) {
            function n(e) {
                if (r[e]) return r[e].exports;
                var o = r[e] = {
                    i: e,
                    l: !1,
                    exports: {}
                };
                return t[e].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
            }
            var r = {};
            return n.m = t, n.c = r, n.d = function(t, r, e) {
                n.o(t, r) || Object.defineProperty(t, r, {
                    configurable: !1,
                    enumerable: !0,
                    get: e
                });
            }, n.n = function(t) {
                var r = t && t.__esModule ? function() {
                    return t.default;
                } : function() {
                    return t;
                };
                return n.d(r, "a", r), r;
            }, n.o = function(t, n) {
                return Object.prototype.hasOwnProperty.call(t, n);
            }, n.p = "", n(n.s = 114);
        }([ function(t, n, r) {
            var e = r(2), o = r(24), i = r(11), u = r(12), c = r(25), a = function(t, n, r) {
                var f, s, l, v, h = t & a.F, p = t & a.G, d = t & a.S, y = t & a.P, g = t & a.B, b = p ? e : d ? e[n] || (e[n] = {}) : (e[n] || {}).prototype, m = p ? o : o[n] || (o[n] = {}), x = m.prototype || (m.prototype = {});
                p && (r = n);
                for (f in r) s = !h && b && void 0 !== b[f], l = (s ? b : r)[f], v = g && s ? c(l, e) : y && "function" == typeof l ? c(Function.call, l) : l, 
                b && u(b, f, l, t & a.U), m[f] != l && i(m, f, v), y && x[f] != l && (x[f] = l);
            };
            e.core = o, a.F = 1, a.G = 2, a.S = 4, a.P = 8, a.B = 16, a.W = 32, a.U = 64, a.R = 128, 
            t.exports = a;
        }, function(t, n, r) {
            var e = r(4);
            t.exports = function(t) {
                if (!e(t)) throw TypeError(t + " is not an object!");
                return t;
            };
        }, function(t, n) {
            var r = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
            "number" == typeof __g && (__g = r);
        }, function(t, n) {
            t.exports = function(t) {
                try {
                    return !!t();
                } catch (t) {
                    return !0;
                }
            };
        }, function(t, n) {
            t.exports = function(t) {
                return "object" == typeof t ? null !== t : "function" == typeof t;
            };
        }, function(t, n, r) {
            var e = r(48)("wks"), o = r(31), i = r(2).Symbol, u = "function" == typeof i;
            (t.exports = function(t) {
                return e[t] || (e[t] = u && i[t] || (u ? i : o)("Symbol." + t));
            }).store = e;
        }, function(t, n, r) {
            t.exports = !r(3)(function() {
                return 7 != Object.defineProperty({}, "a", {
                    get: function() {
                        return 7;
                    }
                }).a;
            });
        }, function(t, n, r) {
            var e = r(1), o = r(86), i = r(21), u = Object.defineProperty;
            n.f = r(6) ? Object.defineProperty : function(t, n, r) {
                if (e(t), n = i(n, !0), e(r), o) try {
                    return u(t, n, r);
                } catch (t) {}
                if ("get" in r || "set" in r) throw TypeError("Accessors not supported!");
                return "value" in r && (t[n] = r.value), t;
            };
        }, function(t, n, r) {
            var e = r(30), o = Math.min;
            t.exports = function(t) {
                return t > 0 ? o(e(t), 9007199254740991) : 0;
            };
        }, function(t, n, r) {
            var e = r(19);
            t.exports = function(t) {
                return Object(e(t));
            };
        }, function(t, n) {
            var r = {}.hasOwnProperty;
            t.exports = function(t, n) {
                return r.call(t, n);
            };
        }, function(t, n, r) {
            var e = r(7), o = r(28);
            t.exports = r(6) ? function(t, n, r) {
                return e.f(t, n, o(1, r));
            } : function(t, n, r) {
                return t[n] = r, t;
            };
        }, function(t, n, r) {
            var e = r(2), o = r(11), i = r(10), u = r(31)("src"), c = Function.toString, a = ("" + c).split("toString");
            r(24).inspectSource = function(t) {
                return c.call(t);
            }, (t.exports = function(t, n, r, c) {
                var f = "function" == typeof r;
                f && (i(r, "name") || o(r, "name", n)), t[n] !== r && (f && (i(r, u) || o(r, u, t[n] ? "" + t[n] : a.join(String(n)))), 
                t === e ? t[n] = r : c ? t[n] ? t[n] = r : o(t, n, r) : (delete t[n], o(t, n, r)));
            })(Function.prototype, "toString", function() {
                return "function" == typeof this && this[u] || c.call(this);
            });
        }, function(t, n) {
            t.exports = function(t) {
                if ("function" != typeof t) throw TypeError(t + " is not a function!");
                return t;
            };
        }, function(t, n, r) {
            var e = r(45), o = r(19);
            t.exports = function(t) {
                return e(o(t));
            };
        }, function(t, n, r) {
            var e = r(0), o = r(3), i = r(19), u = /"/g, c = function(t, n, r, e) {
                var o = String(i(t)), c = "<" + n;
                return "" !== r && (c += " " + r + '="' + String(e).replace(u, "&quot;") + '"'), 
                c + ">" + o + "</" + n + ">";
            };
            t.exports = function(t, n) {
                var r = {};
                r[t] = n(c), e(e.P + e.F * o(function() {
                    var n = ""[t]('"');
                    return n !== n.toLowerCase() || n.split('"').length > 3;
                }), "String", r);
            };
        }, function(t, n, r) {
            var e = r(46), o = r(28), i = r(14), u = r(21), c = r(10), a = r(86), f = Object.getOwnPropertyDescriptor;
            n.f = r(6) ? f : function(t, n) {
                if (t = i(t), n = u(n, !0), a) try {
                    return f(t, n);
                } catch (t) {}
                if (c(t, n)) return o(!e.f.call(t, n), t[n]);
            };
        }, function(t, n, r) {
            var e = r(10), o = r(9), i = r(61)("IE_PROTO"), u = Object.prototype;
            t.exports = Object.getPrototypeOf || function(t) {
                return t = o(t), e(t, i) ? t[i] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null;
            };
        }, function(t, n) {
            var r = {}.toString;
            t.exports = function(t) {
                return r.call(t).slice(8, -1);
            };
        }, function(t, n) {
            t.exports = function(t) {
                if (void 0 == t) throw TypeError("Can't call method on  " + t);
                return t;
            };
        }, function(t, n, r) {
            var e = r(3);
            t.exports = function(t, n) {
                return !!t && e(function() {
                    n ? t.call(null, function() {}, 1) : t.call(null);
                });
            };
        }, function(t, n, r) {
            var e = r(4);
            t.exports = function(t, n) {
                if (!e(t)) return t;
                var r, o;
                if (n && "function" == typeof (r = t.toString) && !e(o = r.call(t))) return o;
                if ("function" == typeof (r = t.valueOf) && !e(o = r.call(t))) return o;
                if (!n && "function" == typeof (r = t.toString) && !e(o = r.call(t))) return o;
                throw TypeError("Can't convert object to primitive value");
            };
        }, function(t, n, r) {
            var e = r(0), o = r(24), i = r(3);
            t.exports = function(t, n) {
                var r = (o.Object || {})[t] || Object[t], u = {};
                u[t] = n(r), e(e.S + e.F * i(function() {
                    r(1);
                }), "Object", u);
            };
        }, function(t, n, r) {
            var e = r(25), o = r(45), i = r(9), u = r(8), c = r(206);
            t.exports = function(t, n) {
                var r = 1 == t, a = 2 == t, f = 3 == t, s = 4 == t, l = 6 == t, v = 5 == t || l, h = n || c;
                return function(n, c, p) {
                    for (var d, y, g = i(n), b = o(g), m = e(c, p, 3), x = u(b.length), w = 0, S = r ? h(n, x) : a ? h(n, 0) : void 0; x > w; w++) if ((v || w in b) && (d = b[w], 
                    y = m(d, w, g), t)) if (r) S[w] = y; else if (y) switch (t) {
                      case 3:
                        return !0;

                      case 5:
                        return d;

                      case 6:
                        return w;

                      case 2:
                        S.push(d);
                    } else if (s) return !1;
                    return l ? -1 : f || s ? s : S;
                };
            };
        }, function(t, n) {
            var r = t.exports = {
                version: "2.4.0"
            };
            "number" == typeof __e && (__e = r);
        }, function(t, n, r) {
            var e = r(13);
            t.exports = function(t, n, r) {
                if (e(t), void 0 === n) return t;
                switch (r) {
                  case 1:
                    return function(r) {
                        return t.call(n, r);
                    };

                  case 2:
                    return function(r, e) {
                        return t.call(n, r, e);
                    };

                  case 3:
                    return function(r, e, o) {
                        return t.call(n, r, e, o);
                    };
                }
                return function() {
                    return t.apply(n, arguments);
                };
            };
        }, function(t, n, r) {
            "use strict";
            if (r(6)) {
                var e = r(32), o = r(2), i = r(3), u = r(0), c = r(57), a = r(84), f = r(25), s = r(38), l = r(28), v = r(11), h = r(39), p = r(30), d = r(8), y = r(34), g = r(21), b = r(10), m = r(92), x = r(47), w = r(4), S = r(9), _ = r(76), E = r(35), O = r(17), P = r(36).f, A = r(78), j = r(31), I = r(5), N = r(23), F = r(49), R = r(81), M = r(80), T = r(42), k = r(53), D = r(37), L = r(79), C = r(101), B = r(7), U = r(16), W = B.f, V = U.f, G = o.RangeError, Y = o.TypeError, z = o.Uint8Array, K = Array.prototype, J = a.ArrayBuffer, q = a.DataView, Q = N(0), X = N(2), $ = N(3), H = N(4), Z = N(5), tt = N(6), nt = F(!0), rt = F(!1), et = M.values, ot = M.keys, it = M.entries, ut = K.lastIndexOf, ct = K.reduce, at = K.reduceRight, ft = K.join, st = K.sort, lt = K.slice, vt = K.toString, ht = K.toLocaleString, pt = I("iterator"), dt = I("toStringTag"), yt = j("typed_constructor"), gt = j("def_constructor"), bt = c.CONSTR, mt = c.TYPED, xt = c.VIEW, wt = N(1, function(t, n) {
                    return At(R(t, t[gt]), n);
                }), St = i(function() {
                    return 1 === new z(new Uint16Array([ 1 ]).buffer)[0];
                }), _t = !!z && !!z.prototype.set && i(function() {
                    new z(1).set({});
                }), Et = function(t, n) {
                    if (void 0 === t) throw Y("Wrong length!");
                    var r = +t, e = d(t);
                    if (n && !m(r, e)) throw G("Wrong length!");
                    return e;
                }, Ot = function(t, n) {
                    var r = p(t);
                    if (r < 0 || r % n) throw G("Wrong offset!");
                    return r;
                }, Pt = function(t) {
                    if (w(t) && mt in t) return t;
                    throw Y(t + " is not a typed array!");
                }, At = function(t, n) {
                    if (!(w(t) && yt in t)) throw Y("It is not a typed array constructor!");
                    return new t(n);
                }, jt = function(t, n) {
                    return It(R(t, t[gt]), n);
                }, It = function(t, n) {
                    for (var r = 0, e = n.length, o = At(t, e); e > r; ) o[r] = n[r++];
                    return o;
                }, Nt = function(t, n, r) {
                    W(t, n, {
                        get: function() {
                            return this._d[r];
                        }
                    });
                }, Ft = function(t) {
                    var n, r, e, o, i, u, c = S(t), a = arguments.length, s = a > 1 ? arguments[1] : void 0, l = void 0 !== s, v = A(c);
                    if (void 0 != v && !_(v)) {
                        for (u = v.call(c), e = [], n = 0; !(i = u.next()).done; n++) e.push(i.value);
                        c = e;
                    }
                    for (l && a > 2 && (s = f(s, arguments[2], 2)), n = 0, r = d(c.length), o = At(this, r); r > n; n++) o[n] = l ? s(c[n], n) : c[n];
                    return o;
                }, Rt = function() {
                    for (var t = 0, n = arguments.length, r = At(this, n); n > t; ) r[t] = arguments[t++];
                    return r;
                }, Mt = !!z && i(function() {
                    ht.call(new z(1));
                }), Tt = function() {
                    return ht.apply(Mt ? lt.call(Pt(this)) : Pt(this), arguments);
                }, kt = {
                    copyWithin: function(t, n) {
                        return C.call(Pt(this), t, n, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    every: function(t) {
                        return H(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    fill: function(t) {
                        return L.apply(Pt(this), arguments);
                    },
                    filter: function(t) {
                        return jt(this, X(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0));
                    },
                    find: function(t) {
                        return Z(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    findIndex: function(t) {
                        return tt(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    forEach: function(t) {
                        Q(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    indexOf: function(t) {
                        return rt(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    includes: function(t) {
                        return nt(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    join: function(t) {
                        return ft.apply(Pt(this), arguments);
                    },
                    lastIndexOf: function(t) {
                        return ut.apply(Pt(this), arguments);
                    },
                    map: function(t) {
                        return wt(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    reduce: function(t) {
                        return ct.apply(Pt(this), arguments);
                    },
                    reduceRight: function(t) {
                        return at.apply(Pt(this), arguments);
                    },
                    reverse: function() {
                        for (var t, n = this, r = Pt(n).length, e = Math.floor(r / 2), o = 0; o < e; ) t = n[o], 
                        n[o++] = n[--r], n[r] = t;
                        return n;
                    },
                    some: function(t) {
                        return $(Pt(this), t, arguments.length > 1 ? arguments[1] : void 0);
                    },
                    sort: function(t) {
                        return st.call(Pt(this), t);
                    },
                    subarray: function(t, n) {
                        var r = Pt(this), e = r.length, o = y(t, e);
                        return new (R(r, r[gt]))(r.buffer, r.byteOffset + o * r.BYTES_PER_ELEMENT, d((void 0 === n ? e : y(n, e)) - o));
                    }
                }, Dt = function(t, n) {
                    return jt(this, lt.call(Pt(this), t, n));
                }, Lt = function(t) {
                    Pt(this);
                    var n = Ot(arguments[1], 1), r = this.length, e = S(t), o = d(e.length), i = 0;
                    if (o + n > r) throw G("Wrong length!");
                    for (;i < o; ) this[n + i] = e[i++];
                }, Ct = {
                    entries: function() {
                        return it.call(Pt(this));
                    },
                    keys: function() {
                        return ot.call(Pt(this));
                    },
                    values: function() {
                        return et.call(Pt(this));
                    }
                }, Bt = function(t, n) {
                    return w(t) && t[mt] && "symbol" != typeof n && n in t && String(+n) == String(n);
                }, Ut = function(t, n) {
                    return Bt(t, n = g(n, !0)) ? l(2, t[n]) : V(t, n);
                }, Wt = function(t, n, r) {
                    return !(Bt(t, n = g(n, !0)) && w(r) && b(r, "value")) || b(r, "get") || b(r, "set") || r.configurable || b(r, "writable") && !r.writable || b(r, "enumerable") && !r.enumerable ? W(t, n, r) : (t[n] = r.value, 
                    t);
                };
                bt || (U.f = Ut, B.f = Wt), u(u.S + u.F * !bt, "Object", {
                    getOwnPropertyDescriptor: Ut,
                    defineProperty: Wt
                }), i(function() {
                    vt.call({});
                }) && (vt = ht = function() {
                    return ft.call(this);
                });
                var Vt = h({}, kt);
                h(Vt, Ct), v(Vt, pt, Ct.values), h(Vt, {
                    slice: Dt,
                    set: Lt,
                    constructor: function() {},
                    toString: vt,
                    toLocaleString: Tt
                }), Nt(Vt, "buffer", "b"), Nt(Vt, "byteOffset", "o"), Nt(Vt, "byteLength", "l"), 
                Nt(Vt, "length", "e"), W(Vt, dt, {
                    get: function() {
                        return this[mt];
                    }
                }), t.exports = function(t, n, r, a) {
                    a = !!a;
                    var f = t + (a ? "Clamped" : "") + "Array", l = "Uint8Array" != f, h = "get" + t, p = "set" + t, y = o[f], g = y || {}, b = y && O(y), m = !y || !c.ABV, S = {}, _ = y && y.prototype, A = function(t, r) {
                        var e = t._d;
                        return e.v[h](r * n + e.o, St);
                    }, j = function(t, r, e) {
                        var o = t._d;
                        a && (e = (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : 255 & e), o.v[p](r * n + o.o, e, St);
                    }, I = function(t, n) {
                        W(t, n, {
                            get: function() {
                                return A(this, n);
                            },
                            set: function(t) {
                                return j(this, n, t);
                            },
                            enumerable: !0
                        });
                    };
                    m ? (y = r(function(t, r, e, o) {
                        s(t, y, f, "_d");
                        var i, u, c, a, l = 0, h = 0;
                        if (w(r)) {
                            if (!(r instanceof J || "ArrayBuffer" == (a = x(r)) || "SharedArrayBuffer" == a)) return mt in r ? It(y, r) : Ft.call(y, r);
                            i = r, h = Ot(e, n);
                            var p = r.byteLength;
                            if (void 0 === o) {
                                if (p % n) throw G("Wrong length!");
                                if ((u = p - h) < 0) throw G("Wrong length!");
                            } else if ((u = d(o) * n) + h > p) throw G("Wrong length!");
                            c = u / n;
                        } else c = Et(r, !0), u = c * n, i = new J(u);
                        for (v(t, "_d", {
                            b: i,
                            o: h,
                            l: u,
                            e: c,
                            v: new q(i)
                        }); l < c; ) I(t, l++);
                    }), _ = y.prototype = E(Vt), v(_, "constructor", y)) : k(function(t) {
                        new y(null), new y(t);
                    }, !0) || (y = r(function(t, r, e, o) {
                        s(t, y, f);
                        var i;
                        return w(r) ? r instanceof J || "ArrayBuffer" == (i = x(r)) || "SharedArrayBuffer" == i ? void 0 !== o ? new g(r, Ot(e, n), o) : void 0 !== e ? new g(r, Ot(e, n)) : new g(r) : mt in r ? It(y, r) : Ft.call(y, r) : new g(Et(r, l));
                    }), Q(b !== Function.prototype ? P(g).concat(P(b)) : P(g), function(t) {
                        t in y || v(y, t, g[t]);
                    }), y.prototype = _, e || (_.constructor = y));
                    var N = _[pt], F = !!N && ("values" == N.name || void 0 == N.name), R = Ct.values;
                    v(y, yt, !0), v(_, mt, f), v(_, xt, !0), v(_, gt, y), (a ? new y(1)[dt] == f : dt in _) || W(_, dt, {
                        get: function() {
                            return f;
                        }
                    }), S[f] = y, u(u.G + u.W + u.F * (y != g), S), u(u.S, f, {
                        BYTES_PER_ELEMENT: n,
                        from: Ft,
                        of: Rt
                    }), "BYTES_PER_ELEMENT" in _ || v(_, "BYTES_PER_ELEMENT", n), u(u.P, f, kt), D(f), 
                    u(u.P + u.F * _t, f, {
                        set: Lt
                    }), u(u.P + u.F * !F, f, Ct), u(u.P + u.F * (_.toString != vt), f, {
                        toString: vt
                    }), u(u.P + u.F * i(function() {
                        new y(1).slice();
                    }), f, {
                        slice: Dt
                    }), u(u.P + u.F * (i(function() {
                        return [ 1, 2 ].toLocaleString() != new y([ 1, 2 ]).toLocaleString();
                    }) || !i(function() {
                        _.toLocaleString.call([ 1, 2 ]);
                    })), f, {
                        toLocaleString: Tt
                    }), T[f] = F ? N : R, e || F || v(_, pt, R);
                };
            } else t.exports = function() {};
        }, function(t, n, r) {
            var e = r(104), o = r(0), i = r(48)("metadata"), u = i.store || (i.store = new (r(107))()), c = function(t, n, r) {
                var o = u.get(t);
                if (!o) {
                    if (!r) return;
                    u.set(t, o = new e());
                }
                var i = o.get(n);
                if (!i) {
                    if (!r) return;
                    o.set(n, i = new e());
                }
                return i;
            }, a = function(t, n, r) {
                var e = c(n, r, !1);
                return void 0 !== e && e.has(t);
            }, f = function(t, n, r) {
                var e = c(n, r, !1);
                return void 0 === e ? void 0 : e.get(t);
            }, s = function(t, n, r, e) {
                c(r, e, !0).set(t, n);
            }, l = function(t, n) {
                var r = c(t, n, !1), e = [];
                return r && r.forEach(function(t, n) {
                    e.push(n);
                }), e;
            }, v = function(t) {
                return void 0 === t || "symbol" == typeof t ? t : String(t);
            }, h = function(t) {
                o(o.S, "Reflect", t);
            };
            t.exports = {
                store: u,
                map: c,
                has: a,
                get: f,
                set: s,
                keys: l,
                key: v,
                exp: h
            };
        }, function(t, n) {
            t.exports = function(t, n) {
                return {
                    enumerable: !(1 & t),
                    configurable: !(2 & t),
                    writable: !(4 & t),
                    value: n
                };
            };
        }, function(t, n, r) {
            var e = r(31)("meta"), o = r(4), i = r(10), u = r(7).f, c = 0, a = Object.isExtensible || function() {
                return !0;
            }, f = !r(3)(function() {
                return a(Object.preventExtensions({}));
            }), s = function(t) {
                u(t, e, {
                    value: {
                        i: "O" + ++c,
                        w: {}
                    }
                });
            }, l = function(t, n) {
                if (!o(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                if (!i(t, e)) {
                    if (!a(t)) return "F";
                    if (!n) return "E";
                    s(t);
                }
                return t[e].i;
            }, v = function(t, n) {
                if (!i(t, e)) {
                    if (!a(t)) return !0;
                    if (!n) return !1;
                    s(t);
                }
                return t[e].w;
            }, h = function(t) {
                return f && p.NEED && a(t) && !i(t, e) && s(t), t;
            }, p = t.exports = {
                KEY: e,
                NEED: !1,
                fastKey: l,
                getWeak: v,
                onFreeze: h
            };
        }, function(t, n) {
            var r = Math.ceil, e = Math.floor;
            t.exports = function(t) {
                return isNaN(t = +t) ? 0 : (t > 0 ? e : r)(t);
            };
        }, function(t, n) {
            var r = 0, e = Math.random();
            t.exports = function(t) {
                return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++r + e).toString(36));
            };
        }, function(t, n) {
            t.exports = !1;
        }, function(t, n, r) {
            var e = r(88), o = r(62);
            t.exports = Object.keys || function(t) {
                return e(t, o);
            };
        }, function(t, n, r) {
            var e = r(30), o = Math.max, i = Math.min;
            t.exports = function(t, n) {
                return t = e(t), t < 0 ? o(t + n, 0) : i(t, n);
            };
        }, function(t, n, r) {
            var e = r(1), o = r(89), i = r(62), u = r(61)("IE_PROTO"), c = function() {}, a = function() {
                var t, n = r(59)("iframe"), e = i.length;
                for (n.style.display = "none", r(64).appendChild(n), n.src = "javascript:", t = n.contentWindow.document, 
                t.open(), t.write("<script>document.F=Object</script>"), t.close(), a = t.F; e--; ) delete a.prototype[i[e]];
                return a();
            };
            t.exports = Object.create || function(t, n) {
                var r;
                return null !== t ? (c.prototype = e(t), r = new c(), c.prototype = null, r[u] = t) : r = a(), 
                void 0 === n ? r : o(r, n);
            };
        }, function(t, n, r) {
            var e = r(88), o = r(62).concat("length", "prototype");
            n.f = Object.getOwnPropertyNames || function(t) {
                return e(t, o);
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(2), o = r(7), i = r(6), u = r(5)("species");
            t.exports = function(t) {
                var n = e[t];
                i && n && !n[u] && o.f(n, u, {
                    configurable: !0,
                    get: function() {
                        return this;
                    }
                });
            };
        }, function(t, n) {
            t.exports = function(t, n, r, e) {
                if (!(t instanceof n) || void 0 !== e && e in t) throw TypeError(r + ": incorrect invocation!");
                return t;
            };
        }, function(t, n, r) {
            var e = r(12);
            t.exports = function(t, n, r) {
                for (var o in n) e(t, o, n[o], r);
                return t;
            };
        }, function(t, n, r) {
            var e = r(7).f, o = r(10), i = r(5)("toStringTag");
            t.exports = function(t, n, r) {
                t && !o(t = r ? t : t.prototype, i) && e(t, i, {
                    configurable: !0,
                    value: n
                });
            };
        }, function(t, n, r) {
            var e = r(0), o = r(19), i = r(3), u = r(66), c = "[" + u + "]", a = "​", f = RegExp("^" + c + c + "*"), s = RegExp(c + c + "*$"), l = function(t, n, r) {
                var o = {}, c = i(function() {
                    return !!u[t]() || a[t]() != a;
                }), f = o[t] = c ? n(v) : u[t];
                r && (o[r] = f), e(e.P + e.F * c, "String", o);
            }, v = l.trim = function(t, n) {
                return t = String(o(t)), 1 & n && (t = t.replace(f, "")), 2 & n && (t = t.replace(s, "")), 
                t;
            };
            t.exports = l;
        }, function(t, n) {
            t.exports = {};
        }, function(t, n, r) {
            var e = r(5)("unscopables"), o = Array.prototype;
            void 0 == o[e] && r(11)(o, e, {}), t.exports = function(t) {
                o[e][t] = !0;
            };
        }, function(t, n, r) {
            var e = r(25), o = r(99), i = r(76), u = r(1), c = r(8), a = r(78), f = {}, s = {}, n = t.exports = function(t, n, r, l, v) {
                var h, p, d, y, g = v ? function() {
                    return t;
                } : a(t), b = e(r, l, n ? 2 : 1), m = 0;
                if ("function" != typeof g) throw TypeError(t + " is not iterable!");
                if (i(g)) {
                    for (h = c(t.length); h > m; m++) if ((y = n ? b(u(p = t[m])[0], p[1]) : b(t[m])) === f || y === s) return y;
                } else for (d = g.call(t); !(p = d.next()).done; ) if ((y = o(d, b, p.value, n)) === f || y === s) return y;
            };
            n.BREAK = f, n.RETURN = s;
        }, function(t, n, r) {
            var e = r(18);
            t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
                return "String" == e(t) ? t.split("") : Object(t);
            };
        }, function(t, n) {
            n.f = {}.propertyIsEnumerable;
        }, function(t, n, r) {
            var e = r(18), o = r(5)("toStringTag"), i = "Arguments" == e(function() {
                return arguments;
            }()), u = function(t, n) {
                try {
                    return t[n];
                } catch (t) {}
            };
            t.exports = function(t) {
                var n, r, c;
                return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (r = u(n = Object(t), o)) ? r : i ? e(n) : "Object" == (c = e(n)) && "function" == typeof n.callee ? "Arguments" : c;
            };
        }, function(t, n, r) {
            var e = r(2), o = e["__core-js_shared__"] || (e["__core-js_shared__"] = {});
            t.exports = function(t) {
                return o[t] || (o[t] = {});
            };
        }, function(t, n, r) {
            var e = r(14), o = r(8), i = r(34);
            t.exports = function(t) {
                return function(n, r, u) {
                    var c, a = e(n), f = o(a.length), s = i(u, f);
                    if (t && r != r) {
                        for (;f > s; ) if ((c = a[s++]) != c) return !0;
                    } else for (;f > s; s++) if ((t || s in a) && a[s] === r) return t || s || 0;
                    return !t && -1;
                };
            };
        }, function(t, n) {
            n.f = Object.getOwnPropertySymbols;
        }, function(t, n) {
            t.exports = function(t, n, r) {
                var e = void 0 === r;
                switch (n.length) {
                  case 0:
                    return e ? t() : t.call(r);

                  case 1:
                    return e ? t(n[0]) : t.call(r, n[0]);

                  case 2:
                    return e ? t(n[0], n[1]) : t.call(r, n[0], n[1]);

                  case 3:
                    return e ? t(n[0], n[1], n[2]) : t.call(r, n[0], n[1], n[2]);

                  case 4:
                    return e ? t(n[0], n[1], n[2], n[3]) : t.call(r, n[0], n[1], n[2], n[3]);
                }
                return t.apply(r, n);
            };
        }, function(t, n, r) {
            var e = r(4), o = r(18), i = r(5)("match");
            t.exports = function(t) {
                var n;
                return e(t) && (void 0 !== (n = t[i]) ? !!n : "RegExp" == o(t));
            };
        }, function(t, n, r) {
            var e = r(5)("iterator"), o = !1;
            try {
                var i = [ 7 ][e]();
                i.return = function() {
                    o = !0;
                }, Array.from(i, function() {
                    throw 2;
                });
            } catch (t) {}
            t.exports = function(t, n) {
                if (!n && !o) return !1;
                var r = !1;
                try {
                    var i = [ 7 ], u = i[e]();
                    u.next = function() {
                        return {
                            done: r = !0
                        };
                    }, i[e] = function() {
                        return u;
                    }, t(i);
                } catch (t) {}
                return r;
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(1);
            t.exports = function() {
                var t = e(this), n = "";
                return t.global && (n += "g"), t.ignoreCase && (n += "i"), t.multiline && (n += "m"), 
                t.unicode && (n += "u"), t.sticky && (n += "y"), n;
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(11), o = r(12), i = r(3), u = r(19), c = r(5);
            t.exports = function(t, n, r) {
                var a = c(t), f = r(u, a, ""[t]), s = f[0], l = f[1];
                i(function() {
                    var n = {};
                    return n[a] = function() {
                        return 7;
                    }, 7 != ""[t](n);
                }) && (o(String.prototype, t, s), e(RegExp.prototype, a, 2 == n ? function(t, n) {
                    return l.call(t, this, n);
                } : function(t) {
                    return l.call(t, this);
                }));
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(2), o = r(0), i = r(12), u = r(39), c = r(29), a = r(44), f = r(38), s = r(4), l = r(3), v = r(53), h = r(40), p = r(67);
            t.exports = function(t, n, r, d, y, g) {
                var b = e[t], m = b, x = y ? "set" : "add", w = m && m.prototype, S = {}, _ = function(t) {
                    var n = w[t];
                    i(w, t, "delete" == t ? function(t) {
                        return !(g && !s(t)) && n.call(this, 0 === t ? 0 : t);
                    } : "has" == t ? function(t) {
                        return !(g && !s(t)) && n.call(this, 0 === t ? 0 : t);
                    } : "get" == t ? function(t) {
                        return g && !s(t) ? void 0 : n.call(this, 0 === t ? 0 : t);
                    } : "add" == t ? function(t) {
                        return n.call(this, 0 === t ? 0 : t), this;
                    } : function(t, r) {
                        return n.call(this, 0 === t ? 0 : t, r), this;
                    });
                };
                if ("function" == typeof m && (g || w.forEach && !l(function() {
                    new m().entries().next();
                }))) {
                    var E = new m(), O = E[x](g ? {} : -0, 1) != E, P = l(function() {
                        E.has(1);
                    }), A = v(function(t) {
                        new m(t);
                    }), j = !g && l(function() {
                        for (var t = new m(), n = 5; n--; ) t[x](n, n);
                        return !t.has(-0);
                    });
                    A || (m = n(function(n, r) {
                        f(n, m, t);
                        var e = p(new b(), n, m);
                        return void 0 != r && a(r, y, e[x], e), e;
                    }), m.prototype = w, w.constructor = m), (P || j) && (_("delete"), _("has"), y && _("get")), 
                    (j || O) && _(x), g && w.clear && delete w.clear;
                } else m = d.getConstructor(n, t, y, x), u(m.prototype, r), c.NEED = !0;
                return h(m, t), S[t] = m, o(o.G + o.W + o.F * (m != b), S), g || d.setStrong(m, t, y), 
                m;
            };
        }, function(t, n, r) {
            for (var e, o = r(2), i = r(11), u = r(31), c = u("typed_array"), a = u("view"), f = !(!o.ArrayBuffer || !o.DataView), s = f, l = 0, v = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); l < 9; ) (e = o[v[l++]]) ? (i(e.prototype, c, !0), 
            i(e.prototype, a, !0)) : s = !1;
            t.exports = {
                ABV: f,
                CONSTR: s,
                TYPED: c,
                VIEW: a
            };
        }, function(t, n, r) {
            t.exports = r(32) || !r(3)(function() {
                var t = Math.random();
                __defineSetter__.call(null, t, function() {}), delete r(2)[t];
            });
        }, function(t, n, r) {
            var e = r(4), o = r(2).document, i = e(o) && e(o.createElement);
            t.exports = function(t) {
                return i ? o.createElement(t) : {};
            };
        }, function(t, n, r) {
            var e = r(2), o = r(24), i = r(32), u = r(87), c = r(7).f;
            t.exports = function(t) {
                var n = o.Symbol || (o.Symbol = i ? {} : e.Symbol || {});
                "_" == t.charAt(0) || t in n || c(n, t, {
                    value: u.f(t)
                });
            };
        }, function(t, n, r) {
            var e = r(48)("keys"), o = r(31);
            t.exports = function(t) {
                return e[t] || (e[t] = o(t));
            };
        }, function(t, n) {
            t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
        }, function(t, n, r) {
            var e = r(18);
            t.exports = Array.isArray || function(t) {
                return "Array" == e(t);
            };
        }, function(t, n, r) {
            t.exports = r(2).document && document.documentElement;
        }, function(t, n, r) {
            var e = r(4), o = r(1), i = function(t, n) {
                if (o(t), !e(n) && null !== n) throw TypeError(n + ": can't set as prototype!");
            };
            t.exports = {
                set: Object.setPrototypeOf || ("__proto__" in {} ? function(t, n, e) {
                    try {
                        e = r(25)(Function.call, r(16).f(Object.prototype, "__proto__").set, 2), e(t, []), 
                        n = !(t instanceof Array);
                    } catch (t) {
                        n = !0;
                    }
                    return function(t, r) {
                        return i(t, r), n ? t.__proto__ = r : e(t, r), t;
                    };
                }({}, !1) : void 0),
                check: i
            };
        }, function(t, n) {
            t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff";
        }, function(t, n, r) {
            var e = r(4), o = r(65).set;
            t.exports = function(t, n, r) {
                var i, u = n.constructor;
                return u !== r && "function" == typeof u && (i = u.prototype) !== r.prototype && e(i) && o && o(t, i), 
                t;
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(30), o = r(19);
            t.exports = function(t) {
                var n = String(o(this)), r = "", i = e(t);
                if (i < 0 || i == 1 / 0) throw RangeError("Count can't be negative");
                for (;i > 0; (i >>>= 1) && (n += n)) 1 & i && (r += n);
                return r;
            };
        }, function(t, n) {
            t.exports = Math.sign || function(t) {
                return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1;
            };
        }, function(t, n) {
            var r = Math.expm1;
            t.exports = !r || r(10) > 22025.465794806718 || r(10) < 22025.465794806718 || -2e-17 != r(-2e-17) ? function(t) {
                return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1;
            } : r;
        }, function(t, n, r) {
            var e = r(30), o = r(19);
            t.exports = function(t) {
                return function(n, r) {
                    var i, u, c = String(o(n)), a = e(r), f = c.length;
                    return a < 0 || a >= f ? t ? "" : void 0 : (i = c.charCodeAt(a), i < 55296 || i > 56319 || a + 1 === f || (u = c.charCodeAt(a + 1)) < 56320 || u > 57343 ? t ? c.charAt(a) : i : t ? c.slice(a, a + 2) : u - 56320 + (i - 55296 << 10) + 65536);
                };
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(32), o = r(0), i = r(12), u = r(11), c = r(10), a = r(42), f = r(73), s = r(40), l = r(17), v = r(5)("iterator"), h = !([].keys && "next" in [].keys()), p = function() {
                return this;
            };
            t.exports = function(t, n, r, d, y, g, b) {
                f(r, n, d);
                var m, x, w, S = function(t) {
                    if (!h && t in P) return P[t];
                    switch (t) {
                      case "keys":
                      case "values":
                        return function() {
                            return new r(this, t);
                        };
                    }
                    return function() {
                        return new r(this, t);
                    };
                }, _ = n + " Iterator", E = "values" == y, O = !1, P = t.prototype, A = P[v] || P["@@iterator"] || y && P[y], j = A || S(y), I = y ? E ? S("entries") : j : void 0, N = "Array" == n ? P.entries || A : A;
                if (N && (w = l(N.call(new t()))) !== Object.prototype && (s(w, _, !0), e || c(w, v) || u(w, v, p)), 
                E && A && "values" !== A.name && (O = !0, j = function() {
                    return A.call(this);
                }), e && !b || !h && !O && P[v] || u(P, v, j), a[n] = j, a[_] = p, y) if (m = {
                    values: E ? j : S("values"),
                    keys: g ? j : S("keys"),
                    entries: I
                }, b) for (x in m) x in P || i(P, x, m[x]); else o(o.P + o.F * (h || O), n, m);
                return m;
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(35), o = r(28), i = r(40), u = {};
            r(11)(u, r(5)("iterator"), function() {
                return this;
            }), t.exports = function(t, n, r) {
                t.prototype = e(u, {
                    next: o(1, r)
                }), i(t, n + " Iterator");
            };
        }, function(t, n, r) {
            var e = r(52), o = r(19);
            t.exports = function(t, n, r) {
                if (e(n)) throw TypeError("String#" + r + " doesn't accept regex!");
                return String(o(t));
            };
        }, function(t, n, r) {
            var e = r(5)("match");
            t.exports = function(t) {
                var n = /./;
                try {
                    "/./"[t](n);
                } catch (r) {
                    try {
                        return n[e] = !1, !"/./"[t](n);
                    } catch (t) {}
                }
                return !0;
            };
        }, function(t, n, r) {
            var e = r(42), o = r(5)("iterator"), i = Array.prototype;
            t.exports = function(t) {
                return void 0 !== t && (e.Array === t || i[o] === t);
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(7), o = r(28);
            t.exports = function(t, n, r) {
                n in t ? e.f(t, n, o(0, r)) : t[n] = r;
            };
        }, function(t, n, r) {
            var e = r(47), o = r(5)("iterator"), i = r(42);
            t.exports = r(24).getIteratorMethod = function(t) {
                if (void 0 != t) return t[o] || t["@@iterator"] || i[e(t)];
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(9), o = r(34), i = r(8);
            t.exports = function(t) {
                for (var n = e(this), r = i(n.length), u = arguments.length, c = o(u > 1 ? arguments[1] : void 0, r), a = u > 2 ? arguments[2] : void 0, f = void 0 === a ? r : o(a, r); f > c; ) n[c++] = t;
                return n;
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(43), o = r(102), i = r(42), u = r(14);
            t.exports = r(72)(Array, "Array", function(t, n) {
                this._t = u(t), this._i = 0, this._k = n;
            }, function() {
                var t = this._t, n = this._k, r = this._i++;
                return !t || r >= t.length ? (this._t = void 0, o(1)) : "keys" == n ? o(0, r) : "values" == n ? o(0, t[r]) : o(0, [ r, t[r] ]);
            }, "values"), i.Arguments = i.Array, e("keys"), e("values"), e("entries");
        }, function(t, n, r) {
            var e = r(1), o = r(13), i = r(5)("species");
            t.exports = function(t, n) {
                var r, u = e(t).constructor;
                return void 0 === u || void 0 == (r = e(u)[i]) ? n : o(r);
            };
        }, function(t, n, r) {
            var e, o, i, u = r(25), c = r(51), a = r(64), f = r(59), s = r(2), l = s.process, v = s.setImmediate, h = s.clearImmediate, p = s.MessageChannel, d = 0, y = {}, g = function() {
                var t = +this;
                if (y.hasOwnProperty(t)) {
                    var n = y[t];
                    delete y[t], n();
                }
            }, b = function(t) {
                g.call(t.data);
            };
            v && h || (v = function(t) {
                for (var n = [], r = 1; arguments.length > r; ) n.push(arguments[r++]);
                return y[++d] = function() {
                    c("function" == typeof t ? t : Function(t), n);
                }, e(d), d;
            }, h = function(t) {
                delete y[t];
            }, "process" == r(18)(l) ? e = function(t) {
                l.nextTick(u(g, t, 1));
            } : p ? (o = new p(), i = o.port2, o.port1.onmessage = b, e = u(i.postMessage, i, 1)) : s.addEventListener && "function" == typeof postMessage && !s.importScripts ? (e = function(t) {
                s.postMessage(t + "", "*");
            }, s.addEventListener("message", b, !1)) : e = "onreadystatechange" in f("script") ? function(t) {
                a.appendChild(f("script")).onreadystatechange = function() {
                    a.removeChild(this), g.call(t);
                };
            } : function(t) {
                setTimeout(u(g, t, 1), 0);
            }), t.exports = {
                set: v,
                clear: h
            };
        }, function(t, n, r) {
            var e = r(2), o = r(82).set, i = e.MutationObserver || e.WebKitMutationObserver, u = e.process, c = e.Promise, a = "process" == r(18)(u);
            t.exports = function() {
                var t, n, r, f = function() {
                    var e, o;
                    for (a && (e = u.domain) && e.exit(); t; ) {
                        o = t.fn, t = t.next;
                        try {
                            o();
                        } catch (e) {
                            throw t ? r() : n = void 0, e;
                        }
                    }
                    n = void 0, e && e.enter();
                };
                if (a) r = function() {
                    u.nextTick(f);
                }; else if (i) {
                    var s = !0, l = document.createTextNode("");
                    new i(f).observe(l, {
                        characterData: !0
                    }), r = function() {
                        l.data = s = !s;
                    };
                } else if (c && c.resolve) {
                    var v = c.resolve();
                    r = function() {
                        v.then(f);
                    };
                } else r = function() {
                    o.call(e, f);
                };
                return function(e) {
                    var o = {
                        fn: e,
                        next: void 0
                    };
                    n && (n.next = o), t || (t = o, r()), n = o;
                };
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(2), o = r(6), i = r(32), u = r(57), c = r(11), a = r(39), f = r(3), s = r(38), l = r(30), v = r(8), h = r(36).f, p = r(7).f, d = r(79), y = r(40), g = e.ArrayBuffer, b = e.DataView, m = e.Math, x = e.RangeError, w = e.Infinity, S = g, _ = m.abs, E = m.pow, O = m.floor, P = m.log, A = m.LN2, j = o ? "_b" : "buffer", I = o ? "_l" : "byteLength", N = o ? "_o" : "byteOffset", F = function(t, n, r) {
                var e, o, i, u = Array(r), c = 8 * r - n - 1, a = (1 << c) - 1, f = a >> 1, s = 23 === n ? E(2, -24) - E(2, -77) : 0, l = 0, v = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for (t = _(t), t != t || t === w ? (o = t != t ? 1 : 0, e = a) : (e = O(P(t) / A), 
                t * (i = E(2, -e)) < 1 && (e--, i *= 2), t += e + f >= 1 ? s / i : s * E(2, 1 - f), 
                t * i >= 2 && (e++, i /= 2), e + f >= a ? (o = 0, e = a) : e + f >= 1 ? (o = (t * i - 1) * E(2, n), 
                e += f) : (o = t * E(2, f - 1) * E(2, n), e = 0)); n >= 8; u[l++] = 255 & o, o /= 256, 
                n -= 8) ;
                for (e = e << n | o, c += n; c > 0; u[l++] = 255 & e, e /= 256, c -= 8) ;
                return u[--l] |= 128 * v, u;
            }, R = function(t, n, r) {
                var e, o = 8 * r - n - 1, i = (1 << o) - 1, u = i >> 1, c = o - 7, a = r - 1, f = t[a--], s = 127 & f;
                for (f >>= 7; c > 0; s = 256 * s + t[a], a--, c -= 8) ;
                for (e = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; e = 256 * e + t[a], a--, c -= 8) ;
                if (0 === s) s = 1 - u; else {
                    if (s === i) return e ? NaN : f ? -w : w;
                    e += E(2, n), s -= u;
                }
                return (f ? -1 : 1) * e * E(2, s - n);
            }, M = function(t) {
                return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0];
            }, T = function(t) {
                return [ 255 & t ];
            }, k = function(t) {
                return [ 255 & t, t >> 8 & 255 ];
            }, D = function(t) {
                return [ 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255 ];
            }, L = function(t) {
                return F(t, 52, 8);
            }, C = function(t) {
                return F(t, 23, 4);
            }, B = function(t, n, r) {
                p(t.prototype, n, {
                    get: function() {
                        return this[r];
                    }
                });
            }, U = function(t, n, r, e) {
                var o = +r, i = l(o);
                if (o != i || i < 0 || i + n > t[I]) throw x("Wrong index!");
                var u = t[j]._b, c = i + t[N], a = u.slice(c, c + n);
                return e ? a : a.reverse();
            }, W = function(t, n, r, e, o, i) {
                var u = +r, c = l(u);
                if (u != c || c < 0 || c + n > t[I]) throw x("Wrong index!");
                for (var a = t[j]._b, f = c + t[N], s = e(+o), v = 0; v < n; v++) a[f + v] = s[i ? v : n - v - 1];
            }, V = function(t, n) {
                s(t, g, "ArrayBuffer");
                var r = +n, e = v(r);
                if (r != e) throw x("Wrong length!");
                return e;
            };
            if (u.ABV) {
                if (!f(function() {
                    new g();
                }) || !f(function() {
                    new g(.5);
                })) {
                    g = function(t) {
                        return new S(V(this, t));
                    };
                    for (var G, Y = g.prototype = S.prototype, z = h(S), K = 0; z.length > K; ) (G = z[K++]) in g || c(g, G, S[G]);
                    i || (Y.constructor = g);
                }
                var J = new b(new g(2)), q = b.prototype.setInt8;
                J.setInt8(0, 2147483648), J.setInt8(1, 2147483649), !J.getInt8(0) && J.getInt8(1) || a(b.prototype, {
                    setInt8: function(t, n) {
                        q.call(this, t, n << 24 >> 24);
                    },
                    setUint8: function(t, n) {
                        q.call(this, t, n << 24 >> 24);
                    }
                }, !0);
            } else g = function(t) {
                var n = V(this, t);
                this._b = d.call(Array(n), 0), this[I] = n;
            }, b = function(t, n, r) {
                s(this, b, "DataView"), s(t, g, "DataView");
                var e = t[I], o = l(n);
                if (o < 0 || o > e) throw x("Wrong offset!");
                if (r = void 0 === r ? e - o : v(r), o + r > e) throw x("Wrong length!");
                this[j] = t, this[N] = o, this[I] = r;
            }, o && (B(g, "byteLength", "_l"), B(b, "buffer", "_b"), B(b, "byteLength", "_l"), 
            B(b, "byteOffset", "_o")), a(b.prototype, {
                getInt8: function(t) {
                    return U(this, 1, t)[0] << 24 >> 24;
                },
                getUint8: function(t) {
                    return U(this, 1, t)[0];
                },
                getInt16: function(t) {
                    var n = U(this, 2, t, arguments[1]);
                    return (n[1] << 8 | n[0]) << 16 >> 16;
                },
                getUint16: function(t) {
                    var n = U(this, 2, t, arguments[1]);
                    return n[1] << 8 | n[0];
                },
                getInt32: function(t) {
                    return M(U(this, 4, t, arguments[1]));
                },
                getUint32: function(t) {
                    return M(U(this, 4, t, arguments[1])) >>> 0;
                },
                getFloat32: function(t) {
                    return R(U(this, 4, t, arguments[1]), 23, 4);
                },
                getFloat64: function(t) {
                    return R(U(this, 8, t, arguments[1]), 52, 8);
                },
                setInt8: function(t, n) {
                    W(this, 1, t, T, n);
                },
                setUint8: function(t, n) {
                    W(this, 1, t, T, n);
                },
                setInt16: function(t, n) {
                    W(this, 2, t, k, n, arguments[2]);
                },
                setUint16: function(t, n) {
                    W(this, 2, t, k, n, arguments[2]);
                },
                setInt32: function(t, n) {
                    W(this, 4, t, D, n, arguments[2]);
                },
                setUint32: function(t, n) {
                    W(this, 4, t, D, n, arguments[2]);
                },
                setFloat32: function(t, n) {
                    W(this, 4, t, C, n, arguments[2]);
                },
                setFloat64: function(t, n) {
                    W(this, 8, t, L, n, arguments[2]);
                }
            });
            y(g, "ArrayBuffer"), y(b, "DataView"), c(b.prototype, u.VIEW, !0), n.ArrayBuffer = g, 
            n.DataView = b;
        }, function(t, n) {
            var r;
            r = function() {
                return this;
            }();
            try {
                r = r || Function("return this")() || (0, eval)("this");
            } catch (t) {
                "object" == typeof window && (r = window);
            }
            t.exports = r;
        }, function(t, n, r) {
            t.exports = !r(6) && !r(3)(function() {
                return 7 != Object.defineProperty(r(59)("div"), "a", {
                    get: function() {
                        return 7;
                    }
                }).a;
            });
        }, function(t, n, r) {
            n.f = r(5);
        }, function(t, n, r) {
            var e = r(10), o = r(14), i = r(49)(!1), u = r(61)("IE_PROTO");
            t.exports = function(t, n) {
                var r, c = o(t), a = 0, f = [];
                for (r in c) r != u && e(c, r) && f.push(r);
                for (;n.length > a; ) e(c, r = n[a++]) && (~i(f, r) || f.push(r));
                return f;
            };
        }, function(t, n, r) {
            var e = r(7), o = r(1), i = r(33);
            t.exports = r(6) ? Object.defineProperties : function(t, n) {
                o(t);
                for (var r, u = i(n), c = u.length, a = 0; c > a; ) e.f(t, r = u[a++], n[r]);
                return t;
            };
        }, function(t, n, r) {
            var e = r(14), o = r(36).f, i = {}.toString, u = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], c = function(t) {
                try {
                    return o(t);
                } catch (t) {
                    return u.slice();
                }
            };
            t.exports.f = function(t) {
                return u && "[object Window]" == i.call(t) ? c(t) : o(e(t));
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(33), o = r(50), i = r(46), u = r(9), c = r(45), a = Object.assign;
            t.exports = !a || r(3)(function() {
                var t = {}, n = {}, r = Symbol(), e = "abcdefghijklmnopqrst";
                return t[r] = 7, e.split("").forEach(function(t) {
                    n[t] = t;
                }), 7 != a({}, t)[r] || Object.keys(a({}, n)).join("") != e;
            }) ? function(t, n) {
                for (var r = u(t), a = arguments.length, f = 1, s = o.f, l = i.f; a > f; ) for (var v, h = c(arguments[f++]), p = s ? e(h).concat(s(h)) : e(h), d = p.length, y = 0; d > y; ) l.call(h, v = p[y++]) && (r[v] = h[v]);
                return r;
            } : a;
        }, function(t, n) {
            t.exports = Object.is || function(t, n) {
                return t === n ? 0 !== t || 1 / t == 1 / n : t != t && n != n;
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(13), o = r(4), i = r(51), u = [].slice, c = {}, a = function(t, n, r) {
                if (!(n in c)) {
                    for (var e = [], o = 0; o < n; o++) e[o] = "a[" + o + "]";
                    c[n] = Function("F,a", "return new F(" + e.join(",") + ")");
                }
                return c[n](t, r);
            };
            t.exports = Function.bind || function(t) {
                var n = e(this), r = u.call(arguments, 1), c = function() {
                    var e = r.concat(u.call(arguments));
                    return this instanceof c ? a(n, e.length, e) : i(n, e, t);
                };
                return o(n.prototype) && (c.prototype = n.prototype), c;
            };
        }, function(t, n, r) {
            var e = r(2).parseInt, o = r(41).trim, i = r(66), u = /^[\-+]?0[xX]/;
            t.exports = 8 !== e(i + "08") || 22 !== e(i + "0x16") ? function(t, n) {
                var r = o(String(t), 3);
                return e(r, n >>> 0 || (u.test(r) ? 16 : 10));
            } : e;
        }, function(t, n, r) {
            var e = r(2).parseFloat, o = r(41).trim;
            t.exports = 1 / e(r(66) + "-0") != -1 / 0 ? function(t) {
                var n = o(String(t), 3), r = e(n);
                return 0 === r && "-" == n.charAt(0) ? -0 : r;
            } : e;
        }, function(t, n, r) {
            var e = r(18);
            t.exports = function(t, n) {
                if ("number" != typeof t && "Number" != e(t)) throw TypeError(n);
                return +t;
            };
        }, function(t, n, r) {
            var e = r(4), o = Math.floor;
            t.exports = function(t) {
                return !e(t) && isFinite(t) && o(t) === t;
            };
        }, function(t, n) {
            t.exports = Math.log1p || function(t) {
                return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t);
            };
        }, function(t, n, r) {
            var e = r(1);
            t.exports = function(t, n, r, o) {
                try {
                    return o ? n(e(r)[0], r[1]) : n(r);
                } catch (n) {
                    var i = t.return;
                    throw void 0 !== i && e(i.call(t)), n;
                }
            };
        }, function(t, n, r) {
            var e = r(13), o = r(9), i = r(45), u = r(8);
            t.exports = function(t, n, r, c, a) {
                e(n);
                var f = o(t), s = i(f), l = u(f.length), v = a ? l - 1 : 0, h = a ? -1 : 1;
                if (r < 2) for (;;) {
                    if (v in s) {
                        c = s[v], v += h;
                        break;
                    }
                    if (v += h, a ? v < 0 : l <= v) throw TypeError("Reduce of empty array with no initial value");
                }
                for (;a ? v >= 0 : l > v; v += h) v in s && (c = n(c, s[v], v, f));
                return c;
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(9), o = r(34), i = r(8);
            t.exports = [].copyWithin || function(t, n) {
                var r = e(this), u = i(r.length), c = o(t, u), a = o(n, u), f = arguments.length > 2 ? arguments[2] : void 0, s = Math.min((void 0 === f ? u : o(f, u)) - a, u - c), l = 1;
                for (a < c && c < a + s && (l = -1, a += s - 1, c += s - 1); s-- > 0; ) a in r ? r[c] = r[a] : delete r[c], 
                c += l, a += l;
                return r;
            };
        }, function(t, n) {
            t.exports = function(t, n) {
                return {
                    value: n,
                    done: !!t
                };
            };
        }, function(t, n, r) {
            r(6) && "g" != /./g.flags && r(7).f(RegExp.prototype, "flags", {
                configurable: !0,
                get: r(54)
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(105);
            t.exports = r(56)("Map", function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0);
                };
            }, {
                get: function(t) {
                    var n = e.getEntry(this, t);
                    return n && n.v;
                },
                set: function(t, n) {
                    return e.def(this, 0 === t ? 0 : t, n);
                }
            }, e, !0);
        }, function(t, n, r) {
            "use strict";
            var e = r(7).f, o = r(35), i = r(39), u = r(25), c = r(38), a = r(19), f = r(44), s = r(72), l = r(102), v = r(37), h = r(6), p = r(29).fastKey, d = h ? "_s" : "size", y = function(t, n) {
                var r, e = p(n);
                if ("F" !== e) return t._i[e];
                for (r = t._f; r; r = r.n) if (r.k == n) return r;
            };
            t.exports = {
                getConstructor: function(t, n, r, s) {
                    var l = t(function(t, e) {
                        c(t, l, n, "_i"), t._i = o(null), t._f = void 0, t._l = void 0, t[d] = 0, void 0 != e && f(e, r, t[s], t);
                    });
                    return i(l.prototype, {
                        clear: function() {
                            for (var t = this, n = t._i, r = t._f; r; r = r.n) r.r = !0, r.p && (r.p = r.p.n = void 0), 
                            delete n[r.i];
                            t._f = t._l = void 0, t[d] = 0;
                        },
                        delete: function(t) {
                            var n = this, r = y(n, t);
                            if (r) {
                                var e = r.n, o = r.p;
                                delete n._i[r.i], r.r = !0, o && (o.n = e), e && (e.p = o), n._f == r && (n._f = e), 
                                n._l == r && (n._l = o), n[d]--;
                            }
                            return !!r;
                        },
                        forEach: function(t) {
                            c(this, l, "forEach");
                            for (var n, r = u(t, arguments.length > 1 ? arguments[1] : void 0, 3); n = n ? n.n : this._f; ) for (r(n.v, n.k, this); n && n.r; ) n = n.p;
                        },
                        has: function(t) {
                            return !!y(this, t);
                        }
                    }), h && e(l.prototype, "size", {
                        get: function() {
                            return a(this[d]);
                        }
                    }), l;
                },
                def: function(t, n, r) {
                    var e, o, i = y(t, n);
                    return i ? i.v = r : (t._l = i = {
                        i: o = p(n, !0),
                        k: n,
                        v: r,
                        p: e = t._l,
                        n: void 0,
                        r: !1
                    }, t._f || (t._f = i), e && (e.n = i), t[d]++, "F" !== o && (t._i[o] = i)), t;
                },
                getEntry: y,
                setStrong: function(t, n, r) {
                    s(t, n, function(t, n) {
                        this._t = t, this._k = n, this._l = void 0;
                    }, function() {
                        for (var t = this, n = t._k, r = t._l; r && r.r; ) r = r.p;
                        return t._t && (t._l = r = r ? r.n : t._t._f) ? "keys" == n ? l(0, r.k) : "values" == n ? l(0, r.v) : l(0, [ r.k, r.v ]) : (t._t = void 0, 
                        l(1));
                    }, r ? "entries" : "values", !r, !0), v(n);
                }
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(105);
            t.exports = r(56)("Set", function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0);
                };
            }, {
                add: function(t) {
                    return e.def(this, t = 0 === t ? 0 : t, t);
                }
            }, e);
        }, function(t, n, r) {
            "use strict";
            var e, o = r(23)(0), i = r(12), u = r(29), c = r(91), a = r(108), f = r(4), s = u.getWeak, l = Object.isExtensible, v = a.ufstore, h = {}, p = function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0);
                };
            }, d = {
                get: function(t) {
                    if (f(t)) {
                        var n = s(t);
                        return !0 === n ? v(this).get(t) : n ? n[this._i] : void 0;
                    }
                },
                set: function(t, n) {
                    return a.def(this, t, n);
                }
            }, y = t.exports = r(56)("WeakMap", p, d, a, !0, !0);
            7 != new y().set((Object.freeze || Object)(h), 7).get(h) && (e = a.getConstructor(p), 
            c(e.prototype, d), u.NEED = !0, o([ "delete", "has", "get", "set" ], function(t) {
                var n = y.prototype, r = n[t];
                i(n, t, function(n, o) {
                    if (f(n) && !l(n)) {
                        this._f || (this._f = new e());
                        var i = this._f[t](n, o);
                        return "set" == t ? this : i;
                    }
                    return r.call(this, n, o);
                });
            }));
        }, function(t, n, r) {
            "use strict";
            var e = r(39), o = r(29).getWeak, i = r(1), u = r(4), c = r(38), a = r(44), f = r(23), s = r(10), l = f(5), v = f(6), h = 0, p = function(t) {
                return t._l || (t._l = new d());
            }, d = function() {
                this.a = [];
            }, y = function(t, n) {
                return l(t.a, function(t) {
                    return t[0] === n;
                });
            };
            d.prototype = {
                get: function(t) {
                    var n = y(this, t);
                    if (n) return n[1];
                },
                has: function(t) {
                    return !!y(this, t);
                },
                set: function(t, n) {
                    var r = y(this, t);
                    r ? r[1] = n : this.a.push([ t, n ]);
                },
                delete: function(t) {
                    var n = v(this.a, function(n) {
                        return n[0] === t;
                    });
                    return ~n && this.a.splice(n, 1), !!~n;
                }
            }, t.exports = {
                getConstructor: function(t, n, r, i) {
                    var f = t(function(t, e) {
                        c(t, f, n, "_i"), t._i = h++, t._l = void 0, void 0 != e && a(e, r, t[i], t);
                    });
                    return e(f.prototype, {
                        delete: function(t) {
                            if (!u(t)) return !1;
                            var n = o(t);
                            return !0 === n ? p(this).delete(t) : n && s(n, this._i) && delete n[this._i];
                        },
                        has: function(t) {
                            if (!u(t)) return !1;
                            var n = o(t);
                            return !0 === n ? p(this).has(t) : n && s(n, this._i);
                        }
                    }), f;
                },
                def: function(t, n, r) {
                    var e = o(i(n), !0);
                    return !0 === e ? p(t).set(n, r) : e[t._i] = r, t;
                },
                ufstore: p
            };
        }, function(t, n, r) {
            var e = r(36), o = r(50), i = r(1), u = r(2).Reflect;
            t.exports = u && u.ownKeys || function(t) {
                var n = e.f(i(t)), r = o.f;
                return r ? n.concat(r(t)) : n;
            };
        }, function(t, n, r) {
            var e = r(8), o = r(68), i = r(19);
            t.exports = function(t, n, r, u) {
                var c = String(i(t)), a = c.length, f = void 0 === r ? " " : String(r), s = e(n);
                if (s <= a || "" == f) return c;
                var l = s - a, v = o.call(f, Math.ceil(l / f.length));
                return v.length > l && (v = v.slice(0, l)), u ? v + c : c + v;
            };
        }, function(t, n, r) {
            var e = r(33), o = r(14), i = r(46).f;
            t.exports = function(t) {
                return function(n) {
                    for (var r, u = o(n), c = e(u), a = c.length, f = 0, s = []; a > f; ) i.call(u, r = c[f++]) && s.push(t ? [ r, u[r] ] : u[r]);
                    return s;
                };
            };
        }, function(t, n, r) {
            var e = r(47), o = r(113);
            t.exports = function(t) {
                return function() {
                    if (e(this) != t) throw TypeError(t + "#toJSON isn't generic");
                    return o(this);
                };
            };
        }, function(t, n, r) {
            var e = r(44);
            t.exports = function(t, n) {
                var r = [];
                return e(t, !1, r.push, r, n), r;
            };
        }, function(t, n, r) {
            r(115), t.exports = r(298);
        }, function(t, n, r) {
            "use strict";
            (function(t) {
                function n(t, n, r) {
                    t[n] || Object[e](t, n, {
                        writable: !0,
                        configurable: !0,
                        value: r
                    });
                }
                if (r(116), r(294), r(295), t._babelPolyfill) throw new Error("only one instance of babel-polyfill is allowed");
                t._babelPolyfill = !0;
                var e = "defineProperty";
                n(String.prototype, "padLeft", "".padStart), n(String.prototype, "padRight", "".padEnd), 
                "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t) {
                    [][t] && n(Array, t, Function.call.bind([][t]));
                });
            }).call(n, r(85));
        }, function(t, n, r) {
            r(117), r(120), r(121), r(122), r(123), r(124), r(125), r(126), r(127), r(128), 
            r(129), r(130), r(131), r(132), r(133), r(134), r(135), r(136), r(137), r(138), 
            r(139), r(140), r(141), r(142), r(143), r(144), r(145), r(146), r(147), r(148), 
            r(149), r(150), r(151), r(152), r(153), r(154), r(155), r(156), r(157), r(158), 
            r(159), r(160), r(161), r(162), r(163), r(164), r(165), r(166), r(167), r(168), 
            r(169), r(170), r(171), r(172), r(173), r(174), r(175), r(176), r(177), r(178), 
            r(179), r(180), r(181), r(182), r(183), r(184), r(185), r(186), r(187), r(188), 
            r(189), r(190), r(191), r(192), r(193), r(194), r(195), r(196), r(197), r(199), 
            r(200), r(201), r(202), r(203), r(204), r(205), r(208), r(209), r(210), r(211), 
            r(212), r(213), r(214), r(215), r(216), r(217), r(218), r(219), r(220), r(80), r(221), 
            r(222), r(103), r(223), r(224), r(225), r(226), r(227), r(104), r(106), r(107), 
            r(228), r(229), r(230), r(231), r(232), r(233), r(234), r(235), r(236), r(237), 
            r(238), r(239), r(240), r(241), r(242), r(243), r(244), r(245), r(246), r(247), 
            r(248), r(249), r(250), r(251), r(252), r(253), r(254), r(255), r(256), r(257), 
            r(258), r(259), r(260), r(261), r(262), r(263), r(264), r(265), r(266), r(267), 
            r(268), r(269), r(270), r(271), r(272), r(273), r(274), r(275), r(276), r(277), 
            r(278), r(279), r(280), r(281), r(282), r(283), r(284), r(285), r(286), r(287), 
            r(288), r(289), r(292), r(293), t.exports = r(24);
        }, function(t, n, r) {
            "use strict";
            var e = r(2), o = r(10), i = r(6), u = r(0), c = r(12), a = r(29).KEY, f = r(3), s = r(48), l = r(40), v = r(31), h = r(5), p = r(87), d = r(60), y = r(118), g = r(119), b = r(63), m = r(1), x = r(14), w = r(21), S = r(28), _ = r(35), E = r(90), O = r(16), P = r(7), A = r(33), j = O.f, I = P.f, N = E.f, F = e.Symbol, R = e.JSON, M = R && R.stringify, T = h("_hidden"), k = h("toPrimitive"), D = {}.propertyIsEnumerable, L = s("symbol-registry"), C = s("symbols"), B = s("op-symbols"), U = Object.prototype, W = "function" == typeof F, V = e.QObject, G = !V || !V.prototype || !V.prototype.findChild, Y = i && f(function() {
                return 7 != _(I({}, "a", {
                    get: function() {
                        return I(this, "a", {
                            value: 7
                        }).a;
                    }
                })).a;
            }) ? function(t, n, r) {
                var e = j(U, n);
                e && delete U[n], I(t, n, r), e && t !== U && I(U, n, e);
            } : I, z = function(t) {
                var n = C[t] = _(F.prototype);
                return n._k = t, n;
            }, K = W && "symbol" == typeof F.iterator ? function(t) {
                return "symbol" == typeof t;
            } : function(t) {
                return t instanceof F;
            }, J = function(t, n, r) {
                return t === U && J(B, n, r), m(t), n = w(n, !0), m(r), o(C, n) ? (r.enumerable ? (o(t, T) && t[T][n] && (t[T][n] = !1), 
                r = _(r, {
                    enumerable: S(0, !1)
                })) : (o(t, T) || I(t, T, S(1, {})), t[T][n] = !0), Y(t, n, r)) : I(t, n, r);
            }, q = function(t, n) {
                m(t);
                for (var r, e = g(n = x(n)), o = 0, i = e.length; i > o; ) J(t, r = e[o++], n[r]);
                return t;
            }, Q = function(t, n) {
                return void 0 === n ? _(t) : q(_(t), n);
            }, X = function(t) {
                var n = D.call(this, t = w(t, !0));
                return !(this === U && o(C, t) && !o(B, t)) && (!(n || !o(this, t) || !o(C, t) || o(this, T) && this[T][t]) || n);
            }, $ = function(t, n) {
                if (t = x(t), n = w(n, !0), t !== U || !o(C, n) || o(B, n)) {
                    var r = j(t, n);
                    return !r || !o(C, n) || o(t, T) && t[T][n] || (r.enumerable = !0), r;
                }
            }, H = function(t) {
                for (var n, r = N(x(t)), e = [], i = 0; r.length > i; ) o(C, n = r[i++]) || n == T || n == a || e.push(n);
                return e;
            }, Z = function(t) {
                for (var n, r = t === U, e = N(r ? B : x(t)), i = [], u = 0; e.length > u; ) !o(C, n = e[u++]) || r && !o(U, n) || i.push(C[n]);
                return i;
            };
            W || (F = function() {
                if (this instanceof F) throw TypeError("Symbol is not a constructor!");
                var t = v(arguments.length > 0 ? arguments[0] : void 0), n = function(r) {
                    this === U && n.call(B, r), o(this, T) && o(this[T], t) && (this[T][t] = !1), Y(this, t, S(1, r));
                };
                return i && G && Y(U, t, {
                    configurable: !0,
                    set: n
                }), z(t);
            }, c(F.prototype, "toString", function() {
                return this._k;
            }), O.f = $, P.f = J, r(36).f = E.f = H, r(46).f = X, r(50).f = Z, i && !r(32) && c(U, "propertyIsEnumerable", X, !0), 
            p.f = function(t) {
                return z(h(t));
            }), u(u.G + u.W + u.F * !W, {
                Symbol: F
            });
            for (var tt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), nt = 0; tt.length > nt; ) h(tt[nt++]);
            for (var tt = A(h.store), nt = 0; tt.length > nt; ) d(tt[nt++]);
            u(u.S + u.F * !W, "Symbol", {
                for: function(t) {
                    return o(L, t += "") ? L[t] : L[t] = F(t);
                },
                keyFor: function(t) {
                    if (K(t)) return y(L, t);
                    throw TypeError(t + " is not a symbol!");
                },
                useSetter: function() {
                    G = !0;
                },
                useSimple: function() {
                    G = !1;
                }
            }), u(u.S + u.F * !W, "Object", {
                create: Q,
                defineProperty: J,
                defineProperties: q,
                getOwnPropertyDescriptor: $,
                getOwnPropertyNames: H,
                getOwnPropertySymbols: Z
            }), R && u(u.S + u.F * (!W || f(function() {
                var t = F();
                return "[null]" != M([ t ]) || "{}" != M({
                    a: t
                }) || "{}" != M(Object(t));
            })), "JSON", {
                stringify: function(t) {
                    if (void 0 !== t && !K(t)) {
                        for (var n, r, e = [ t ], o = 1; arguments.length > o; ) e.push(arguments[o++]);
                        return n = e[1], "function" == typeof n && (r = n), !r && b(n) || (n = function(t, n) {
                            if (r && (n = r.call(this, t, n)), !K(n)) return n;
                        }), e[1] = n, M.apply(R, e);
                    }
                }
            }), F.prototype[k] || r(11)(F.prototype, k, F.prototype.valueOf), l(F, "Symbol"), 
            l(Math, "Math", !0), l(e.JSON, "JSON", !0);
        }, function(t, n, r) {
            var e = r(33), o = r(14);
            t.exports = function(t, n) {
                for (var r, i = o(t), u = e(i), c = u.length, a = 0; c > a; ) if (i[r = u[a++]] === n) return r;
            };
        }, function(t, n, r) {
            var e = r(33), o = r(50), i = r(46);
            t.exports = function(t) {
                var n = e(t), r = o.f;
                if (r) for (var u, c = r(t), a = i.f, f = 0; c.length > f; ) a.call(t, u = c[f++]) && n.push(u);
                return n;
            };
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Object", {
                create: r(35)
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S + e.F * !r(6), "Object", {
                defineProperty: r(7).f
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S + e.F * !r(6), "Object", {
                defineProperties: r(89)
            });
        }, function(t, n, r) {
            var e = r(14), o = r(16).f;
            r(22)("getOwnPropertyDescriptor", function() {
                return function(t, n) {
                    return o(e(t), n);
                };
            });
        }, function(t, n, r) {
            var e = r(9), o = r(17);
            r(22)("getPrototypeOf", function() {
                return function(t) {
                    return o(e(t));
                };
            });
        }, function(t, n, r) {
            var e = r(9), o = r(33);
            r(22)("keys", function() {
                return function(t) {
                    return o(e(t));
                };
            });
        }, function(t, n, r) {
            r(22)("getOwnPropertyNames", function() {
                return r(90).f;
            });
        }, function(t, n, r) {
            var e = r(4), o = r(29).onFreeze;
            r(22)("freeze", function(t) {
                return function(n) {
                    return t && e(n) ? t(o(n)) : n;
                };
            });
        }, function(t, n, r) {
            var e = r(4), o = r(29).onFreeze;
            r(22)("seal", function(t) {
                return function(n) {
                    return t && e(n) ? t(o(n)) : n;
                };
            });
        }, function(t, n, r) {
            var e = r(4), o = r(29).onFreeze;
            r(22)("preventExtensions", function(t) {
                return function(n) {
                    return t && e(n) ? t(o(n)) : n;
                };
            });
        }, function(t, n, r) {
            var e = r(4);
            r(22)("isFrozen", function(t) {
                return function(n) {
                    return !e(n) || !!t && t(n);
                };
            });
        }, function(t, n, r) {
            var e = r(4);
            r(22)("isSealed", function(t) {
                return function(n) {
                    return !e(n) || !!t && t(n);
                };
            });
        }, function(t, n, r) {
            var e = r(4);
            r(22)("isExtensible", function(t) {
                return function(n) {
                    return !!e(n) && (!t || t(n));
                };
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S + e.F, "Object", {
                assign: r(91)
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Object", {
                is: r(92)
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Object", {
                setPrototypeOf: r(65).set
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(47), o = {};
            o[r(5)("toStringTag")] = "z", o + "" != "[object z]" && r(12)(Object.prototype, "toString", function() {
                return "[object " + e(this) + "]";
            }, !0);
        }, function(t, n, r) {
            var e = r(0);
            e(e.P, "Function", {
                bind: r(93)
            });
        }, function(t, n, r) {
            var e = r(7).f, o = r(28), i = r(10), u = Function.prototype, c = /^\s*function ([^ (]*)/, a = Object.isExtensible || function() {
                return !0;
            };
            "name" in u || r(6) && e(u, "name", {
                configurable: !0,
                get: function() {
                    try {
                        var t = this, n = ("" + t).match(c)[1];
                        return i(t, "name") || !a(t) || e(t, "name", o(5, n)), n;
                    } catch (t) {
                        return "";
                    }
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(4), o = r(17), i = r(5)("hasInstance"), u = Function.prototype;
            i in u || r(7).f(u, i, {
                value: function(t) {
                    if ("function" != typeof this || !e(t)) return !1;
                    if (!e(this.prototype)) return t instanceof this;
                    for (;t = o(t); ) if (this.prototype === t) return !0;
                    return !1;
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(94);
            e(e.G + e.F * (parseInt != o), {
                parseInt: o
            });
        }, function(t, n, r) {
            var e = r(0), o = r(95);
            e(e.G + e.F * (parseFloat != o), {
                parseFloat: o
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(2), o = r(10), i = r(18), u = r(67), c = r(21), a = r(3), f = r(36).f, s = r(16).f, l = r(7).f, v = r(41).trim, h = e.Number, p = h, d = h.prototype, y = "Number" == i(r(35)(d)), g = "trim" in String.prototype, b = function(t) {
                var n = c(t, !1);
                if ("string" == typeof n && n.length > 2) {
                    n = g ? n.trim() : v(n, 3);
                    var r, e, o, i = n.charCodeAt(0);
                    if (43 === i || 45 === i) {
                        if (88 === (r = n.charCodeAt(2)) || 120 === r) return NaN;
                    } else if (48 === i) {
                        switch (n.charCodeAt(1)) {
                          case 66:
                          case 98:
                            e = 2, o = 49;
                            break;

                          case 79:
                          case 111:
                            e = 8, o = 55;
                            break;

                          default:
                            return +n;
                        }
                        for (var u, a = n.slice(2), f = 0, s = a.length; f < s; f++) if ((u = a.charCodeAt(f)) < 48 || u > o) return NaN;
                        return parseInt(a, e);
                    }
                }
                return +n;
            };
            if (!h(" 0o1") || !h("0b1") || h("+0x1")) {
                h = function(t) {
                    var n = arguments.length < 1 ? 0 : t, r = this;
                    return r instanceof h && (y ? a(function() {
                        d.valueOf.call(r);
                    }) : "Number" != i(r)) ? u(new p(b(n)), r, h) : b(n);
                };
                for (var m, x = r(6) ? f(p) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), w = 0; x.length > w; w++) o(p, m = x[w]) && !o(h, m) && l(h, m, s(p, m));
                h.prototype = d, d.constructor = h, r(12)(e, "Number", h);
            }
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(30), i = r(96), u = r(68), c = 1..toFixed, a = Math.floor, f = [ 0, 0, 0, 0, 0, 0 ], s = "Number.toFixed: incorrect invocation!", l = function(t, n) {
                for (var r = -1, e = n; ++r < 6; ) e += t * f[r], f[r] = e % 1e7, e = a(e / 1e7);
            }, v = function(t) {
                for (var n = 6, r = 0; --n >= 0; ) r += f[n], f[n] = a(r / t), r = r % t * 1e7;
            }, h = function() {
                for (var t = 6, n = ""; --t >= 0; ) if ("" !== n || 0 === t || 0 !== f[t]) {
                    var r = String(f[t]);
                    n = "" === n ? r : n + u.call("0", 7 - r.length) + r;
                }
                return n;
            }, p = function(t, n, r) {
                return 0 === n ? r : n % 2 == 1 ? p(t, n - 1, r * t) : p(t * t, n / 2, r);
            }, d = function(t) {
                for (var n = 0, r = t; r >= 4096; ) n += 12, r /= 4096;
                for (;r >= 2; ) n += 1, r /= 2;
                return n;
            };
            e(e.P + e.F * (!!c && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !r(3)(function() {
                c.call({});
            })), "Number", {
                toFixed: function(t) {
                    var n, r, e, c, a = i(this, s), f = o(t), y = "", g = "0";
                    if (f < 0 || f > 20) throw RangeError(s);
                    if (a != a) return "NaN";
                    if (a <= -1e21 || a >= 1e21) return String(a);
                    if (a < 0 && (y = "-", a = -a), a > 1e-21) if (n = d(a * p(2, 69, 1)) - 69, r = n < 0 ? a * p(2, -n, 1) : a / p(2, n, 1), 
                    r *= 4503599627370496, (n = 52 - n) > 0) {
                        for (l(0, r), e = f; e >= 7; ) l(1e7, 0), e -= 7;
                        for (l(p(10, e, 1), 0), e = n - 1; e >= 23; ) v(1 << 23), e -= 23;
                        v(1 << e), l(1, 1), v(2), g = h();
                    } else l(0, r), l(1 << -n, 0), g = h() + u.call("0", f);
                    return f > 0 ? (c = g.length, g = y + (c <= f ? "0." + u.call("0", f - c) + g : g.slice(0, c - f) + "." + g.slice(c - f))) : g = y + g, 
                    g;
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(3), i = r(96), u = 1..toPrecision;
            e(e.P + e.F * (o(function() {
                return "1" !== u.call(1, void 0);
            }) || !o(function() {
                u.call({});
            })), "Number", {
                toPrecision: function(t) {
                    var n = i(this, "Number#toPrecision: incorrect invocation!");
                    return void 0 === t ? u.call(n) : u.call(n, t);
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Number", {
                EPSILON: Math.pow(2, -52)
            });
        }, function(t, n, r) {
            var e = r(0), o = r(2).isFinite;
            e(e.S, "Number", {
                isFinite: function(t) {
                    return "number" == typeof t && o(t);
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Number", {
                isInteger: r(97)
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Number", {
                isNaN: function(t) {
                    return t != t;
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(97), i = Math.abs;
            e(e.S, "Number", {
                isSafeInteger: function(t) {
                    return o(t) && i(t) <= 9007199254740991;
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Number", {
                MAX_SAFE_INTEGER: 9007199254740991
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Number", {
                MIN_SAFE_INTEGER: -9007199254740991
            });
        }, function(t, n, r) {
            var e = r(0), o = r(95);
            e(e.S + e.F * (Number.parseFloat != o), "Number", {
                parseFloat: o
            });
        }, function(t, n, r) {
            var e = r(0), o = r(94);
            e(e.S + e.F * (Number.parseInt != o), "Number", {
                parseInt: o
            });
        }, function(t, n, r) {
            var e = r(0), o = r(98), i = Math.sqrt, u = Math.acosh;
            e(e.S + e.F * !(u && 710 == Math.floor(u(Number.MAX_VALUE)) && u(1 / 0) == 1 / 0), "Math", {
                acosh: function(t) {
                    return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? Math.log(t) + Math.LN2 : o(t - 1 + i(t - 1) * i(t + 1));
                }
            });
        }, function(t, n, r) {
            function e(t) {
                return isFinite(t = +t) && 0 != t ? t < 0 ? -e(-t) : Math.log(t + Math.sqrt(t * t + 1)) : t;
            }
            var o = r(0), i = Math.asinh;
            o(o.S + o.F * !(i && 1 / i(0) > 0), "Math", {
                asinh: e
            });
        }, function(t, n, r) {
            var e = r(0), o = Math.atanh;
            e(e.S + e.F * !(o && 1 / o(-0) < 0), "Math", {
                atanh: function(t) {
                    return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2;
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(69);
            e(e.S, "Math", {
                cbrt: function(t) {
                    return o(t = +t) * Math.pow(Math.abs(t), 1 / 3);
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                clz32: function(t) {
                    return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32;
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = Math.exp;
            e(e.S, "Math", {
                cosh: function(t) {
                    return (o(t = +t) + o(-t)) / 2;
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(70);
            e(e.S + e.F * (o != Math.expm1), "Math", {
                expm1: o
            });
        }, function(t, n, r) {
            var e = r(0), o = r(69), i = Math.pow, u = i(2, -52), c = i(2, -23), a = i(2, 127) * (2 - c), f = i(2, -126), s = function(t) {
                return t + 1 / u - 1 / u;
            };
            e(e.S, "Math", {
                fround: function(t) {
                    var n, r, e = Math.abs(t), i = o(t);
                    return e < f ? i * s(e / f / c) * f * c : (n = (1 + c / u) * e, r = n - (n - e), 
                    r > a || r != r ? i * (1 / 0) : i * r);
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = Math.abs;
            e(e.S, "Math", {
                hypot: function(t, n) {
                    for (var r, e, i = 0, u = 0, c = arguments.length, a = 0; u < c; ) r = o(arguments[u++]), 
                    a < r ? (e = a / r, i = i * e * e + 1, a = r) : r > 0 ? (e = r / a, i += e * e) : i += r;
                    return a === 1 / 0 ? 1 / 0 : a * Math.sqrt(i);
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = Math.imul;
            e(e.S + e.F * r(3)(function() {
                return -5 != o(4294967295, 5) || 2 != o.length;
            }), "Math", {
                imul: function(t, n) {
                    var r = +t, e = +n, o = 65535 & r, i = 65535 & e;
                    return 0 | o * i + ((65535 & r >>> 16) * i + o * (65535 & e >>> 16) << 16 >>> 0);
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                log10: function(t) {
                    return Math.log(t) / Math.LN10;
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                log1p: r(98)
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                log2: function(t) {
                    return Math.log(t) / Math.LN2;
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                sign: r(69)
            });
        }, function(t, n, r) {
            var e = r(0), o = r(70), i = Math.exp;
            e(e.S + e.F * r(3)(function() {
                return -2e-17 != !Math.sinh(-2e-17);
            }), "Math", {
                sinh: function(t) {
                    return Math.abs(t = +t) < 1 ? (o(t) - o(-t)) / 2 : (i(t - 1) - i(-t - 1)) * (Math.E / 2);
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(70), i = Math.exp;
            e(e.S, "Math", {
                tanh: function(t) {
                    var n = o(t = +t), r = o(-t);
                    return n == 1 / 0 ? 1 : r == 1 / 0 ? -1 : (n - r) / (i(t) + i(-t));
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                trunc: function(t) {
                    return (t > 0 ? Math.floor : Math.ceil)(t);
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(34), i = String.fromCharCode, u = String.fromCodePoint;
            e(e.S + e.F * (!!u && 1 != u.length), "String", {
                fromCodePoint: function(t) {
                    for (var n, r = [], e = arguments.length, u = 0; e > u; ) {
                        if (n = +arguments[u++], o(n, 1114111) !== n) throw RangeError(n + " is not a valid code point");
                        r.push(n < 65536 ? i(n) : i(55296 + ((n -= 65536) >> 10), n % 1024 + 56320));
                    }
                    return r.join("");
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(14), i = r(8);
            e(e.S, "String", {
                raw: function(t) {
                    for (var n = o(t.raw), r = i(n.length), e = arguments.length, u = [], c = 0; r > c; ) u.push(String(n[c++])), 
                    c < e && u.push(String(arguments[c]));
                    return u.join("");
                }
            });
        }, function(t, n, r) {
            "use strict";
            r(41)("trim", function(t) {
                return function() {
                    return t(this, 3);
                };
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(71)(!0);
            r(72)(String, "String", function(t) {
                this._t = String(t), this._i = 0;
            }, function() {
                var t, n = this._t, r = this._i;
                return r >= n.length ? {
                    value: void 0,
                    done: !0
                } : (t = e(n, r), this._i += t.length, {
                    value: t,
                    done: !1
                });
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(71)(!1);
            e(e.P, "String", {
                codePointAt: function(t) {
                    return o(this, t);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(8), i = r(74), u = "".endsWith;
            e(e.P + e.F * r(75)("endsWith"), "String", {
                endsWith: function(t) {
                    var n = i(this, t, "endsWith"), r = arguments.length > 1 ? arguments[1] : void 0, e = o(n.length), c = void 0 === r ? e : Math.min(o(r), e), a = String(t);
                    return u ? u.call(n, a, c) : n.slice(c - a.length, c) === a;
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(74);
            e(e.P + e.F * r(75)("includes"), "String", {
                includes: function(t) {
                    return !!~o(this, t, "includes").indexOf(t, arguments.length > 1 ? arguments[1] : void 0);
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.P, "String", {
                repeat: r(68)
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(8), i = r(74), u = "".startsWith;
            e(e.P + e.F * r(75)("startsWith"), "String", {
                startsWith: function(t) {
                    var n = i(this, t, "startsWith"), r = o(Math.min(arguments.length > 1 ? arguments[1] : void 0, n.length)), e = String(t);
                    return u ? u.call(n, e, r) : n.slice(r, r + e.length) === e;
                }
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("anchor", function(t) {
                return function(n) {
                    return t(this, "a", "name", n);
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("big", function(t) {
                return function() {
                    return t(this, "big", "", "");
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("blink", function(t) {
                return function() {
                    return t(this, "blink", "", "");
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("bold", function(t) {
                return function() {
                    return t(this, "b", "", "");
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("fixed", function(t) {
                return function() {
                    return t(this, "tt", "", "");
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("fontcolor", function(t) {
                return function(n) {
                    return t(this, "font", "color", n);
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("fontsize", function(t) {
                return function(n) {
                    return t(this, "font", "size", n);
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("italics", function(t) {
                return function() {
                    return t(this, "i", "", "");
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("link", function(t) {
                return function(n) {
                    return t(this, "a", "href", n);
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("small", function(t) {
                return function() {
                    return t(this, "small", "", "");
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("strike", function(t) {
                return function() {
                    return t(this, "strike", "", "");
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("sub", function(t) {
                return function() {
                    return t(this, "sub", "", "");
                };
            });
        }, function(t, n, r) {
            "use strict";
            r(15)("sup", function(t) {
                return function() {
                    return t(this, "sup", "", "");
                };
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Date", {
                now: function() {
                    return new Date().getTime();
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(9), i = r(21);
            e(e.P + e.F * r(3)(function() {
                return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
                    toISOString: function() {
                        return 1;
                    }
                });
            }), "Date", {
                toJSON: function(t) {
                    var n = o(this), r = i(n);
                    return "number" != typeof r || isFinite(r) ? n.toISOString() : null;
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(3), i = Date.prototype.getTime, u = function(t) {
                return t > 9 ? t : "0" + t;
            };
            e(e.P + e.F * (o(function() {
                return "0385-07-25T07:06:39.999Z" != new Date(-5e13 - 1).toISOString();
            }) || !o(function() {
                new Date(NaN).toISOString();
            })), "Date", {
                toISOString: function() {
                    if (!isFinite(i.call(this))) throw RangeError("Invalid time value");
                    var t = this, n = t.getUTCFullYear(), r = t.getUTCMilliseconds(), e = n < 0 ? "-" : n > 9999 ? "+" : "";
                    return e + ("00000" + Math.abs(n)).slice(e ? -6 : -4) + "-" + u(t.getUTCMonth() + 1) + "-" + u(t.getUTCDate()) + "T" + u(t.getUTCHours()) + ":" + u(t.getUTCMinutes()) + ":" + u(t.getUTCSeconds()) + "." + (r > 99 ? r : "0" + u(r)) + "Z";
                }
            });
        }, function(t, n, r) {
            var e = Date.prototype, o = e.toString, i = e.getTime;
            new Date(NaN) + "" != "Invalid Date" && r(12)(e, "toString", function() {
                var t = i.call(this);
                return t === t ? o.call(this) : "Invalid Date";
            });
        }, function(t, n, r) {
            var e = r(5)("toPrimitive"), o = Date.prototype;
            e in o || r(11)(o, e, r(198));
        }, function(t, n, r) {
            "use strict";
            var e = r(1), o = r(21);
            t.exports = function(t) {
                if ("string" !== t && "number" !== t && "default" !== t) throw TypeError("Incorrect hint");
                return o(e(this), "number" != t);
            };
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Array", {
                isArray: r(63)
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(25), o = r(0), i = r(9), u = r(99), c = r(76), a = r(8), f = r(77), s = r(78);
            o(o.S + o.F * !r(53)(function(t) {
                Array.from(t);
            }), "Array", {
                from: function(t) {
                    var n, r, o, l, v = i(t), h = "function" == typeof this ? this : Array, p = arguments.length, d = p > 1 ? arguments[1] : void 0, y = void 0 !== d, g = 0, b = s(v);
                    if (y && (d = e(d, p > 2 ? arguments[2] : void 0, 2)), void 0 == b || h == Array && c(b)) for (n = a(v.length), 
                    r = new h(n); n > g; g++) f(r, g, y ? d(v[g], g) : v[g]); else for (l = b.call(v), 
                    r = new h(); !(o = l.next()).done; g++) f(r, g, y ? u(l, d, [ o.value, g ], !0) : o.value);
                    return r.length = g, r;
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(77);
            e(e.S + e.F * r(3)(function() {
                function t() {}
                return !(Array.of.call(t) instanceof t);
            }), "Array", {
                of: function() {
                    for (var t = 0, n = arguments.length, r = new ("function" == typeof this ? this : Array)(n); n > t; ) o(r, t, arguments[t++]);
                    return r.length = n, r;
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(14), i = [].join;
            e(e.P + e.F * (r(45) != Object || !r(20)(i)), "Array", {
                join: function(t) {
                    return i.call(o(this), void 0 === t ? "," : t);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(64), i = r(18), u = r(34), c = r(8), a = [].slice;
            e(e.P + e.F * r(3)(function() {
                o && a.call(o);
            }), "Array", {
                slice: function(t, n) {
                    var r = c(this.length), e = i(this);
                    if (n = void 0 === n ? r : n, "Array" == e) return a.call(this, t, n);
                    for (var o = u(t, r), f = u(n, r), s = c(f - o), l = Array(s), v = 0; v < s; v++) l[v] = "String" == e ? this.charAt(o + v) : this[o + v];
                    return l;
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(13), i = r(9), u = r(3), c = [].sort, a = [ 1, 2, 3 ];
            e(e.P + e.F * (u(function() {
                a.sort(void 0);
            }) || !u(function() {
                a.sort(null);
            }) || !r(20)(c)), "Array", {
                sort: function(t) {
                    return void 0 === t ? c.call(i(this)) : c.call(i(this), o(t));
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(23)(0), i = r(20)([].forEach, !0);
            e(e.P + e.F * !i, "Array", {
                forEach: function(t) {
                    return o(this, t, arguments[1]);
                }
            });
        }, function(t, n, r) {
            var e = r(207);
            t.exports = function(t, n) {
                return new (e(t))(n);
            };
        }, function(t, n, r) {
            var e = r(4), o = r(63), i = r(5)("species");
            t.exports = function(t) {
                var n;
                return o(t) && (n = t.constructor, "function" != typeof n || n !== Array && !o(n.prototype) || (n = void 0), 
                e(n) && null === (n = n[i]) && (n = void 0)), void 0 === n ? Array : n;
            };
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(23)(1);
            e(e.P + e.F * !r(20)([].map, !0), "Array", {
                map: function(t) {
                    return o(this, t, arguments[1]);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(23)(2);
            e(e.P + e.F * !r(20)([].filter, !0), "Array", {
                filter: function(t) {
                    return o(this, t, arguments[1]);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(23)(3);
            e(e.P + e.F * !r(20)([].some, !0), "Array", {
                some: function(t) {
                    return o(this, t, arguments[1]);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(23)(4);
            e(e.P + e.F * !r(20)([].every, !0), "Array", {
                every: function(t) {
                    return o(this, t, arguments[1]);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(100);
            e(e.P + e.F * !r(20)([].reduce, !0), "Array", {
                reduce: function(t) {
                    return o(this, t, arguments.length, arguments[1], !1);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(100);
            e(e.P + e.F * !r(20)([].reduceRight, !0), "Array", {
                reduceRight: function(t) {
                    return o(this, t, arguments.length, arguments[1], !0);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(49)(!1), i = [].indexOf, u = !!i && 1 / [ 1 ].indexOf(1, -0) < 0;
            e(e.P + e.F * (u || !r(20)(i)), "Array", {
                indexOf: function(t) {
                    return u ? i.apply(this, arguments) || 0 : o(this, t, arguments[1]);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(14), i = r(30), u = r(8), c = [].lastIndexOf, a = !!c && 1 / [ 1 ].lastIndexOf(1, -0) < 0;
            e(e.P + e.F * (a || !r(20)(c)), "Array", {
                lastIndexOf: function(t) {
                    if (a) return c.apply(this, arguments) || 0;
                    var n = o(this), r = u(n.length), e = r - 1;
                    for (arguments.length > 1 && (e = Math.min(e, i(arguments[1]))), e < 0 && (e = r + e); e >= 0; e--) if (e in n && n[e] === t) return e || 0;
                    return -1;
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.P, "Array", {
                copyWithin: r(101)
            }), r(43)("copyWithin");
        }, function(t, n, r) {
            var e = r(0);
            e(e.P, "Array", {
                fill: r(79)
            }), r(43)("fill");
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(23)(5), i = !0;
            "find" in [] && Array(1).find(function() {
                i = !1;
            }), e(e.P + e.F * i, "Array", {
                find: function(t) {
                    return o(this, t, arguments.length > 1 ? arguments[1] : void 0);
                }
            }), r(43)("find");
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(23)(6), i = "findIndex", u = !0;
            i in [] && Array(1)[i](function() {
                u = !1;
            }), e(e.P + e.F * u, "Array", {
                findIndex: function(t) {
                    return o(this, t, arguments.length > 1 ? arguments[1] : void 0);
                }
            }), r(43)(i);
        }, function(t, n, r) {
            r(37)("Array");
        }, function(t, n, r) {
            var e = r(2), o = r(67), i = r(7).f, u = r(36).f, c = r(52), a = r(54), f = e.RegExp, s = f, l = f.prototype, v = /a/g, h = /a/g, p = new f(v) !== v;
            if (r(6) && (!p || r(3)(function() {
                return h[r(5)("match")] = !1, f(v) != v || f(h) == h || "/a/i" != f(v, "i");
            }))) {
                f = function(t, n) {
                    var r = this instanceof f, e = c(t), i = void 0 === n;
                    return !r && e && t.constructor === f && i ? t : o(p ? new s(e && !i ? t.source : t, n) : s((e = t instanceof f) ? t.source : t, e && i ? a.call(t) : n), r ? this : l, f);
                };
                for (var d = u(s), y = 0; d.length > y; ) !function(t) {
                    t in f || i(f, t, {
                        configurable: !0,
                        get: function() {
                            return s[t];
                        },
                        set: function(n) {
                            s[t] = n;
                        }
                    });
                }(d[y++]);
                l.constructor = f, f.prototype = l, r(12)(e, "RegExp", f);
            }
            r(37)("RegExp");
        }, function(t, n, r) {
            "use strict";
            r(103);
            var e = r(1), o = r(54), i = r(6), u = /./.toString, c = function(t) {
                r(12)(RegExp.prototype, "toString", t, !0);
            };
            r(3)(function() {
                return "/a/b" != u.call({
                    source: "a",
                    flags: "b"
                });
            }) ? c(function() {
                var t = e(this);
                return "/".concat(t.source, "/", "flags" in t ? t.flags : !i && t instanceof RegExp ? o.call(t) : void 0);
            }) : "toString" != u.name && c(function() {
                return u.call(this);
            });
        }, function(t, n, r) {
            r(55)("match", 1, function(t, n, r) {
                return [ function(r) {
                    "use strict";
                    var e = t(this), o = void 0 == r ? void 0 : r[n];
                    return void 0 !== o ? o.call(r, e) : new RegExp(r)[n](String(e));
                }, r ];
            });
        }, function(t, n, r) {
            r(55)("replace", 2, function(t, n, r) {
                return [ function(e, o) {
                    "use strict";
                    var i = t(this), u = void 0 == e ? void 0 : e[n];
                    return void 0 !== u ? u.call(e, i, o) : r.call(String(i), e, o);
                }, r ];
            });
        }, function(t, n, r) {
            r(55)("search", 1, function(t, n, r) {
                return [ function(r) {
                    "use strict";
                    var e = t(this), o = void 0 == r ? void 0 : r[n];
                    return void 0 !== o ? o.call(r, e) : new RegExp(r)[n](String(e));
                }, r ];
            });
        }, function(t, n, r) {
            r(55)("split", 2, function(t, n, e) {
                "use strict";
                var o = r(52), i = e, u = [].push, c = "length";
                if ("c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1)[c] || 2 != "ab".split(/(?:ab)*/)[c] || 4 != ".".split(/(.?)(.?)/)[c] || ".".split(/()()/)[c] > 1 || "".split(/.?/)[c]) {
                    var a = void 0 === /()??/.exec("")[1];
                    e = function(t, n) {
                        var r = String(this);
                        if (void 0 === t && 0 === n) return [];
                        if (!o(t)) return i.call(r, t, n);
                        var e, f, s, l, v, h = [], p = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), d = 0, y = void 0 === n ? 4294967295 : n >>> 0, g = new RegExp(t.source, p + "g");
                        for (a || (e = new RegExp("^" + g.source + "$(?!\\s)", p)); (f = g.exec(r)) && !((s = f.index + f[0][c]) > d && (h.push(r.slice(d, f.index)), 
                        !a && f[c] > 1 && f[0].replace(e, function() {
                            for (v = 1; v < arguments[c] - 2; v++) void 0 === arguments[v] && (f[v] = void 0);
                        }), f[c] > 1 && f.index < r[c] && u.apply(h, f.slice(1)), l = f[0][c], d = s, h[c] >= y)); ) g.lastIndex === f.index && g.lastIndex++;
                        return d === r[c] ? !l && g.test("") || h.push("") : h.push(r.slice(d)), h[c] > y ? h.slice(0, y) : h;
                    };
                } else "0".split(void 0, 0)[c] && (e = function(t, n) {
                    return void 0 === t && 0 === n ? [] : i.call(this, t, n);
                });
                return [ function(r, o) {
                    var i = t(this), u = void 0 == r ? void 0 : r[n];
                    return void 0 !== u ? u.call(r, i, o) : e.call(String(i), r, o);
                }, e ];
            });
        }, function(t, n, r) {
            "use strict";
            var e, o, i, u = r(32), c = r(2), a = r(25), f = r(47), s = r(0), l = r(4), v = r(13), h = r(38), p = r(44), d = r(81), y = r(82).set, g = r(83)(), b = c.TypeError, m = c.process, x = c.Promise, m = c.process, w = "process" == f(m), S = function() {}, _ = !!function() {
                try {
                    var t = x.resolve(1), n = (t.constructor = {})[r(5)("species")] = function(t) {
                        t(S, S);
                    };
                    return (w || "function" == typeof PromiseRejectionEvent) && t.then(S) instanceof n;
                } catch (t) {}
            }(), E = function(t, n) {
                return t === n || t === x && n === i;
            }, O = function(t) {
                var n;
                return !(!l(t) || "function" != typeof (n = t.then)) && n;
            }, P = function(t) {
                return E(x, t) ? new A(t) : new o(t);
            }, A = o = function(t) {
                var n, r;
                this.promise = new t(function(t, e) {
                    if (void 0 !== n || void 0 !== r) throw b("Bad Promise constructor");
                    n = t, r = e;
                }), this.resolve = v(n), this.reject = v(r);
            }, j = function(t) {
                try {
                    t();
                } catch (t) {
                    return {
                        error: t
                    };
                }
            }, I = function(t, n) {
                if (!t._n) {
                    t._n = !0;
                    var r = t._c;
                    g(function() {
                        for (var e = t._v, o = 1 == t._s, i = 0; r.length > i; ) !function(n) {
                            var r, i, u = o ? n.ok : n.fail, c = n.resolve, a = n.reject, f = n.domain;
                            try {
                                u ? (o || (2 == t._h && R(t), t._h = 1), !0 === u ? r = e : (f && f.enter(), r = u(e), 
                                f && f.exit()), r === n.promise ? a(b("Promise-chain cycle")) : (i = O(r)) ? i.call(r, c, a) : c(r)) : a(e);
                            } catch (t) {
                                a(t);
                            }
                        }(r[i++]);
                        t._c = [], t._n = !1, n && !t._h && N(t);
                    });
                }
            }, N = function(t) {
                y.call(c, function() {
                    var n, r, e, o = t._v;
                    if (F(t) && (n = j(function() {
                        w ? m.emit("unhandledRejection", o, t) : (r = c.onunhandledrejection) ? r({
                            promise: t,
                            reason: o
                        }) : (e = c.console) && e.error && e.error("Unhandled promise rejection", o);
                    }), t._h = w || F(t) ? 2 : 1), t._a = void 0, n) throw n.error;
                });
            }, F = function(t) {
                if (1 == t._h) return !1;
                for (var n, r = t._a || t._c, e = 0; r.length > e; ) if (n = r[e++], n.fail || !F(n.promise)) return !1;
                return !0;
            }, R = function(t) {
                y.call(c, function() {
                    var n;
                    w ? m.emit("rejectionHandled", t) : (n = c.onrejectionhandled) && n({
                        promise: t,
                        reason: t._v
                    });
                });
            }, M = function(t) {
                var n = this;
                n._d || (n._d = !0, n = n._w || n, n._v = t, n._s = 2, n._a || (n._a = n._c.slice()), 
                I(n, !0));
            }, T = function(t) {
                var n, r = this;
                if (!r._d) {
                    r._d = !0, r = r._w || r;
                    try {
                        if (r === t) throw b("Promise can't be resolved itself");
                        (n = O(t)) ? g(function() {
                            var e = {
                                _w: r,
                                _d: !1
                            };
                            try {
                                n.call(t, a(T, e, 1), a(M, e, 1));
                            } catch (t) {
                                M.call(e, t);
                            }
                        }) : (r._v = t, r._s = 1, I(r, !1));
                    } catch (t) {
                        M.call({
                            _w: r,
                            _d: !1
                        }, t);
                    }
                }
            };
            _ || (x = function(t) {
                h(this, x, "Promise", "_h"), v(t), e.call(this);
                try {
                    t(a(T, this, 1), a(M, this, 1));
                } catch (t) {
                    M.call(this, t);
                }
            }, e = function(t) {
                this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, 
                this._n = !1;
            }, e.prototype = r(39)(x.prototype, {
                then: function(t, n) {
                    var r = P(d(this, x));
                    return r.ok = "function" != typeof t || t, r.fail = "function" == typeof n && n, 
                    r.domain = w ? m.domain : void 0, this._c.push(r), this._a && this._a.push(r), this._s && I(this, !1), 
                    r.promise;
                },
                catch: function(t) {
                    return this.then(void 0, t);
                }
            }), A = function() {
                var t = new e();
                this.promise = t, this.resolve = a(T, t, 1), this.reject = a(M, t, 1);
            }), s(s.G + s.W + s.F * !_, {
                Promise: x
            }), r(40)(x, "Promise"), r(37)("Promise"), i = r(24).Promise, s(s.S + s.F * !_, "Promise", {
                reject: function(t) {
                    var n = P(this);
                    return (0, n.reject)(t), n.promise;
                }
            }), s(s.S + s.F * (u || !_), "Promise", {
                resolve: function(t) {
                    if (t instanceof x && E(t.constructor, this)) return t;
                    var n = P(this);
                    return (0, n.resolve)(t), n.promise;
                }
            }), s(s.S + s.F * !(_ && r(53)(function(t) {
                x.all(t).catch(S);
            })), "Promise", {
                all: function(t) {
                    var n = this, r = P(n), e = r.resolve, o = r.reject, i = j(function() {
                        var r = [], i = 0, u = 1;
                        p(t, !1, function(t) {
                            var c = i++, a = !1;
                            r.push(void 0), u++, n.resolve(t).then(function(t) {
                                a || (a = !0, r[c] = t, --u || e(r));
                            }, o);
                        }), --u || e(r);
                    });
                    return i && o(i.error), r.promise;
                },
                race: function(t) {
                    var n = this, r = P(n), e = r.reject, o = j(function() {
                        p(t, !1, function(t) {
                            n.resolve(t).then(r.resolve, e);
                        });
                    });
                    return o && e(o.error), r.promise;
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(108);
            r(56)("WeakSet", function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0);
                };
            }, {
                add: function(t) {
                    return e.def(this, t, !0);
                }
            }, e, !1, !0);
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(57), i = r(84), u = r(1), c = r(34), a = r(8), f = r(4), s = r(2).ArrayBuffer, l = r(81), v = i.ArrayBuffer, h = i.DataView, p = o.ABV && s.isView, d = v.prototype.slice, y = o.VIEW;
            e(e.G + e.W + e.F * (s !== v), {
                ArrayBuffer: v
            }), e(e.S + e.F * !o.CONSTR, "ArrayBuffer", {
                isView: function(t) {
                    return p && p(t) || f(t) && y in t;
                }
            }), e(e.P + e.U + e.F * r(3)(function() {
                return !new v(2).slice(1, void 0).byteLength;
            }), "ArrayBuffer", {
                slice: function(t, n) {
                    if (void 0 !== d && void 0 === n) return d.call(u(this), t);
                    for (var r = u(this).byteLength, e = c(t, r), o = c(void 0 === n ? r : n, r), i = new (l(this, v))(a(o - e)), f = new h(this), s = new h(i), p = 0; e < o; ) s.setUint8(p++, f.getUint8(e++));
                    return i;
                }
            }), r(37)("ArrayBuffer");
        }, function(t, n, r) {
            var e = r(0);
            e(e.G + e.W + e.F * !r(57).ABV, {
                DataView: r(84).DataView
            });
        }, function(t, n, r) {
            r(26)("Int8", 1, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            });
        }, function(t, n, r) {
            r(26)("Uint8", 1, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            });
        }, function(t, n, r) {
            r(26)("Uint8", 1, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            }, !0);
        }, function(t, n, r) {
            r(26)("Int16", 2, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            });
        }, function(t, n, r) {
            r(26)("Uint16", 2, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            });
        }, function(t, n, r) {
            r(26)("Int32", 4, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            });
        }, function(t, n, r) {
            r(26)("Uint32", 4, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            });
        }, function(t, n, r) {
            r(26)("Float32", 4, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            });
        }, function(t, n, r) {
            r(26)("Float64", 8, function(t) {
                return function(n, r, e) {
                    return t(this, n, r, e);
                };
            });
        }, function(t, n, r) {
            var e = r(0), o = r(13), i = r(1), u = (r(2).Reflect || {}).apply, c = Function.apply;
            e(e.S + e.F * !r(3)(function() {
                u(function() {});
            }), "Reflect", {
                apply: function(t, n, r) {
                    var e = o(t), a = i(r);
                    return u ? u(e, n, a) : c.call(e, n, a);
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(35), i = r(13), u = r(1), c = r(4), a = r(3), f = r(93), s = (r(2).Reflect || {}).construct, l = a(function() {
                function t() {}
                return !(s(function() {}, [], t) instanceof t);
            }), v = !a(function() {
                s(function() {});
            });
            e(e.S + e.F * (l || v), "Reflect", {
                construct: function(t, n) {
                    i(t), u(n);
                    var r = arguments.length < 3 ? t : i(arguments[2]);
                    if (v && !l) return s(t, n, r);
                    if (t == r) {
                        switch (n.length) {
                          case 0:
                            return new t();

                          case 1:
                            return new t(n[0]);

                          case 2:
                            return new t(n[0], n[1]);

                          case 3:
                            return new t(n[0], n[1], n[2]);

                          case 4:
                            return new t(n[0], n[1], n[2], n[3]);
                        }
                        var e = [ null ];
                        return e.push.apply(e, n), new (f.apply(t, e))();
                    }
                    var a = r.prototype, h = o(c(a) ? a : Object.prototype), p = Function.apply.call(t, h, n);
                    return c(p) ? p : h;
                }
            });
        }, function(t, n, r) {
            var e = r(7), o = r(0), i = r(1), u = r(21);
            o(o.S + o.F * r(3)(function() {
                Reflect.defineProperty(e.f({}, 1, {
                    value: 1
                }), 1, {
                    value: 2
                });
            }), "Reflect", {
                defineProperty: function(t, n, r) {
                    i(t), n = u(n, !0), i(r);
                    try {
                        return e.f(t, n, r), !0;
                    } catch (t) {
                        return !1;
                    }
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(16).f, i = r(1);
            e(e.S, "Reflect", {
                deleteProperty: function(t, n) {
                    var r = o(i(t), n);
                    return !(r && !r.configurable) && delete t[n];
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(1), i = function(t) {
                this._t = o(t), this._i = 0;
                var n, r = this._k = [];
                for (n in t) r.push(n);
            };
            r(73)(i, "Object", function() {
                var t, n = this, r = n._k;
                do if (n._i >= r.length) return {
                    value: void 0,
                    done: !0
                }; while (!((t = r[n._i++]) in n._t));
                return {
                    value: t,
                    done: !1
                };
            }), e(e.S, "Reflect", {
                enumerate: function(t) {
                    return new i(t);
                }
            });
        }, function(t, n, r) {
            function e(t, n) {
                var r, c, s = arguments.length < 3 ? t : arguments[2];
                return f(t) === s ? t[n] : (r = o.f(t, n)) ? u(r, "value") ? r.value : void 0 !== r.get ? r.get.call(s) : void 0 : a(c = i(t)) ? e(c, n, s) : void 0;
            }
            var o = r(16), i = r(17), u = r(10), c = r(0), a = r(4), f = r(1);
            c(c.S, "Reflect", {
                get: e
            });
        }, function(t, n, r) {
            var e = r(16), o = r(0), i = r(1);
            o(o.S, "Reflect", {
                getOwnPropertyDescriptor: function(t, n) {
                    return e.f(i(t), n);
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(17), i = r(1);
            e(e.S, "Reflect", {
                getPrototypeOf: function(t) {
                    return o(i(t));
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Reflect", {
                has: function(t, n) {
                    return n in t;
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(1), i = Object.isExtensible;
            e(e.S, "Reflect", {
                isExtensible: function(t) {
                    return o(t), !i || i(t);
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Reflect", {
                ownKeys: r(109)
            });
        }, function(t, n, r) {
            var e = r(0), o = r(1), i = Object.preventExtensions;
            e(e.S, "Reflect", {
                preventExtensions: function(t) {
                    o(t);
                    try {
                        return i && i(t), !0;
                    } catch (t) {
                        return !1;
                    }
                }
            });
        }, function(t, n, r) {
            function e(t, n, r) {
                var a, v, h = arguments.length < 4 ? t : arguments[3], p = i.f(s(t), n);
                if (!p) {
                    if (l(v = u(t))) return e(v, n, r, h);
                    p = f(0);
                }
                return c(p, "value") ? !(!1 === p.writable || !l(h)) && (a = i.f(h, n) || f(0), 
                a.value = r, o.f(h, n, a), !0) : void 0 !== p.set && (p.set.call(h, r), !0);
            }
            var o = r(7), i = r(16), u = r(17), c = r(10), a = r(0), f = r(28), s = r(1), l = r(4);
            a(a.S, "Reflect", {
                set: e
            });
        }, function(t, n, r) {
            var e = r(0), o = r(65);
            o && e(e.S, "Reflect", {
                setPrototypeOf: function(t, n) {
                    o.check(t, n);
                    try {
                        return o.set(t, n), !0;
                    } catch (t) {
                        return !1;
                    }
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(49)(!0);
            e(e.P, "Array", {
                includes: function(t) {
                    return o(this, t, arguments.length > 1 ? arguments[1] : void 0);
                }
            }), r(43)("includes");
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(71)(!0);
            e(e.P, "String", {
                at: function(t) {
                    return o(this, t);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(110);
            e(e.P, "String", {
                padStart: function(t) {
                    return o(this, t, arguments.length > 1 ? arguments[1] : void 0, !0);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(110);
            e(e.P, "String", {
                padEnd: function(t) {
                    return o(this, t, arguments.length > 1 ? arguments[1] : void 0, !1);
                }
            });
        }, function(t, n, r) {
            "use strict";
            r(41)("trimLeft", function(t) {
                return function() {
                    return t(this, 1);
                };
            }, "trimStart");
        }, function(t, n, r) {
            "use strict";
            r(41)("trimRight", function(t) {
                return function() {
                    return t(this, 2);
                };
            }, "trimEnd");
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(19), i = r(8), u = r(52), c = r(54), a = RegExp.prototype, f = function(t, n) {
                this._r = t, this._s = n;
            };
            r(73)(f, "RegExp String", function() {
                var t = this._r.exec(this._s);
                return {
                    value: t,
                    done: null === t
                };
            }), e(e.P, "String", {
                matchAll: function(t) {
                    if (o(this), !u(t)) throw TypeError(t + " is not a regexp!");
                    var n = String(this), r = "flags" in a ? String(t.flags) : c.call(t), e = new RegExp(t.source, ~r.indexOf("g") ? r : "g" + r);
                    return e.lastIndex = i(t.lastIndex), new f(e, n);
                }
            });
        }, function(t, n, r) {
            r(60)("asyncIterator");
        }, function(t, n, r) {
            r(60)("observable");
        }, function(t, n, r) {
            var e = r(0), o = r(109), i = r(14), u = r(16), c = r(77);
            e(e.S, "Object", {
                getOwnPropertyDescriptors: function(t) {
                    for (var n, r = i(t), e = u.f, a = o(r), f = {}, s = 0; a.length > s; ) c(f, n = a[s++], e(r, n));
                    return f;
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(111)(!1);
            e(e.S, "Object", {
                values: function(t) {
                    return o(t);
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(111)(!0);
            e(e.S, "Object", {
                entries: function(t) {
                    return o(t);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(9), i = r(13), u = r(7);
            r(6) && e(e.P + r(58), "Object", {
                __defineGetter__: function(t, n) {
                    u.f(o(this), t, {
                        get: i(n),
                        enumerable: !0,
                        configurable: !0
                    });
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(9), i = r(13), u = r(7);
            r(6) && e(e.P + r(58), "Object", {
                __defineSetter__: function(t, n) {
                    u.f(o(this), t, {
                        set: i(n),
                        enumerable: !0,
                        configurable: !0
                    });
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(9), i = r(21), u = r(17), c = r(16).f;
            r(6) && e(e.P + r(58), "Object", {
                __lookupGetter__: function(t) {
                    var n, r = o(this), e = i(t, !0);
                    do if (n = c(r, e)) return n.get; while (r = u(r));
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(9), i = r(21), u = r(17), c = r(16).f;
            r(6) && e(e.P + r(58), "Object", {
                __lookupSetter__: function(t) {
                    var n, r = o(this), e = i(t, !0);
                    do if (n = c(r, e)) return n.set; while (r = u(r));
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.P + e.R, "Map", {
                toJSON: r(112)("Map")
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.P + e.R, "Set", {
                toJSON: r(112)("Set")
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "System", {
                global: r(2)
            });
        }, function(t, n, r) {
            var e = r(0), o = r(18);
            e(e.S, "Error", {
                isError: function(t) {
                    return "Error" === o(t);
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                iaddh: function(t, n, r, e) {
                    var o = t >>> 0, i = n >>> 0, u = r >>> 0;
                    return i + (e >>> 0) + ((o & u | (o | u) & ~(o + u >>> 0)) >>> 31) | 0;
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                isubh: function(t, n, r, e) {
                    var o = t >>> 0, i = n >>> 0, u = r >>> 0;
                    return i - (e >>> 0) - ((~o & u | ~(o ^ u) & o - u >>> 0) >>> 31) | 0;
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                imulh: function(t, n) {
                    var r = +t, e = +n, o = 65535 & r, i = 65535 & e, u = r >> 16, c = e >> 16, a = (u * i >>> 0) + (o * i >>> 16);
                    return u * c + (a >> 16) + ((o * c >>> 0) + (65535 & a) >> 16);
                }
            });
        }, function(t, n, r) {
            var e = r(0);
            e(e.S, "Math", {
                umulh: function(t, n) {
                    var r = +t, e = +n, o = 65535 & r, i = 65535 & e, u = r >>> 16, c = e >>> 16, a = (u * i >>> 0) + (o * i >>> 16);
                    return u * c + (a >>> 16) + ((o * c >>> 0) + (65535 & a) >>> 16);
                }
            });
        }, function(t, n, r) {
            var e = r(27), o = r(1), i = e.key, u = e.set;
            e.exp({
                defineMetadata: function(t, n, r, e) {
                    u(t, n, o(r), i(e));
                }
            });
        }, function(t, n, r) {
            var e = r(27), o = r(1), i = e.key, u = e.map, c = e.store;
            e.exp({
                deleteMetadata: function(t, n) {
                    var r = arguments.length < 3 ? void 0 : i(arguments[2]), e = u(o(n), r, !1);
                    if (void 0 === e || !e.delete(t)) return !1;
                    if (e.size) return !0;
                    var a = c.get(n);
                    return a.delete(r), !!a.size || c.delete(n);
                }
            });
        }, function(t, n, r) {
            var e = r(27), o = r(1), i = r(17), u = e.has, c = e.get, a = e.key, f = function(t, n, r) {
                if (u(t, n, r)) return c(t, n, r);
                var e = i(n);
                return null !== e ? f(t, e, r) : void 0;
            };
            e.exp({
                getMetadata: function(t, n) {
                    return f(t, o(n), arguments.length < 3 ? void 0 : a(arguments[2]));
                }
            });
        }, function(t, n, r) {
            var e = r(106), o = r(113), i = r(27), u = r(1), c = r(17), a = i.keys, f = i.key, s = function(t, n) {
                var r = a(t, n), i = c(t);
                if (null === i) return r;
                var u = s(i, n);
                return u.length ? r.length ? o(new e(r.concat(u))) : u : r;
            };
            i.exp({
                getMetadataKeys: function(t) {
                    return s(u(t), arguments.length < 2 ? void 0 : f(arguments[1]));
                }
            });
        }, function(t, n, r) {
            var e = r(27), o = r(1), i = e.get, u = e.key;
            e.exp({
                getOwnMetadata: function(t, n) {
                    return i(t, o(n), arguments.length < 3 ? void 0 : u(arguments[2]));
                }
            });
        }, function(t, n, r) {
            var e = r(27), o = r(1), i = e.keys, u = e.key;
            e.exp({
                getOwnMetadataKeys: function(t) {
                    return i(o(t), arguments.length < 2 ? void 0 : u(arguments[1]));
                }
            });
        }, function(t, n, r) {
            var e = r(27), o = r(1), i = r(17), u = e.has, c = e.key, a = function(t, n, r) {
                if (u(t, n, r)) return !0;
                var e = i(n);
                return null !== e && a(t, e, r);
            };
            e.exp({
                hasMetadata: function(t, n) {
                    return a(t, o(n), arguments.length < 3 ? void 0 : c(arguments[2]));
                }
            });
        }, function(t, n, r) {
            var e = r(27), o = r(1), i = e.has, u = e.key;
            e.exp({
                hasOwnMetadata: function(t, n) {
                    return i(t, o(n), arguments.length < 3 ? void 0 : u(arguments[2]));
                }
            });
        }, function(t, n, r) {
            var e = r(27), o = r(1), i = r(13), u = e.key, c = e.set;
            e.exp({
                metadata: function(t, n) {
                    return function(r, e) {
                        c(t, n, (void 0 !== e ? o : i)(r), u(e));
                    };
                }
            });
        }, function(t, n, r) {
            var e = r(0), o = r(83)(), i = r(2).process, u = "process" == r(18)(i);
            e(e.G, {
                asap: function(t) {
                    var n = u && i.domain;
                    o(n ? n.bind(t) : t);
                }
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(0), o = r(2), i = r(24), u = r(83)(), c = r(5)("observable"), a = r(13), f = r(1), s = r(38), l = r(39), v = r(11), h = r(44), p = h.RETURN, d = function(t) {
                return null == t ? void 0 : a(t);
            }, y = function(t) {
                var n = t._c;
                n && (t._c = void 0, n());
            }, g = function(t) {
                return void 0 === t._o;
            }, b = function(t) {
                g(t) || (t._o = void 0, y(t));
            }, m = function(t, n) {
                f(t), this._c = void 0, this._o = t, t = new x(this);
                try {
                    var r = n(t), e = r;
                    null != r && ("function" == typeof r.unsubscribe ? r = function() {
                        e.unsubscribe();
                    } : a(r), this._c = r);
                } catch (n) {
                    return void t.error(n);
                }
                g(this) && y(this);
            };
            m.prototype = l({}, {
                unsubscribe: function() {
                    b(this);
                }
            });
            var x = function(t) {
                this._s = t;
            };
            x.prototype = l({}, {
                next: function(t) {
                    var n = this._s;
                    if (!g(n)) {
                        var r = n._o;
                        try {
                            var e = d(r.next);
                            if (e) return e.call(r, t);
                        } catch (t) {
                            try {
                                b(n);
                            } finally {
                                throw t;
                            }
                        }
                    }
                },
                error: function(t) {
                    var n = this._s;
                    if (g(n)) throw t;
                    var r = n._o;
                    n._o = void 0;
                    try {
                        var e = d(r.error);
                        if (!e) throw t;
                        t = e.call(r, t);
                    } catch (t) {
                        try {
                            y(n);
                        } finally {
                            throw t;
                        }
                    }
                    return y(n), t;
                },
                complete: function(t) {
                    var n = this._s;
                    if (!g(n)) {
                        var r = n._o;
                        n._o = void 0;
                        try {
                            var e = d(r.complete);
                            t = e ? e.call(r, t) : void 0;
                        } catch (t) {
                            try {
                                y(n);
                            } finally {
                                throw t;
                            }
                        }
                        return y(n), t;
                    }
                }
            });
            var w = function(t) {
                s(this, w, "Observable", "_f")._f = a(t);
            };
            l(w.prototype, {
                subscribe: function(t) {
                    return new m(t, this._f);
                },
                forEach: function(t) {
                    var n = this;
                    return new (i.Promise || o.Promise)(function(r, e) {
                        a(t);
                        var o = n.subscribe({
                            next: function(n) {
                                try {
                                    return t(n);
                                } catch (t) {
                                    e(t), o.unsubscribe();
                                }
                            },
                            error: e,
                            complete: r
                        });
                    });
                }
            }), l(w, {
                from: function(t) {
                    var n = "function" == typeof this ? this : w, r = d(f(t)[c]);
                    if (r) {
                        var e = f(r.call(t));
                        return e.constructor === n ? e : new n(function(t) {
                            return e.subscribe(t);
                        });
                    }
                    return new n(function(n) {
                        var r = !1;
                        return u(function() {
                            if (!r) {
                                try {
                                    if (h(t, !1, function(t) {
                                        if (n.next(t), r) return p;
                                    }) === p) return;
                                } catch (t) {
                                    if (r) throw t;
                                    return void n.error(t);
                                }
                                n.complete();
                            }
                        }), function() {
                            r = !0;
                        };
                    });
                },
                of: function() {
                    for (var t = 0, n = arguments.length, r = Array(n); t < n; ) r[t] = arguments[t++];
                    return new ("function" == typeof this ? this : w)(function(t) {
                        var n = !1;
                        return u(function() {
                            if (!n) {
                                for (var e = 0; e < r.length; ++e) if (t.next(r[e]), n) return;
                                t.complete();
                            }
                        }), function() {
                            n = !0;
                        };
                    });
                }
            }), v(w.prototype, c, function() {
                return this;
            }), e(e.G, {
                Observable: w
            }), r(37)("Observable");
        }, function(t, n, r) {
            var e = r(2), o = r(0), i = r(51), u = r(290), c = e.navigator, a = !!c && /MSIE .\./.test(c.userAgent), f = function(t) {
                return a ? function(n, r) {
                    return t(i(u, [].slice.call(arguments, 2), "function" == typeof n ? n : Function(n)), r);
                } : t;
            };
            o(o.G + o.B + o.F * a, {
                setTimeout: f(e.setTimeout),
                setInterval: f(e.setInterval)
            });
        }, function(t, n, r) {
            "use strict";
            var e = r(291), o = r(51), i = r(13);
            t.exports = function() {
                for (var t = i(this), n = arguments.length, r = Array(n), u = 0, c = e._, a = !1; n > u; ) (r[u] = arguments[u++]) === c && (a = !0);
                return function() {
                    var e, i = this, u = arguments.length, f = 0, s = 0;
                    if (!a && !u) return o(t, r, i);
                    if (e = r.slice(), a) for (;n > f; f++) e[f] === c && (e[f] = arguments[s++]);
                    for (;u > s; ) e.push(arguments[s++]);
                    return o(t, e, i);
                };
            };
        }, function(t, n, r) {
            t.exports = r(2);
        }, function(t, n, r) {
            var e = r(0), o = r(82);
            e(e.G + e.B, {
                setImmediate: o.set,
                clearImmediate: o.clear
            });
        }, function(t, n, r) {
            for (var e = r(80), o = r(12), i = r(2), u = r(11), c = r(42), a = r(5), f = a("iterator"), s = a("toStringTag"), l = c.Array, v = [ "NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList" ], h = 0; h < 5; h++) {
                var p, d = v[h], y = i[d], g = y && y.prototype;
                if (g) {
                    g[f] || u(g, f, l), g[s] || u(g, s, d), c[d] = l;
                    for (p in e) g[p] || o(g, p, e[p], !0);
                }
            }
        }, function(t, n, r) {
            (function(n) {
                !function(n) {
                    "use strict";
                    function r(t, n, r, e) {
                        var i = n && n.prototype instanceof o ? n : o, u = Object.create(i.prototype), c = new h(e || []);
                        return u._invoke = f(t, r, c), u;
                    }
                    function e(t, n, r) {
                        try {
                            return {
                                type: "normal",
                                arg: t.call(n, r)
                            };
                        } catch (t) {
                            return {
                                type: "throw",
                                arg: t
                            };
                        }
                    }
                    function o() {}
                    function i() {}
                    function u() {}
                    function c(t) {
                        [ "next", "throw", "return" ].forEach(function(n) {
                            t[n] = function(t) {
                                return this._invoke(n, t);
                            };
                        });
                    }
                    function a(t) {
                        function r(n, o, i, u) {
                            var c = e(t[n], t, o);
                            if ("throw" !== c.type) {
                                var a = c.arg, f = a.value;
                                return f && "object" == typeof f && b.call(f, "__await") ? Promise.resolve(f.__await).then(function(t) {
                                    r("next", t, i, u);
                                }, function(t) {
                                    r("throw", t, i, u);
                                }) : Promise.resolve(f).then(function(t) {
                                    a.value = t, i(a);
                                }, u);
                            }
                            u(c.arg);
                        }
                        function o(t, n) {
                            function e() {
                                return new Promise(function(e, o) {
                                    r(t, n, e, o);
                                });
                            }
                            return i = i ? i.then(e, e) : e();
                        }
                        "object" == typeof n.process && n.process.domain && (r = n.process.domain.bind(r));
                        var i;
                        this._invoke = o;
                    }
                    function f(t, n, r) {
                        var o = O;
                        return function(i, u) {
                            if (o === A) throw new Error("Generator is already running");
                            if (o === j) {
                                if ("throw" === i) throw u;
                                return d();
                            }
                            for (r.method = i, r.arg = u; ;) {
                                var c = r.delegate;
                                if (c) {
                                    var a = s(c, r);
                                    if (a) {
                                        if (a === I) continue;
                                        return a;
                                    }
                                }
                                if ("next" === r.method) r.sent = r._sent = r.arg; else if ("throw" === r.method) {
                                    if (o === O) throw o = j, r.arg;
                                    r.dispatchException(r.arg);
                                } else "return" === r.method && r.abrupt("return", r.arg);
                                o = A;
                                var f = e(t, n, r);
                                if ("normal" === f.type) {
                                    if (o = r.done ? j : P, f.arg === I) continue;
                                    return {
                                        value: f.arg,
                                        done: r.done
                                    };
                                }
                                "throw" === f.type && (o = j, r.method = "throw", r.arg = f.arg);
                            }
                        };
                    }
                    function s(t, n) {
                        var r = t.iterator[n.method];
                        if (r === y) {
                            if (n.delegate = null, "throw" === n.method) {
                                if (t.iterator.return && (n.method = "return", n.arg = y, s(t, n), "throw" === n.method)) return I;
                                n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method");
                            }
                            return I;
                        }
                        var o = e(r, t.iterator, n.arg);
                        if ("throw" === o.type) return n.method = "throw", n.arg = o.arg, n.delegate = null, 
                        I;
                        var i = o.arg;
                        return i ? i.done ? (n[t.resultName] = i.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", 
                        n.arg = y), n.delegate = null, I) : i : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), 
                        n.delegate = null, I);
                    }
                    function l(t) {
                        var n = {
                            tryLoc: t[0]
                        };
                        1 in t && (n.catchLoc = t[1]), 2 in t && (n.finallyLoc = t[2], n.afterLoc = t[3]), 
                        this.tryEntries.push(n);
                    }
                    function v(t) {
                        var n = t.completion || {};
                        n.type = "normal", delete n.arg, t.completion = n;
                    }
                    function h(t) {
                        this.tryEntries = [ {
                            tryLoc: "root"
                        } ], t.forEach(l, this), this.reset(!0);
                    }
                    function p(t) {
                        if (t) {
                            var n = t[x];
                            if (n) return n.call(t);
                            if ("function" == typeof t.next) return t;
                            if (!isNaN(t.length)) {
                                var r = -1, e = function n() {
                                    for (;++r < t.length; ) if (b.call(t, r)) return n.value = t[r], n.done = !1, n;
                                    return n.value = y, n.done = !0, n;
                                };
                                return e.next = e;
                            }
                        }
                        return {
                            next: d
                        };
                    }
                    function d() {
                        return {
                            value: y,
                            done: !0
                        };
                    }
                    var y, g = Object.prototype, b = g.hasOwnProperty, m = "function" == typeof Symbol ? Symbol : {}, x = m.iterator || "@@iterator", w = m.asyncIterator || "@@asyncIterator", S = m.toStringTag || "@@toStringTag", _ = "object" == typeof t, E = n.regeneratorRuntime;
                    if (E) return void (_ && (t.exports = E));
                    E = n.regeneratorRuntime = _ ? t.exports : {}, E.wrap = r;
                    var O = "suspendedStart", P = "suspendedYield", A = "executing", j = "completed", I = {}, N = {};
                    N[x] = function() {
                        return this;
                    };
                    var F = Object.getPrototypeOf, R = F && F(F(p([])));
                    R && R !== g && b.call(R, x) && (N = R);
                    var M = u.prototype = o.prototype = Object.create(N);
                    i.prototype = M.constructor = u, u.constructor = i, u[S] = i.displayName = "GeneratorFunction", 
                    E.isGeneratorFunction = function(t) {
                        var n = "function" == typeof t && t.constructor;
                        return !!n && (n === i || "GeneratorFunction" === (n.displayName || n.name));
                    }, E.mark = function(t) {
                        return Object.setPrototypeOf ? Object.setPrototypeOf(t, u) : (t.__proto__ = u, S in t || (t[S] = "GeneratorFunction")), 
                        t.prototype = Object.create(M), t;
                    }, E.awrap = function(t) {
                        return {
                            __await: t
                        };
                    }, c(a.prototype), a.prototype[w] = function() {
                        return this;
                    }, E.AsyncIterator = a, E.async = function(t, n, e, o) {
                        var i = new a(r(t, n, e, o));
                        return E.isGeneratorFunction(n) ? i : i.next().then(function(t) {
                            return t.done ? t.value : i.next();
                        });
                    }, c(M), M[S] = "Generator", M[x] = function() {
                        return this;
                    }, M.toString = function() {
                        return "[object Generator]";
                    }, E.keys = function(t) {
                        var n = [];
                        for (var r in t) n.push(r);
                        return n.reverse(), function r() {
                            for (;n.length; ) {
                                var e = n.pop();
                                if (e in t) return r.value = e, r.done = !1, r;
                            }
                            return r.done = !0, r;
                        };
                    }, E.values = p, h.prototype = {
                        constructor: h,
                        reset: function(t) {
                            if (this.prev = 0, this.next = 0, this.sent = this._sent = y, this.done = !1, this.delegate = null, 
                            this.method = "next", this.arg = y, this.tryEntries.forEach(v), !t) for (var n in this) "t" === n.charAt(0) && b.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = y);
                        },
                        stop: function() {
                            this.done = !0;
                            var t = this.tryEntries[0], n = t.completion;
                            if ("throw" === n.type) throw n.arg;
                            return this.rval;
                        },
                        dispatchException: function(t) {
                            function n(n, e) {
                                return i.type = "throw", i.arg = t, r.next = n, e && (r.method = "next", r.arg = y), 
                                !!e;
                            }
                            if (this.done) throw t;
                            for (var r = this, e = this.tryEntries.length - 1; e >= 0; --e) {
                                var o = this.tryEntries[e], i = o.completion;
                                if ("root" === o.tryLoc) return n("end");
                                if (o.tryLoc <= this.prev) {
                                    var u = b.call(o, "catchLoc"), c = b.call(o, "finallyLoc");
                                    if (u && c) {
                                        if (this.prev < o.catchLoc) return n(o.catchLoc, !0);
                                        if (this.prev < o.finallyLoc) return n(o.finallyLoc);
                                    } else if (u) {
                                        if (this.prev < o.catchLoc) return n(o.catchLoc, !0);
                                    } else {
                                        if (!c) throw new Error("try statement without catch or finally");
                                        if (this.prev < o.finallyLoc) return n(o.finallyLoc);
                                    }
                                }
                            }
                        },
                        abrupt: function(t, n) {
                            for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                                var e = this.tryEntries[r];
                                if (e.tryLoc <= this.prev && b.call(e, "finallyLoc") && this.prev < e.finallyLoc) {
                                    var o = e;
                                    break;
                                }
                            }
                            o && ("break" === t || "continue" === t) && o.tryLoc <= n && n <= o.finallyLoc && (o = null);
                            var i = o ? o.completion : {};
                            return i.type = t, i.arg = n, o ? (this.method = "next", this.next = o.finallyLoc, 
                            I) : this.complete(i);
                        },
                        complete: function(t, n) {
                            if ("throw" === t.type) throw t.arg;
                            return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, 
                            this.method = "return", this.next = "end") : "normal" === t.type && n && (this.next = n), 
                            I;
                        },
                        finish: function(t) {
                            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                var r = this.tryEntries[n];
                                if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), v(r), I;
                            }
                        },
                        catch: function(t) {
                            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                var r = this.tryEntries[n];
                                if (r.tryLoc === t) {
                                    var e = r.completion;
                                    if ("throw" === e.type) {
                                        var o = e.arg;
                                        v(r);
                                    }
                                    return o;
                                }
                            }
                            throw new Error("illegal catch attempt");
                        },
                        delegateYield: function(t, n, r) {
                            return this.delegate = {
                                iterator: p(t),
                                resultName: n,
                                nextLoc: r
                            }, "next" === this.method && (this.arg = y), I;
                        }
                    };
                }("object" == typeof n ? n : "object" == typeof window ? window : "object" == typeof self ? self : this);
            }).call(n, r(85));
        }, function(t, n, r) {
            r(296), t.exports = r(24).RegExp.escape;
        }, function(t, n, r) {
            var e = r(0), o = r(297)(/[\\^$*+?.()|[\]{}]/g, "\\$&");
            e(e.S, "RegExp", {
                escape: function(t) {
                    return o(t);
                }
            });
        }, function(t, n) {
            t.exports = function(t, n) {
                var r = n === Object(n) ? function(t) {
                    return n[t];
                } : n;
                return function(n) {
                    return String(n).replace(t, r);
                };
            };
        }, function(t, n, r) {
            "use strict";
            function e(t, n, r) {
                return n in t ? Object.defineProperty(t, n, {
                    value: r,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[n] = r, t;
            }
            function o(t, n, r) {
                var e = Object.prototype.isPrototypeOf.call(p, r), o = e ? r.value : r, i = h.get(t).get(n.name), u = e ? r.key : void 0, f = n.keyPath || i.keyPath, s = n.autoIncrement || i.autoIncrement;
                if (null === f) s || void 0 !== u || (u = (0, a.uuid)()); else {
                    if ("object" !== (void 0 === r ? "undefined" : c(r))) return !1;
                    s || void 0 !== r[f] || (r[f] = (0, a.uuid)());
                }
                return u ? [ o, u ] : [ o ];
            }
            function i(t) {
                return t.every(function(t) {
                    return -1 !== l.call(this.database.objectStoreNames, t);
                }, this);
            }
            function u(t, n) {
                var r = h.get(t.name), e = [];
                return n.forEach(function(n) {
                    if (!r.has(n)) {
                        var o = new Promise(function(e) {
                            var o = t.transaction([ n ], f.TRANSACTION_READWRITE);
                            o.oncomplete = e, o.onabort = e;
                            var i = o.objectStore(n);
                            if (void 0 !== i.autoIncrement) return void r.set(n, {
                                autoIncrement: i.autoIncrement,
                                keyPath: i.keyPath
                            });
                            var u = void 0;
                            if (null !== i.keyPath) if (Array.isArray(i.keyPath)) u = !1; else try {
                                i.add({}), u = !0;
                            } catch (t) {
                                u = !1;
                            } else try {
                                i.add("some value"), u = !0;
                            } catch (t) {
                                u = !1;
                            }
                            r.set(n, {
                                autoIncrement: u,
                                keyPath: i.keyPath
                            }), o.abort();
                        });
                        e.push(o);
                    }
                }), Promise.all(e);
            }
            Object.defineProperty(n, "__esModule", {
                value: !0
            });
            var c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t;
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
            }, a = r(299), f = r(300), s = {};
            s.ASC = f.SORT_ASC, s.ASC_UNIQUE = f.SORT_ASC_UNIQUE, s.DESC = f.SORT_DESC, s.DESC_UNIQUE = f.SORT_DESC_UNIQUE;
            var l = Array.prototype.indexOf, v = "function" == typeof IDBObjectStore.prototype.getAll && "function" == typeof IDBObjectStore.prototype.getAllKeys, h = new Map(), p = Object.create(null), d = {
                insert: function() {
                    var t = this, n = 1 === arguments.length, r = n ? Object.keys(arguments[0]) : [ arguments[0] ];
                    if (!i.call(this, r)) {
                        var s = (0, a.createError)("NotFoundError", "Database " + this.database.name + " (version " + this.database.version + ") doesn't contain all needed stores");
                        return Promise.reject(s);
                    }
                    var l = void 0;
                    return n ? l = arguments[0] : (l = {}, l[arguments[0]] = [ arguments[1] ]), u(this.database, r).then(function() {
                        return new Promise(function(i, u) {
                            var s = {}, v = void 0, h = void 0;
                            try {
                                v = t.database.transaction(r, f.TRANSACTION_READWRITE);
                            } catch (n) {
                                if ("NotFoundError" === n.name) {
                                    var p = {};
                                    r.forEach(function(n) {
                                        var r = t.insert(e({}, n, Array.isArray(l[n]) ? l[n] : [ l[n] ])).then(function(t) {
                                            return t[n];
                                        });
                                        p[n] = r;
                                    }), (0, a.resolveAllPromises)(p).then(i, u);
                                } else u(n);
                                return;
                            }
                            v.oncomplete = v.onerror = v.onabort = function(t) {
                                var e = h || t.target.error;
                                e || "complete" !== t.type ? u((0, a.ensureError)(e)) : i(n ? s : s[r[0]][0]), "error" === t.type && t.preventDefault();
                            };
                            for (var d in l) {
                                var y = function(n) {
                                    for (var r = v.objectStore(n), e = 0; e < l[n].length; e++) {
                                        var i = function(e) {
                                            var i = o(t.database.name, r, l[n][e]);
                                            if (!i) return h = (0, a.createError)("InvalidStateError", "You must supply objects to be saved in the object store with set keyPath"), 
                                            {
                                                v: {
                                                    v: void 0
                                                }
                                            };
                                            var u = void 0;
                                            try {
                                                u = r.add.apply(r, i);
                                            } catch (t) {
                                                return h = t, "continue";
                                            }
                                            u.onsuccess = function(t) {
                                                s[n] = s[n] || [], s[n][e] = t.target.result;
                                            };
                                        }(e);
                                        switch (i) {
                                          case "continue":
                                            continue;

                                          default:
                                            if ("object" === (void 0 === i ? "undefined" : c(i))) return i.v;
                                        }
                                    }
                                }(d);
                                if ("object" === (void 0 === y ? "undefined" : c(y))) return y.v;
                            }
                        });
                    });
                },
                upsert: function() {
                    var t = this, n = 1 === arguments.length, r = n ? Object.keys(arguments[0]) : [ arguments[0] ];
                    if (!i.call(this, r)) {
                        var s = (0, a.createError)("NotFoundError", "Database " + this.database.name + " (version " + this.database.version + ") doesn't contain all needed stores");
                        return Promise.reject(s);
                    }
                    var l = void 0;
                    return n ? l = arguments[0] : (l = {}, l[arguments[0]] = [ arguments[1] ]), u(this.database, r).then(function() {
                        return new Promise(function(i, u) {
                            var s = {}, v = void 0, h = void 0;
                            try {
                                v = t.database.transaction(r, f.TRANSACTION_READWRITE);
                            } catch (n) {
                                if ("NotFoundError" === n.name) {
                                    var p = {};
                                    r.forEach(function(n) {
                                        var r = t.upsert(e({}, n, Array.isArray(l[n]) ? l[n] : [ l[n] ])).then(function(t) {
                                            return t[n];
                                        });
                                        p[n] = r;
                                    }), (0, a.resolveAllPromises)(p).then(i).catch(u);
                                } else u(n);
                                return;
                            }
                            v.oncomplete = v.onerror = v.onabort = function(t) {
                                var e = h || t.target.error;
                                e || "complete" !== t.type ? u((0, a.ensureError)(e)) : i(n ? s : s[r[0]][0]), "error" === t.type && t.preventDefault();
                            };
                            for (var d in l) {
                                var y = function(n) {
                                    for (var r = v.objectStore(n), e = 0; e < l[n].length; e++) {
                                        var i = function(e) {
                                            var i = o(t.database.name, r, l[n][e]);
                                            if (!i) return h = (0, a.createError)("InvalidStateError", "You must supply objects to be saved in the object store with set keyPath"), 
                                            {
                                                v: {
                                                    v: void 0
                                                }
                                            };
                                            var u = void 0;
                                            try {
                                                u = r.put.apply(r, i);
                                            } catch (t) {
                                                return h = t, "continue";
                                            }
                                            u.onsuccess = function(t) {
                                                s[n] = s[n] || [], s[n][e] = t.target.result;
                                            };
                                        }(e);
                                        switch (i) {
                                          case "continue":
                                            continue;

                                          default:
                                            if ("object" === (void 0 === i ? "undefined" : c(i))) return i.v;
                                        }
                                    }
                                }(d);
                                if ("object" === (void 0 === y ? "undefined" : c(y))) return y.v;
                            }
                        });
                    });
                },
                delete: function() {
                    var t = this, n = 1 === arguments.length, r = n ? Object.keys(arguments[0]) : [ arguments[0] ];
                    if (!i.call(this, r)) {
                        var e = (0, a.createError)("NotFoundError", "Database " + this.database.name + " (version " + this.database.version + ") doesn't contain all needed stores");
                        return Promise.reject(e);
                    }
                    var o = void 0;
                    return n ? o = arguments[0] : (o = {}, o[arguments[0]] = [ arguments[1] ]), new Promise(function(n, e) {
                        var i = void 0, u = void 0;
                        try {
                            i = t.database.transaction(r, f.TRANSACTION_READWRITE);
                        } catch (i) {
                            if ("NotFoundError" === i.name) {
                                var c = r.map(function(n) {
                                    return t.delete(n, o[n]);
                                });
                                Promise.all(c).then(function() {
                                    return n();
                                }).catch(e);
                            } else e(i);
                            return;
                        }
                        i.oncomplete = i.onerror = i.onabort = function(t) {
                            var r = u || t.target.error;
                            r ? e((0, a.ensureError)(r)) : n(), "error" === t.type && t.preventDefault();
                        };
                        for (var s in o) !function(t) {
                            var n = i.objectStore(t);
                            o[t].forEach(function(t) {
                                if (!u) try {
                                    n.delete(t);
                                } catch (t) {
                                    u = t;
                                }
                            });
                        }(s);
                    });
                },
                clear: function(t) {
                    var n = this;
                    if (t = Array.isArray(t) ? t : [ t ], !i.call(this, t)) {
                        var r = (0, a.createError)("NotFoundError", "Database " + this.database.name + " (version " + this.database.version + ") doesn't contain all needed stores");
                        return Promise.reject(r);
                    }
                    return new Promise(function(r, e) {
                        var o = void 0, i = void 0;
                        try {
                            o = n.database.transaction(t, f.TRANSACTION_READWRITE);
                        } catch (o) {
                            if ("NotFoundError" === o.name) {
                                var u = t.map(function(t) {
                                    return n.clear([ t ]);
                                });
                                Promise.all(u).then(function() {
                                    return r();
                                }).catch(e);
                            } else e(o);
                            return;
                        }
                        o.oncomplete = o.onerror = o.onabort = function(t) {
                            var n = i || t.target.error;
                            n ? e((0, a.ensureError)(n)) : r(), "error" === t.type && t.preventDefault();
                        }, t.forEach(function(t) {
                            var n = o.objectStore(t);
                            if (!i) try {
                                n.clear();
                            } catch (t) {
                                i = t;
                            }
                        });
                    });
                },
                get: function() {
                    var t = this, n = 1 === arguments.length && "object" === c(arguments[0]), r = n ? Object.keys(arguments[0]) : [ arguments[0] ];
                    if (!i.call(this, r)) {
                        var e = (0, a.createError)("NotFoundError", "Database " + this.database.name + " (version " + this.database.version + ") doesn't contain all needed stores");
                        return Promise.reject(e);
                    }
                    var o = {}, u = void 0, l = void 0;
                    return n ? u = arguments[0] : (u = {}, u[arguments[0]] = arguments[1]), r.forEach(function(t) {
                        o[t] = [];
                    }), new Promise(function(e, i) {
                        var h = void 0;
                        try {
                            h = t.database.transaction(r, f.TRANSACTION_READONLY);
                        } catch (n) {
                            if ("NotFoundError" === n.name) {
                                var p = {};
                                r.forEach(function(n) {
                                    var r = t.get(n, u[n]);
                                    p[n] = r;
                                }), (0, a.resolveAllPromises)(p).then(e).catch(i);
                            } else i(n);
                            return;
                        }
                        h.oncomplete = h.onerror = h.onabort = function(t) {
                            var u = l || t.target.error;
                            u || "complete" !== t.type ? i((0, a.ensureError)(u)) : e(n ? o : o[r[0]]), "error" === t.type && t.preventDefault();
                        };
                        for (var d in u) {
                            var y = function(t) {
                                var n = h.objectStore(t), r = u[t] || {}, e = r.direction || s.ASC, i = r.range instanceof f.IDBKeyRangeRef ? r.range : null, c = !1, p = void 0;
                                if (v && (c = Object.keys(r).every(function(t) {
                                    return "index" !== t && "direction" !== t;
                                })), r.index) {
                                    if (!n.indexNames.contains(r.index)) return l = (0, a.createError)("NotFoundError", "Object store " + n.name + " doesn't contain \"" + r.index + '" index'), 
                                    {
                                        v: void 0
                                    };
                                    try {
                                        p = n.index(r.index).openCursor(i, e);
                                    } catch (t) {
                                        return l = t, {
                                            v: void 0
                                        };
                                    }
                                } else {
                                    if (c) {
                                        var d = [ i ], y = 0;
                                        r.limit && (d.push(r.limit), r.offset && (d[1] += r.offset, y = r.offset));
                                        try {
                                            n.getAll.apply(n, d).onsuccess = function(n) {
                                                n.target.result.forEach(function(n, r) {
                                                    if (!(r < y)) {
                                                        var e = r - y;
                                                        o[t][e] = o[t][e] || {}, o[t][e].value = n;
                                                    }
                                                });
                                            }, n.getAllKeys.apply(n, d).onsuccess = function(n) {
                                                n.target.result.forEach(function(n, r) {
                                                    if (!(r < y)) {
                                                        var e = r - y;
                                                        o[t][e] = o[t][e] || {}, o[t][e].key = n;
                                                    }
                                                });
                                            };
                                        } catch (t) {
                                            l = t;
                                        }
                                        return "continue";
                                    }
                                    try {
                                        p = n.openCursor(i, e);
                                    } catch (t) {
                                        return l = t, {
                                            v: void 0
                                        };
                                    }
                                }
                                var g = !1;
                                p.onsuccess = function(n) {
                                    var e = n.target.result;
                                    if (e) {
                                        if (r.offset && !g) return g = !0, void e.advance(r.offset);
                                        o[t].push({
                                            key: e.key,
                                            value: e.value
                                        }), r.limit && r.limit === o[t].length || e.continue();
                                    }
                                };
                            }(d);
                            switch (y) {
                              case "continue":
                                continue;

                              default:
                                if ("object" === (void 0 === y ? "undefined" : c(y))) return y.v;
                            }
                        }
                    });
                },
                count: function() {
                    var t = this, n = 1 === arguments.length && "object" === c(arguments[0]), r = n ? Object.keys(arguments[0]) : [ arguments[0] ], e = void 0;
                    if (n ? e = arguments[0] : (e = {}, e[arguments[0]] = "function" == typeof arguments[1] ? null : arguments[1]), 
                    !i.call(this, r)) {
                        var o = (0, a.createError)("NotFoundError", "Database " + this.database.name + " (version " + this.database.version + ") doesn't contain all needed stores");
                        return Promise.reject(o);
                    }
                    return new Promise(function(o, i) {
                        var u = {}, s = void 0, l = void 0, v = void 0;
                        try {
                            s = t.database.transaction(r, f.TRANSACTION_READONLY);
                        } catch (n) {
                            if ("NotFoundError" === n.name) {
                                var h = {};
                                r.forEach(function(n) {
                                    var r = t.count(n, e[n]);
                                    h[n] = r;
                                }), (0, a.resolveAllPromises)(h).then(o).catch(i);
                            } else i(n);
                            return;
                        }
                        s.oncomplete = s.onerror = s.onabort = function(t) {
                            var e = v || t.target.error;
                            e || "complete" !== t.type ? i((0, a.ensureError)(e)) : o(n ? u : u[r[0]]), "error" === t.type && t.preventDefault();
                        };
                        for (var p in e) {
                            var d = function(t) {
                                var n = s.objectStore(t), r = e[t] || {}, o = r.range instanceof f.IDBKeyRangeRef ? [ r.range ] : [];
                                if (r.index) {
                                    if (!n.indexNames.contains(r.index)) return v = (0, a.createError)("NotFoundError", "Object store " + n.name + " doesn't contain \"" + r.index + '" index'), 
                                    {
                                        v: void 0
                                    };
                                    try {
                                        var i = n.index(r.index);
                                        l = i.count.apply(i, o);
                                    } catch (t) {
                                        return v = t, {
                                            v: void 0
                                        };
                                    }
                                } else try {
                                    l = n.count.apply(n, o);
                                } catch (t) {
                                    return v = t, {
                                        v: void 0
                                    };
                                }
                                l.onsuccess = function(n) {
                                    u[t] = n.target.result || 0;
                                };
                            }(p);
                            if ("object" === (void 0 === d ? "undefined" : c(d))) return d.v;
                        }
                    });
                },
                close: function() {
                    this.database.close(), delete this.database;
                }
            };
            s.open = function(t) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    version: 1
                };
                return new Promise(function(r, e) {
                    if (!f.indexedDbRef) return void e((0, a.createError)("NotSupportedError", "Your browser doesn't support IndexedDB"));
                    var o = f.indexedDbRef.open(t, n.version), i = !1;
                    o.onupgradeneeded = function(t) {
                        if (!i) {
                            n.migration = n.migration || {};
                            for (var r = t.oldVersion + 1; r <= t.newVersion; r++) n.migration[r] && n.migration[r].call(this, this.result);
                        }
                    }, o.onerror = function(t) {
                        i || (t.preventDefault(), e((0, a.ensureError)(t.target.error)), i = !0);
                    }, o.onsuccess = function() {
                        if (!i) {
                            var u = this.result, c = parseInt(u.version || 0, 10);
                            if ("function" == typeof u.setVersion && c < n.version) {
                                var f = u.setVersion(n.version);
                                return f.onsuccess = function(i) {
                                    var a = new Event("upgradeneeded");
                                    a.oldVersion = c, a.newVersion = n.version, o.onupgradeneeded.call({
                                        result: i.target.source
                                    }, a), u.close(), s.open(t, n).then(r, e);
                                }, void (f.onerror = function(t) {
                                    var n = t.target.errorMessage || t.target.webkitErrorMessage || t.target.mozErrorMessage || t.target.msErrorMessage || t.target.error.name;
                                    e((0, a.ensureError)(n));
                                });
                            }
                            h.has(t) || h.set(t, new Map()), r(Object.create(d, {
                                database: {
                                    configurable: !0,
                                    enumerable: !1,
                                    value: u,
                                    writable: !1
                                }
                            })), i = !0;
                        }
                    }, o.onblocked = function(n) {
                        i || (n.preventDefault(), e((0, a.createError)("InvalidStateError", "Database " + t + " is blocked")), 
                        i = !0);
                    };
                });
            }, s.deleteDatabase = function(t) {
                return new Promise(function(n, r) {
                    if (!f.indexedDbRef) return void r((0, a.createError)("NotSupportedError", "Your browser doesn't support IndexedDB"));
                    var e = f.indexedDbRef.deleteDatabase(t);
                    e.onsuccess = e.onerror = e.onblocked = function(e) {
                        var o = "blocked" === e.type ? (0, a.createError)("InvalidStateError", "Database " + t + " is blocked") : e.target.error;
                        o ? r((0, a.ensureError)(o)) : n(), "success" !== e.type && e.preventDefault();
                    };
                });
            }, s.keyValue = function(t, n) {
                return Object.create(p, {
                    key: {
                        value: t,
                        configurable: !1,
                        writable: !1
                    },
                    value: {
                        value: n,
                        configurable: !1,
                        writable: !1
                    }
                });
            }, n.default = s, t.exports = n.default;
        }, function(t, n, r) {
            "use strict";
            function e(t) {
                return function() {
                    var n = t.apply(this, arguments);
                    return new Promise(function(t, r) {
                        function e(o, i) {
                            try {
                                var u = n[o](i), c = u.value;
                            } catch (t) {
                                return void r(t);
                            }
                            if (!u.done) return Promise.resolve(c).then(function(t) {
                                e("next", t);
                            }, function(t) {
                                e("throw", t);
                            });
                            t(c);
                        }
                        return e("next");
                    });
                };
            }
            Object.defineProperty(n, "__esModule", {
                value: !0
            });
            var o = (n.uuid = function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
                    var n = 16 * Math.random() | 0;
                    return ("x" === t ? n : 3 & n | 8).toString(16);
                });
            }, n.createError = function(t, n) {
                var r = new Error(n);
                return r.name = t, r;
            });
            n.ensureError = function(t) {
                return t instanceof Error ? t : o(t.name, t.message);
            }, n.resolveAllPromises = function() {
                var t = e(regeneratorRuntime.mark(function t(n) {
                    var r, e, o, i, u, c;
                    return regeneratorRuntime.wrap(function(t) {
                        for (;;) switch (t.prev = t.next) {
                          case 0:
                            r = [];
                            for (e in n) r.push(n[e]);
                            return t.next = 4, Promise.all(r);

                          case 4:
                            o = t.sent, i = {}, u = 0;
                            for (c in n) i[c] = o[u], u++;
                            return t.abrupt("return", i);

                          case 9:
                          case "end":
                            return t.stop();
                        }
                    }, t, void 0);
                }));
                return function(n) {
                    return t.apply(this, arguments);
                };
            }();
        }, function(t, n, r) {
            "use strict";
            Object.defineProperty(n, "__esModule", {
                value: !0
            });
            var e = "undefined" != typeof window;
            n.indexedDbRef = e ? window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB : indexedDB, 
            n.IDBKeyRangeRef = e ? window.IDBKeyRange || window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange : IDBKeyRange, 
            n.TRANSACTION_READONLY = e ? window.IDBTransaction.READ_ONLY || "readonly" : "readonly", 
            n.TRANSACTION_READWRITE = e ? window.IDBTransaction.READ_WRITE || "readwrite" : "readwrite", 
            n.SORT_ASC = e ? window.IDBCursor.NEXT || "next" : "next", n.SORT_ASC_UNIQUE = e ? window.IDBCursor.NEXT_NO_DUPLICATE || "nextunique" : "nextunique", 
            n.SORT_DESC = e ? window.IDBCursor.PREV || "prev" : "prev", n.SORT_DESC_UNIQUE = e ? window.IDBCursor.PREV_NO_DUPLICATE || "prevunique" : "prevunique";
        } ]);
    });
}, function(module, exports) {
    "use strict";
    module.exports = {
        name: "visualbookmarks",
        version: 3,
        migration: {
            1: function(database) {
                database.createObjectStore("thumbs", {
                    keyPath: "url"
                });
                database.createObjectStore("unsafe_domains", {
                    keyPath: "domain"
                });
                database.createObjectStore("cloud_data", {
                    keyPath: "domain"
                });
                database.createObjectStore("thumbs_shown", {
                    keyPath: "position"
                });
                database.createObjectStore("blacklist", {
                    keyPath: "domain"
                });
            },
            2: function(database) {
                database.createObjectStore("users", {
                    keyPath: "uid"
                });
            },
            3: function(database) {
                database.createObjectStore("pickup", {
                    keyPath: "url"
                });
            }
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var deepEqual = __webpack_require__(299);
    function Differ(collection) {
        if (!Array.isArray(collection)) throw new Error("Differ can be initialized with arrays only");
        this.collection = collection.slice();
    }
    Differ.prototype.update = function(collection) {
        if (!Array.isArray(collection)) throw new Error("Differ can be updated with arrays only");
        var result = {
            changed: [],
            added: [],
            removed: []
        };
        var length = Math.max(this.collection.length, collection.length);
        for (var i = 0; i < length; i++) {
            var currentItem = this.collection[i];
            var newItem = collection[i];
            if (currentItem && newItem && !deepEqual(currentItem, newItem)) result.changed.push(i);
            if (!currentItem && newItem) result.added.push(i);
            if (currentItem && !newItem) result.removed.push(i);
        }
        this.collection = collection.slice();
        return result;
    };
    module.exports = Differ;
}, function(module, exports, __webpack_require__) {
    var pSlice = Array.prototype.slice;
    var objectKeys = __webpack_require__(300);
    var isArguments = __webpack_require__(301);
    var deepEqual = module.exports = function(actual, expected, opts) {
        if (!opts) opts = {};
        if (actual === expected) return true; else if (actual instanceof Date && expected instanceof Date) return actual.getTime() === expected.getTime(); else if (!actual || !expected || "object" != typeof actual && "object" != typeof expected) return opts.strict ? actual === expected : actual == expected; else return objEquiv(actual, expected, opts);
    };
    function isUndefinedOrNull(value) {
        return null === value || void 0 === value;
    }
    function isBuffer(x) {
        if (!x || "object" !== typeof x || "number" !== typeof x.length) return false;
        if ("function" !== typeof x.copy || "function" !== typeof x.slice) return false;
        if (x.length > 0 && "number" !== typeof x[0]) return false;
        return true;
    }
    function objEquiv(a, b, opts) {
        var i, key;
        if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
        if (a.prototype !== b.prototype) return false;
        if (isArguments(a)) {
            if (!isArguments(b)) return false;
            a = pSlice.call(a);
            b = pSlice.call(b);
            return deepEqual(a, b, opts);
        }
        if (isBuffer(a)) {
            if (!isBuffer(b)) return false;
            if (a.length !== b.length) return false;
            for (i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
            return true;
        }
        try {
            var ka = objectKeys(a), kb = objectKeys(b);
        } catch (e) {
            return false;
        }
        if (ka.length != kb.length) return false;
        ka.sort();
        kb.sort();
        for (i = ka.length - 1; i >= 0; i--) if (ka[i] != kb[i]) return false;
        for (i = ka.length - 1; i >= 0; i--) {
            key = ka[i];
            if (!deepEqual(a[key], b[key], opts)) return false;
        }
        return typeof a === typeof b;
    }
}, function(module, exports) {
    exports = module.exports = "function" === typeof Object.keys ? Object.keys : shim;
    exports.shim = shim;
    function shim(obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
}, function(module, exports) {
    var supportsArgumentsClass = "[object Arguments]" == function() {
        return Object.prototype.toString.call(arguments);
    }();
    exports = module.exports = supportsArgumentsClass ? supported : unsupported;
    exports.supported = supported;
    function supported(object) {
        return "[object Arguments]" == Object.prototype.toString.call(object);
    }
    exports.unsupported = unsupported;
    function unsupported(object) {
        return object && "object" == typeof object && "number" == typeof object.length && Object.prototype.hasOwnProperty.call(object, "callee") && !Object.prototype.propertyIsEnumerable.call(object, "callee") || false;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var ticker = __webpack_require__(303);
    var reginfo = __webpack_require__(304);
    var quotes = __webpack_require__(306);
    var branding = __webpack_require__(277);
    var settings = __webpack_require__(216);
    var channel = __webpack_require__(27);
    var _ = __webpack_require__(91);
    var ON_UPDATED_DELAY_MS = 500;
    var ENABLED_SETTING_NAME = "showInformers";
    var informers = {};
    exports.init = function() {
        if (exports.isSupported()) {
            ticker.init();
            createInformers();
            listenUpdates();
            settings.onChanged.addListener(onSettingChanged);
        }
    };
    exports.isSupported = function() {
        return branding.getRegionBrandId() === branding.REGION_BRANDINGS.YANDEX;
    };
    exports.isEnabled = function() {
        return Boolean(settings.get(ENABLED_SETTING_NAME));
    };
    exports.getData = function() {
        return Promise.all([ informers.reginfo.getData(), informers.quotes.getData() ]).then(function(results) {
            var _results = _slicedToArray(results, 2), reginfoData = _results[0], quotesData = _results[1];
            return {
                weather: reginfoData && reginfoData.weather,
                traffic: reginfoData && reginfoData.traffic,
                currency: {
                    usd: quotesData && "usd" === quotesData.code ? quotesData : null,
                    eur: quotesData && "eur" === quotesData.code ? quotesData : null
                }
            };
        });
    };
    exports.onUpdated = channel.create();
    exports.onEnabledChanged = channel.create();
    function createInformers() {
        informers.reginfo = reginfo.create();
        informers.quotes = quotes.create();
    }
    function listenUpdates() {
        var dispatchDebounced = _.debounce(function() {
            return exports.onUpdated.dispatch();
        }, ON_UPDATED_DELAY_MS);
        Object.keys(informers).forEach(function(key) {
            return informers[key].onUpdated.addListener(dispatchDebounced);
        });
    }
    function onSettingChanged(info) {
        if (info.key === ENABLED_SETTING_NAME) exports.onEnabledChanged.dispatch();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var alarms = __webpack_require__(3);
    var channel = __webpack_require__(27);
    var ALARM = {
        name: "informers",
        periodInMinutes: 15
    };
    exports.init = function() {
        alarms.register(ALARM, function() {
            exports.onTick.dispatch();
        });
    };
    exports.onTick = channel.create("Informers/ticker");
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var logger = __webpack_require__(5).create("Informers/reginfo");
    var xml = __webpack_require__(61);
    var urlUtils = __webpack_require__(83);
    var Informer = __webpack_require__(305);
    var platformAbout = __webpack_require__(23);
    var branding = __webpack_require__(277);
    var URL_TPL = "https://export.yandex.ru/bar/reginfo.xml?lang={locale}&brid={regionId}";
    exports.create = function() {
        return new Informer({
            url: branding.expandUrl(URL_TPL),
            setting: "informerReginfo",
            parser: extractData,
            logger: logger
        });
    };
    function extractData(responseXml) {
        return Promise.all([ extractWeather(responseXml), extractTraffic(responseXml) ]).then(function(results) {
            var _results = _slicedToArray(results, 2), weather = _results[0], traffic = _results[1];
            return {
                weather: weather,
                traffic: traffic
            };
        }).catch(function(error) {
            logger.error("Error during xml data extratingx, %i", error.message);
        });
    }
    function extractWeather(responseXml) {
        return Promise.all([ xml.getText(responseXml, "info > weather > day > title"), xml.getText(responseXml, "info > weather > day > day_part > temperature"), xml.getText(responseXml, "info > weather > day > day_part > image"), xml.getText(responseXml, "info > weather > url") ]).then(function(results) {
            var _results2 = _slicedToArray(results, 4), title = _results2[0], temperature = _results2[1], icon = _results2[2], url = _results2[3];
            var result = {
                title: title,
                level: parseInt(temperature, 10),
                icon: icon,
                url: url
            };
            if (Informer.hasEmptyProps(result)) {
                logger.error("Weather contains empty data, %j %j", result, responseXml);
                return null;
            }
            result.url = urlUtils.setQuery(result.url, {
                from: platformAbout.type
            });
            return result;
        }).catch(function(error) {
            logger.error("Error on weather xml parsing, %i", error.message);
        });
    }
    function extractTraffic(responseXml) {
        return Promise.all([ xml.getText(responseXml, "info > traffic > title"), xml.getText(responseXml, "info > traffic > region > level"), xml.getText(responseXml, "info > traffic > region > icon"), xml.getText(responseXml, "info > traffic > region > url") ]).then(function(results) {
            var _results3 = _slicedToArray(results, 4), title = _results3[0], level = _results3[1], icon = _results3[2], url = _results3[3];
            var result = {
                title: title,
                level: parseInt(level, 10),
                icon: icon,
                url: url
            };
            if (Informer.hasEmptyProps(result)) {
                logger.error("Traffic contains empty data, %j %j", result, responseXml);
                return null;
            }
            if (result.level < 0 || result.level > 10) {
                logger.error("Traffic contains incorrect level, %i", result.level);
                return null;
            }
            return result;
        }).catch(function(error) {
            logger.error("Error on traffic xml parsing, %i", error.message);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var xhr = __webpack_require__(32);
    var channel = __webpack_require__(27);
    var settings = __webpack_require__(216);
    var ticker = __webpack_require__(303);
    var Informer = module.exports = function(options) {
        var _this = this;
        this.options = options;
        this.logger = options.logger;
        this.onUpdated = channel.create(options.setting);
        ticker.onTick.addListener(function() {
            return _this.updateData();
        });
    };
    Informer.prototype.getData = function() {
        return settings.get(this.options.setting) || null;
    };
    Informer.prototype.updateData = function() {
        var _this2 = this;
        this._loadData().then(function(responseXml) {
            return _this2._extractData(responseXml);
        }).then(function(data) {
            return _this2._saveData(data);
        }).catch(function(e) {
            return _this2._processError(e);
        });
    };
    Informer.prototype._loadData = function() {
        var _this3 = this;
        this.logger.info("Loading data from: %s", this.options.url);
        return new Promise(function(resolve, reject) {
            xhr({
                url: _this3.options.url,
                parse: "xml"
            }, function(error, xmlDoc) {
                if (error) {
                    _this3.logger.error("Error while loading data %s", error.message);
                    reject();
                } else resolve(xmlDoc);
            });
        });
    };
    Informer.prototype._extractData = function(responseXml) {
        return this.options.parser.call(this, responseXml);
    };
    Informer.prototype._saveData = function(data) {
        this.logger.info("Saving data: %j", data);
        settings.set(this.options.setting, data);
        this.onUpdated.dispatch();
    };
    Informer.prototype._processError = function(e) {
        if (e) this.logger.error(e);
        this._saveData(null);
    };
    Informer.hasEmptyProps = function(obj) {
        if (!obj) return true; else return Object.keys(obj).some(function(key) {
            return "string" === typeof obj[key] && "" === obj[key] || Number.isNaN(obj[key]);
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var logger = __webpack_require__(5).create("Informers/quotes");
    var xml = __webpack_require__(61);
    var curly = __webpack_require__(207);
    var Informer = __webpack_require__(305);
    var URL_TPL = "https://ya.ru/search/?lr=174993&text={text}&wiz=finance";
    exports.create = function() {
        return new Informer({
            url: "https://export.yandex.ru/bar/quotes.xml",
            setting: "informerQuotes",
            parser: extractData,
            logger: logger
        });
    };
    function extractData(responseXml) {
        return Promise.all([ xml.getAttr(responseXml, "quotes > quote", "name"), xml.getAttr(responseXml, "quotes > quote", "id"), xml.getText(responseXml, "quotes > quote > value"), xml.getText(responseXml, "quotes > quote > change") ]).then(function(results) {
            var _results = _slicedToArray(results, 4), name = _results[0], value = (_results[1], 
            _results[2]), change = _results[3];
            var code = getCurrencyCode(name);
            if (!code) {
                logger.warn("Currency name does not contain USD|EUR: %s", name);
                return null;
            }
            var result = {
                value: parseFloat(value),
                change: parseFloat(change),
                code: code,
                url: curly.insertUrlVars(URL_TPL, {
                    text: name
                })
            };
            if (Informer.hasEmptyProps(result)) {
                logger.error("Quote contains empty data, %j %j", result, responseXml);
                return null;
            } else return result;
        }).catch(function(error) {
            logger.error("Excract xml data error, %j", error.messsage);
        });
    }
    function getCurrencyCode(name) {
        if (/usd/i.test(name)) return "usd";
        if (/eur/i.test(name)) return "eur";
        return "";
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var uniq = __webpack_require__(200);
    var pluck = __webpack_require__(156);
    var listener = __webpack_require__(308);
    var sorter = __webpack_require__(323);
    var restorator = __webpack_require__(325);
    var closedItem = __webpack_require__(321);
    var logger = __webpack_require__(5).create("closed tabs");
    var state = __webpack_require__(326);
    exports.onUpdated = state.onUpdated;
    exports.init = function() {
        listener.start();
        listener.onTabClosed.addListener(handleTabClosedEvent);
        listener.onWindowClosed.addListener(handleWindowClosedEvent);
        listener.onHistoryCleared.addListener(handleHistoryClearedEvent);
        exports.onUpdated.dispatch(state.get());
    };
    exports.restoreItem = function(itemId) {
        var closedTabs = state.get();
        var restoredIndex = restoreTabOrWindow(closedTabs, itemId);
        if (restoredIndex !== -1) state.remove(restoredIndex);
    };
    exports.hasClosed = function(windowId) {
        var closedItems = state.get();
        var windows = sorter.getWindows(closedItems);
        if (windows.length > 0) return true;
        var tabs = sorter.getTabs(closedItems, windowId);
        return tabs.length > 0;
    };
    exports.getClosedTabs = function(windowId) {
        var tabs = state.get().slice();
        return sorter.sortItems(tabs, windowId);
    };
    function restoreTabOrWindow(closedTabs, itemId) {
        if (closedItem.isWindowId(itemId)) return restorator.restoreWindow(closedTabs, itemId, handleWindowRestoredEvent); else return restorator.restoreTab(closedTabs, itemId);
    }
    function handleTabClosedEvent(closedTab) {
        state.upsert(closedTab);
    }
    function handleWindowClosedEvent(windowId) {
        setTimeout(function() {
            logger.info("Window %s closed, update closed-tabs data", windowId);
            var windowTabs = state.removeClosedWithWindowTabs(windowId);
            var urls = getUrlsFromTabs(windowTabs);
            var closedWindow = closedItem.createClosedWindow(urls, windowId);
            state.unshift(closedWindow);
        }, 0);
    }
    function getUrlsFromTabs(tabs) {
        var urls = pluck(tabs, "url");
        return uniq(urls);
    }
    function handleWindowRestoredEvent(error, restoredWindowId, window) {
        if (error || !window) logger.error("Error while restoring window %s; %j", restoredWindowId, error); else {
            logger.info("Window %s restored (old id - %s)", window.id, restoredWindowId);
            state.replaceWindowIds(restoredWindowId, window.id);
        }
    }
    function handleHistoryClearedEvent() {
        logger.info("History cleared, removing closed-tabs data");
        state.clear();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var channel = __webpack_require__(27);
    var urlUtils = __webpack_require__(83);
    var tabsWatcherEvents = __webpack_require__(309).events;
    var platformAbout = __webpack_require__(23);
    var closedItem = __webpack_require__(321);
    var isRegExp = __webpack_require__(322);
    var closedTabsFilter = [].concat(platformAbout.vbUrls || []);
    exports.start = function() {
        tabsWatcherEvents.onRemoved.addListener(handleTabClosedEvent);
        chrome.windows.onRemoved.addListener(handleWindowClosedEvent);
        addHistoryRemovedListener();
    };
    exports.onTabClosed = channel.create();
    exports.onWindowClosed = channel.create();
    exports.onWindowCreated = channel.create();
    exports.onHistoryCleared = channel.create();
    function handleTabClosedEvent(tabId, tab, removeInfo) {
        var tabData = tab.data;
        var url = tabData.url;
        if (!isWatchingUrl(url)) return;
        var closedTab = closedItem.createClosedTab(url, tabData, removeInfo);
        exports.onTabClosed.dispatch(closedTab);
    }
    function handleWindowClosedEvent(windowId) {
        exports.onWindowClosed.dispatch(windowId);
    }
    function isWatchingUrl(url) {
        return !closedTabsFilter.some(function(pattern) {
            if (isRegExp(pattern)) return pattern.test(url);
            return urlUtils.isEqualUrls(pattern, url);
        });
    }
    function addHistoryRemovedListener() {
        if (chrome.history && chrome.history.onVisitRemoved) chrome.history.onVisitRemoved.addListener(handleHistoryRemovedEvent);
    }
    function handleHistoryRemovedEvent(removedInfo) {
        if (removedInfo && removedInfo.allHistory) exports.onHistoryCleared.dispatch();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Channel = __webpack_require__(27);
    var TabsWatcher = __webpack_require__(310);
    exports.watcher = new TabsWatcher();
    exports.events = {
        public: {}
    };
    [ "onCreated", "onUpdated", "onActivated", "onRemoved", "onAttached", "onReplaced", "onBeforeNavigate", "onCommitted", "onCompleted", "onErrorOccurred", "onDOMContentLoaded", "onHistoryStateUpdated", "onReferenceFragmentUpdated" ].forEach(function(event) {
        exports.events[event] = eventProxyFactory(exports.watcher[event]);
        exports.events.public[event] = eventProxyFactory(exports.watcher.public[event]);
    });
    function eventProxyFactory(signal) {
        var channel = new Channel();
        signal.add(function() {
            channel.dispatch.apply(channel, arguments);
        });
        return channel;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _eventToSignalMap;
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperty(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        }); else obj[key] = value;
        return obj;
    }
    var _signals = __webpack_require__(311);
    var _signals2 = _interopRequireDefault(_signals);
    var _thenChrome = __webpack_require__(283);
    var _thenChrome2 = _interopRequireDefault(_thenChrome);
    var _tab = __webpack_require__(312);
    var _tab2 = _interopRequireDefault(_tab);
    var _collectionStorage = __webpack_require__(317);
    var _collectionStorage2 = _interopRequireDefault(_collectionStorage);
    var _collectionCollection = __webpack_require__(319);
    var _collectionCollection2 = _interopRequireDefault(_collectionCollection);
    var _navListener = __webpack_require__(320);
    var _navListener2 = _interopRequireDefault(_navListener);
    var _navigation = __webpack_require__(313);
    var eventToSignalMap = (_eventToSignalMap = {}, _defineProperty(_eventToSignalMap, _navigation.NAVIGATION_STATUS.BEFORE_NAVIGATE, "onBeforeNavigate"), 
    _defineProperty(_eventToSignalMap, _navigation.NAVIGATION_STATUS.COMMITTED, "onCommitted"), 
    _defineProperty(_eventToSignalMap, _navigation.NAVIGATION_STATUS.DOM_CONTENT_LOADED, "onDOMContentLoaded"), 
    _defineProperty(_eventToSignalMap, _navigation.NAVIGATION_STATUS.COMPLETED, "onCompleted"), 
    _defineProperty(_eventToSignalMap, _navigation.NAVIGATION_STATUS.ERROR_OCCURRED, "onErrorOccurred"), 
    _defineProperty(_eventToSignalMap, _navigation.NAVIGATION_STATUS.HISTORY_STATE_UPDATED, "onHistoryStatusUpdated"), 
    _defineProperty(_eventToSignalMap, _navigation.NAVIGATION_STATUS.REFERENCE_FRAGMENT_UPDATED, "onReferenceFragmentUpdated"), 
    _eventToSignalMap);
    var TabsWatcher = function() {
        function TabsWatcher() {
            _classCallCheck(this, TabsWatcher);
            this.storage = new _collectionStorage2["default"](_collectionCollection2["default"]);
            this["public"] = {};
            this._createSignals(this);
            this._createSignals(this["public"]);
            this._createNavListener();
            this._createTabActionListeners();
            this._createWindowActionListeners();
            this._readExistingTabs();
            this.activeTabId = {};
            this.replacedTabs = {};
            this.currentWindowId = null;
        }
        _createClass(TabsWatcher, [ {
            key: "getTabData",
            value: function(tabId) {
                return this.storage.getById(tabId);
            }
        }, {
            key: "_createSignals",
            value: function(scope) {
                scope.onCreated = new _signals2["default"]();
                scope.onUpdated = new _signals2["default"]();
                scope.onActivated = new _signals2["default"]();
                scope.onRemoved = new _signals2["default"]();
                scope.onAttached = new _signals2["default"]();
                scope.onReplaced = new _signals2["default"]();
                scope.onBeforeNavigate = new _signals2["default"]();
                scope.onCommitted = new _signals2["default"]();
                scope.onCompleted = new _signals2["default"]();
                scope.onErrorOccurred = new _signals2["default"]();
                scope.onDOMContentLoaded = new _signals2["default"]();
                scope.onHistoryStateUpdated = new _signals2["default"]();
                scope.onReferenceFragmentUpdated = new _signals2["default"]();
            }
        }, {
            key: "_createNavListener",
            value: function() {
                this.navListener = new _navListener2["default"]();
                this._updateNavigation = this._updateNavigation.bind(this);
                this.navListener.onNavigationUpdated.add(this._updateNavigation);
            }
        }, {
            key: "_createTabActionListeners",
            value: function() {
                this._onCreated = this._onCreated.bind(this);
                this._onRemoved = this._onRemoved.bind(this);
                this._onUpdated = this._onUpdated.bind(this);
                this._onActivated = this._onActivated.bind(this);
                this._onAttached = this._onAttached.bind(this);
                this._onReplaced = this._onReplaced.bind(this);
                chrome.tabs.onCreated.addListener(this._onCreated);
                chrome.tabs.onRemoved.addListener(this._onRemoved);
                chrome.tabs.onUpdated.addListener(this._onUpdated);
                chrome.tabs.onActivated.addListener(this._onActivated);
                chrome.tabs.onAttached.addListener(this._onAttached);
                chrome.tabs.onReplaced.addListener(this._onReplaced);
            }
        }, {
            key: "_createWindowActionListeners",
            value: function() {
                this._onWindowFocusChanged = this._onWindowFocusChanged.bind(this);
                chrome.windows.onFocusChanged.addListener(this._onWindowFocusChanged);
            }
        }, {
            key: "_readExistingTabs",
            value: function() {
                var _this = this;
                _thenChrome2["default"].windows.getAll({
                    populate: true
                }).then(function(windows) {
                    return _this._readTabsFromExistingWindows(windows);
                }).then(function(tabs) {
                    return _this._saveTabsToStorage(tabs);
                })["catch"](function(error) {
                    throw error;
                });
            }
        }, {
            key: "_readTabsFromExistingWindows",
            value: function(windows) {
                var currentWindow = windows.filter(function(window) {
                    return window.focused;
                })[0];
                this.currentWindowId = currentWindow ? currentWindow.id : null;
                return windows.reduce(function(res, win) {
                    return res.concat(win.tabs);
                }, []);
            }
        }, {
            key: "_saveTabsToStorage",
            value: function(tabs) {
                var _this2 = this;
                var wrappers = tabs.map(function(tab) {
                    if (tab.active) _this2.activeTabId[tab.windowId] = tab.id;
                    tab.isInCurrentWindow = tab.windowId === _this2.currentWindowId;
                    return new _tab2["default"](tab);
                });
                this.storage.update(wrappers);
            }
        }, {
            key: "_updateNavigation",
            value: function(navigation) {
                var _this3 = this;
                var tabId = navigation.tabId;
                _thenChrome2["default"].tabs.get(tabId).then(function(data) {
                    var diff = _this3.storage.getDiffObject(tabId, {
                        data: data,
                        navigation: navigation
                    });
                    var tab = _this3.storage.merge(diff);
                    _this3._dispatch(eventToSignalMap[navigation.status], tabId, tab, navigation);
                })["catch"](function() {});
            }
        }, {
            key: "_onCreated",
            value: function(tab) {
                tab.navInNewWindow = 0 === this.storage.snapshot(function(_ref) {
                    var data = _ref.data;
                    return data.windowId === tab.windowId;
                }).size;
                tab.isInCurrentWindow = tab.windowId === this.currentWindowId;
                tab = new _tab2["default"](tab);
                this.storage.update(tab);
                this._dispatch("onCreated", tab.id, tab);
            }
        }, {
            key: "_onReplaced",
            value: function(addedTabId, removedTabId) {
                this.storage.remove(removedTabId);
                this.replacedTabs[addedTabId] = true;
            }
        }, {
            key: "_onAttached",
            value: function(tabId, _ref2) {
                var newWindowId = _ref2.newWindowId;
                var newPosition = _ref2.newPosition;
                var diff = this.storage.getDiffObject(tabId, {
                    data: {
                        windowId: newWindowId,
                        index: newPosition,
                        isInCurrentWindow: newWindowId === this.currentWindowId
                    }
                });
                var tab = this.storage.merge(diff);
                this._dispatch("onAttached", tabId, tab, {
                    newWindowId: newWindowId,
                    newPosition: newPosition
                });
            }
        }, {
            key: "_onUpdated",
            value: function(tabId, updateInfo) {
                if (updateInfo.status) return;
                var diff = this.storage.getDiffObject(tabId, {
                    data: updateInfo
                });
                var tab = this.storage.merge(diff);
                this._dispatch("onUpdated", tabId, tab, updateInfo);
            }
        }, {
            key: "_onActivated",
            value: function(_ref3) {
                var tabId = _ref3.tabId;
                var windowId = _ref3.windowId;
                if (this.replacedTabs[tabId]) this._replaceTab(tabId, windowId); else {
                    var _activateTab2 = this._activateTab(tabId, windowId);
                    var _activateTab22 = _slicedToArray(_activateTab2, 2);
                    var activatedTab = _activateTab22[0];
                    var deactivatedTab = _activateTab22[1];
                    this._dispatch("onActivated", tabId, activatedTab, windowId, deactivatedTab);
                }
            }
        }, {
            key: "_replaceTab",
            value: function(tabId, windowId) {
                var _this4 = this;
                delete this.replacedTabs[tabId];
                _thenChrome2["default"].tabs.get(tabId).then(function(tab) {
                    tab.isInCurrentWindow = windowId === _this4.currentWindowId;
                    _this4.storage.update(new _tab2["default"](tab));
                    _this4._onActivated({
                        tabId: tabId,
                        windowId: windowId
                    });
                })["catch"](function() {});
            }
        }, {
            key: "_activateTab",
            value: function(tabId, windowId) {
                var activeTabId = this.activeTabId[windowId];
                var diffs = [ this.storage.getDiffObject(tabId, {
                    data: {
                        active: true
                    }
                }) ];
                this.activeTabId[windowId] = tabId;
                if (activeTabId) diffs.push(this.storage.getDiffObject(activeTabId, {
                    data: {
                        active: false
                    }
                }));
                return this.storage.merge(diffs);
            }
        }, {
            key: "_onRemoved",
            value: function(tabId, removeInfo) {
                var windowId = removeInfo.windowId;
                if (this.activeTabId[windowId] === tabId) delete this.activeTabId[windowId];
                var removedTab = this.storage.remove(tabId);
                this._dispatch("onRemoved", tabId, removedTab, removeInfo);
            }
        }, {
            key: "_onWindowFocusChanged",
            value: function(windowId) {
                var _this5 = this;
                if (windowId === chrome.windows.WINDOW_ID_NONE) return;
                var diff = this.storage.snapshot(function(_ref4) {
                    var data = _ref4.data;
                    return data.windowId === windowId || data.windowId === _this5.currentWindowId;
                }).map(function(_ref5) {
                    var id = _ref5.id;
                    var data = _ref5.data;
                    return _this5.storage.getDiffObject(id, {
                        data: {
                            isInCurrentWindow: data.windowId === windowId
                        }
                    });
                });
                this.storage.merge(diff);
                this.currentWindowId = windowId;
            }
        }, {
            key: "_tabsInCurrentWindowQuery",
            value: function(_ref6) {
                var data = _ref6.data;
                return data.windowId === this.currentWindowId;
            }
        }, {
            key: "_dispatch",
            value: function(signalName, tabId, tabData) {
                var isIncognito = tabData.data.incognito;
                for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) args[_key - 3] = arguments[_key];
                if (this[signalName] instanceof _signals2["default"]) {
                    var _signalName;
                    (_signalName = this[signalName]).dispatch.apply(_signalName, [ tabId, tabData ].concat(args));
                }
                if (!isIncognito) if (this["public"][signalName] instanceof _signals2["default"]) {
                    var _public$signalName;
                    (_public$signalName = this["public"][signalName]).dispatch.apply(_public$signalName, [ tabId, tabData ].concat(args));
                }
            }
        }, {
            key: "destroy",
            value: function() {
                this.storage.clear();
                this._removeEventListeners(this);
                this._removeEventListeners(this["public"]);
                chrome.tabs.onCreated.removeListener(this._onCreated);
                chrome.tabs.onRemoved.removeListener(this._onRemoved);
                chrome.tabs.onUpdated.removeListener(this._onUpdated);
                chrome.tabs.onActivated.removeListener(this._onActivated);
                chrome.tabs.onAttached.removeListener(this._onAttached);
                chrome.tabs.onReplaced.removeListener(this._onReplaced);
                this.navListener.onNavigationUpdated.remove(this._updateNavigation);
                chrome.windows.onFocusChanged.removeListener(this._onWindowFocusChanged);
            }
        }, {
            key: "_removeEventListeners",
            value: function(scope) {
                scope.onCreated.removeAll();
                scope.onUpdated.removeAll();
                scope.onActivated.removeAll();
                scope.onRemoved.removeAll();
                scope.onAttached.removeAll();
                scope.onBeforeNavigate.removeAll();
                scope.onCommitted.removeAll();
                scope.onCompleted.removeAll();
                scope.onErrorOccurred.removeAll();
                scope.onDOMContentLoaded.removeAll();
                scope.onHistoryStateUpdated.removeAll();
                scope.onReferenceFragmentUpdated.removeAll();
            }
        } ]);
        return TabsWatcher;
    }();
    exports["default"] = TabsWatcher;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    !function(global) {
        function SignalBinding(signal, listener, isOnce, listenerContext, priority) {
            this._listener = listener;
            this._isOnce = isOnce;
            this.context = listenerContext;
            this._signal = signal;
            this._priority = priority || 0;
        }
        SignalBinding.prototype = {
            active: true,
            params: null,
            execute: function(paramsArr) {
                var handlerReturn, params;
                if (this.active && !!this._listener) {
                    params = this.params ? this.params.concat(paramsArr) : paramsArr;
                    handlerReturn = this._listener.apply(this.context, params);
                    if (this._isOnce) this.detach();
                }
                return handlerReturn;
            },
            detach: function() {
                return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
            },
            isBound: function() {
                return !!this._signal && !!this._listener;
            },
            isOnce: function() {
                return this._isOnce;
            },
            getListener: function() {
                return this._listener;
            },
            getSignal: function() {
                return this._signal;
            },
            _destroy: function() {
                delete this._signal;
                delete this._listener;
                delete this.context;
            },
            toString: function() {
                return "[SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]";
            }
        };
        function validateListener(listener, fnName) {
            if ("function" !== typeof listener) throw new Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", fnName));
        }
        function Signal() {
            this._bindings = [];
            this._prevParams = null;
            var self = this;
            this.dispatch = function() {
                Signal.prototype.dispatch.apply(self, arguments);
            };
        }
        Signal.prototype = {
            VERSION: "1.0.0",
            memorize: false,
            _shouldPropagate: true,
            active: true,
            _registerListener: function(listener, isOnce, listenerContext, priority) {
                var binding, prevIndex = this._indexOfListener(listener, listenerContext);
                if (prevIndex !== -1) {
                    binding = this._bindings[prevIndex];
                    if (binding.isOnce() !== isOnce) throw new Error("You cannot add" + (isOnce ? "" : "Once") + "() then add" + (!isOnce ? "" : "Once") + "() the same listener without removing the relationship first.");
                } else {
                    binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                    this._addBinding(binding);
                }
                if (this.memorize && this._prevParams) binding.execute(this._prevParams);
                return binding;
            },
            _addBinding: function(binding) {
                var n = this._bindings.length;
                do --n; while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
                this._bindings.splice(n + 1, 0, binding);
            },
            _indexOfListener: function(listener, context) {
                var cur, n = this._bindings.length;
                while (n--) {
                    cur = this._bindings[n];
                    if (cur._listener === listener && cur.context === context) return n;
                }
                return -1;
            },
            has: function(listener, context) {
                return this._indexOfListener(listener, context) !== -1;
            },
            add: function(listener, listenerContext, priority) {
                validateListener(listener, "add");
                return this._registerListener(listener, false, listenerContext, priority);
            },
            addOnce: function(listener, listenerContext, priority) {
                validateListener(listener, "addOnce");
                return this._registerListener(listener, true, listenerContext, priority);
            },
            remove: function(listener, context) {
                validateListener(listener, "remove");
                var i = this._indexOfListener(listener, context);
                if (i !== -1) {
                    this._bindings[i]._destroy();
                    this._bindings.splice(i, 1);
                }
                return listener;
            },
            removeAll: function() {
                var n = this._bindings.length;
                while (n--) this._bindings[n]._destroy();
                this._bindings.length = 0;
            },
            getNumListeners: function() {
                return this._bindings.length;
            },
            halt: function() {
                this._shouldPropagate = false;
            },
            dispatch: function(params) {
                if (!this.active) return;
                var bindings, paramsArr = Array.prototype.slice.call(arguments), n = this._bindings.length;
                if (this.memorize) this._prevParams = paramsArr;
                if (!n) return;
                bindings = this._bindings.slice();
                this._shouldPropagate = true;
                do n--; while (bindings[n] && this._shouldPropagate && false !== bindings[n].execute(paramsArr));
            },
            forget: function() {
                this._prevParams = null;
            },
            dispose: function() {
                this.removeAll();
                delete this._bindings;
                delete this._prevParams;
            },
            toString: function() {
                return "[Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]";
            }
        };
        var signals = Signal;
        signals.Signal = Signal;
        if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return signals;
        }.call(exports, __webpack_require__, exports, module), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if ("undefined" !== typeof module && module.exports) module.exports = signals; else global["signals"] = signals;
    }(this);
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _get = function(_x2, _x3, _x4) {
        var _again = true;
        _function: while (_again) {
            var object = _x2, property = _x3, receiver = _x4;
            _again = false;
            if (null === object) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (void 0 === desc) {
                var parent = Object.getPrototypeOf(object);
                if (null === parent) return; else {
                    _x2 = parent;
                    _x3 = property;
                    _x4 = receiver;
                    _again = true;
                    desc = parent = void 0;
                    continue _function;
                }
            } else if ("value" in desc) return desc.value; else {
                var getter = desc.get;
                if (void 0 === getter) return;
                return getter.call(receiver);
            }
        }
    };
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _inherits(subClass, superClass) {
        if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var _lodashObjectPick = __webpack_require__(75);
    var _lodashObjectPick2 = _interopRequireDefault(_lodashObjectPick);
    var _navigation = __webpack_require__(313);
    var _navigation2 = _interopRequireDefault(_navigation);
    var _collectionModel = __webpack_require__(316);
    var _collectionModel2 = _interopRequireDefault(_collectionModel);
    var _lodashLangIsEmpty = __webpack_require__(73);
    var _lodashLangIsEmpty2 = _interopRequireDefault(_lodashLangIsEmpty);
    var props = [ "id", "windowId", "openerTabId", "active", "isInCurrentWindow", "audible", "mutedInfo", "title", "favIconUrl", "status", "incognito", "sessionId", "url", "navInNewWindow", "navInExistingTab" ];
    var navProps = [ "transitionType", "transitionQualifiers", "url", "status" ];
    var COMPLETE = "complete";
    var LOADING = "loading";
    var COMPLETED = _navigation.NAVIGATION_STATUS.COMPLETED;
    var COMMITTED = _navigation.NAVIGATION_STATUS.COMMITTED;
    var Tab = function(_Model) {
        _inherits(Tab, _Model);
        function Tab(tab, navigation) {
            _classCallCheck(this, Tab);
            _get(Object.getPrototypeOf(Tab.prototype), "constructor", this).call(this);
            this.id = tab.id;
            this.data = {
                navInExistingTab: false
            };
            this.updateData(tab);
            if (navigation || (0, _lodashLangIsEmpty2["default"])(tab.url)) this.navigation = new _navigation2["default"](navigation); else this.navigation = new _navigation2["default"]({
                url: tab.url,
                status: tab.status === COMPLETE ? COMPLETED : COMMITTED
            });
        }
        _createClass(Tab, [ {
            key: "updateData",
            value: function(tabData) {
                Object.assign(this.data, (0, _lodashObjectPick2["default"])(tabData, props));
                return this;
            }
        }, {
            key: "merge",
            value: function() {
                var _ref = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];
                var data = _ref.data;
                var navigation = _ref.navigation;
                if (data) this.updateData(data);
                if (navigation) this.updateNavigation(navigation);
                return this;
            }
        }, {
            key: "updateNavigation",
            value: function(data) {
                var navData = (0, _lodashObjectPick2["default"])(data, navProps);
                this.data.navInExistingTab = !this.navigation.isEmpty;
                this.navigation.update(navData);
                this.data.url = navData.url;
                this.data.status = this.isComplete ? COMPLETE : LOADING;
                return this;
            }
        }, {
            key: "clone",
            value: function() {
                var data = Object.assign({}, this.data);
                data.mutedInfo = Object.assign({}, data.mutedInfo);
                return new Tab(data, this.navigation);
            }
        }, {
            key: "getId",
            value: function() {
                return this.id;
            }
        }, {
            key: "isComplete",
            get: function() {
                return this.navigation.isFinished;
            }
        }, {
            key: "isCurrent",
            get: function() {
                return this.data.isInCurrentWindow && this.data.active;
            }
        } ]);
        return Tab;
    }(_collectionModel2["default"]);
    exports["default"] = Tab;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
            return arr2;
        } else return Array.from(arr);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _lodashArrayLast = __webpack_require__(120);
    var _lodashArrayLast2 = _interopRequireDefault(_lodashArrayLast);
    var _uuid = __webpack_require__(314);
    var _uuid2 = _interopRequireDefault(_uuid);
    var NAVIGATION_STATUS = {
        EMPTY: -1,
        BEFORE_NAVIGATE: 0,
        COMMITTED: 1,
        DOM_CONTENT_LOADED: 2,
        COMPLETED: 3,
        ERROR_OCCURRED: 4,
        HISTORY_STATE_UPDATED: 5,
        REFERENCE_FRAGMENT_UPDATED: 6
    };
    exports.NAVIGATION_STATUS = NAVIGATION_STATUS;
    var EMPTY = NAVIGATION_STATUS.EMPTY;
    var BEFORE_NAVIGATE = NAVIGATION_STATUS.BEFORE_NAVIGATE;
    var COMMITTED = NAVIGATION_STATUS.COMMITTED;
    var DOM_CONTENT_LOADED = NAVIGATION_STATUS.DOM_CONTENT_LOADED;
    var COMPLETED = NAVIGATION_STATUS.COMPLETED;
    var ERROR_OCCURRED = NAVIGATION_STATUS.ERROR_OCCURRED;
    var HISTORY_STATE_UPDATED = NAVIGATION_STATUS.HISTORY_STATE_UPDATED;
    var POSSIBLE_STATUSES = [ BEFORE_NAVIGATE, COMMITTED, COMPLETED, ERROR_OCCURRED ];
    var CLIENT_REDIRECT = "client_redirect";
    var SERVER_REDIRECT = "server_redirect";
    var Navigation = function() {
        function Navigation() {
            var _ref = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];
            var url = _ref.url;
            var _ref$stack = _ref.stack;
            var stack = void 0 === _ref$stack ? [] : _ref$stack;
            var _ref$previousUrl = _ref.previousUrl;
            var previousUrl = void 0 === _ref$previousUrl ? null : _ref$previousUrl;
            var _ref$previousRedirectChain = _ref.previousRedirectChain;
            var previousRedirectChain = void 0 === _ref$previousRedirectChain ? [] : _ref$previousRedirectChain;
            var _ref$redirectChain = _ref.redirectChain;
            var redirectChain = void 0 === _ref$redirectChain ? [] : _ref$redirectChain;
            var _ref$status = _ref.status;
            var status = void 0 === _ref$status ? EMPTY : _ref$status;
            var navigationId = _ref.uuid;
            _classCallCheck(this, Navigation);
            this.stack = stack.concat();
            this.status = status;
            if (void 0 !== url) this.url = url; else {
                var lastNavigation = (0, _lodashArrayLast2["default"])(this.stack);
                this.url = lastNavigation ? lastNavigation.url : null;
            }
            this.uuid = navigationId || _uuid2["default"].v4();
            this.redirectChain = redirectChain;
            this.previousUrl = previousUrl;
            this.previousRedirectChain = previousRedirectChain.concat();
        }
        _createClass(Navigation, [ {
            key: "update",
            value: function(navData) {
                if (navData.status === DOM_CONTENT_LOADED && this.url !== navData.url) return this;
                if (navData.status === COMPLETED && this.url !== navData.url) return this;
                if (navData.status === BEFORE_NAVIGATE) {
                    this.previousUrl = this.url;
                    this.previousRedirectChain = this.redirectChain.concat();
                    this.clear();
                    this.uuid = _uuid2["default"].v4();
                }
                if (navData.status === COMMITTED) this._onCommitted(navData);
                if (navData.status === HISTORY_STATE_UPDATED) this._onHistoryStateUpdated();
                this.stack.push(navData);
                this._updateStatus(navData);
                this.url = navData.url;
                return this;
            }
        }, {
            key: "_onHistoryStateUpdated",
            value: function() {
                if (this.isCompleted) return;
                this.redirectChain.push((0, _lodashArrayLast2["default"])(this.stack).url);
            }
        }, {
            key: "getNavigationStack",
            value: function() {
                return this.redirectChain.concat(this.url);
            }
        }, {
            key: "_onCommitted",
            value: function(navData) {
                var lastNavState = (0, _lodashArrayLast2["default"])(this.stack);
                if (navData.transitionQualifiers) {
                    if (this._wasClientRedirect(navData)) {
                        var _redirectChain;
                        (_redirectChain = this.redirectChain).push.apply(_redirectChain, _toConsumableArray(this.previousRedirectChain).concat([ this.previousUrl ]));
                    }
                    if (this._wasServerRedirect(navData)) this.redirectChain.push(lastNavState.url);
                }
                if (!lastNavState || lastNavState.status !== BEFORE_NAVIGATE) {
                    this.previousUrl = this.url;
                    this.previousRedirectChain = this.redirectChain.concat();
                    this.clear();
                    this.uuid = _uuid2["default"].v4();
                }
            }
        }, {
            key: "_wasClientRedirect",
            value: function(navData) {
                return navData.transitionQualifiers.indexOf(CLIENT_REDIRECT) !== -1;
            }
        }, {
            key: "_wasServerRedirect",
            value: function(navData) {
                return navData.transitionQualifiers.indexOf(SERVER_REDIRECT) !== -1;
            }
        }, {
            key: "clear",
            value: function() {
                this.url = null;
                this.stack.length = 0;
                this.redirectChain.length = 0;
                this.uuid = _uuid2["default"].v4();
                return this;
            }
        }, {
            key: "_updateStatus",
            value: function(_ref2) {
                var status = _ref2.status;
                if (POSSIBLE_STATUSES.indexOf(status) !== -1) this.status = status;
            }
        }, {
            key: "isEmpty",
            get: function() {
                return this.status === EMPTY;
            }
        }, {
            key: "isStarted",
            get: function() {
                return this.status === BEFORE_NAVIGATE;
            }
        }, {
            key: "isCompleted",
            get: function() {
                return this.status === COMPLETED;
            }
        }, {
            key: "isFinished",
            get: function() {
                return this.isCompleted || this.isError;
            }
        }, {
            key: "isError",
            get: function() {
                return this.status === ERROR_OCCURRED;
            }
        } ]);
        return Navigation;
    }();
    exports["default"] = Navigation;
}, function(module, exports, __webpack_require__) {
    var _rng = __webpack_require__(315);
    var _byteToHex = [];
    var _hexToByte = {};
    for (var i = 0; i < 256; i++) {
        _byteToHex[i] = (i + 256).toString(16).substr(1);
        _hexToByte[_byteToHex[i]] = i;
    }
    function parse(s, buf, offset) {
        var i = buf && offset || 0, ii = 0;
        buf = buf || [];
        s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
            if (ii < 16) buf[i + ii++] = _hexToByte[oct];
        });
        while (ii < 16) buf[i + ii++] = 0;
        return buf;
    }
    function unparse(buf, offset) {
        var i = offset || 0, bth = _byteToHex;
        return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
    }
    var _seedBytes = _rng();
    var _nodeId = [ 1 | _seedBytes[0], _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5] ];
    var _clockseq = 16383 & (_seedBytes[6] << 8 | _seedBytes[7]);
    var _lastMSecs = 0, _lastNSecs = 0;
    function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || [];
        options = options || {};
        var clockseq = void 0 !== options.clockseq ? options.clockseq : _clockseq;
        var msecs = void 0 !== options.msecs ? options.msecs : new Date().getTime();
        var nsecs = void 0 !== options.nsecs ? options.nsecs : _lastNSecs + 1;
        var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt < 0 && void 0 === options.clockseq) clockseq = clockseq + 1 & 16383;
        if ((dt < 0 || msecs > _lastMSecs) && void 0 === options.nsecs) nsecs = 0;
        if (nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        var tl = (1e4 * (268435455 & msecs) + nsecs) % 4294967296;
        b[i++] = tl >>> 24 & 255;
        b[i++] = tl >>> 16 & 255;
        b[i++] = tl >>> 8 & 255;
        b[i++] = 255 & tl;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b[i++] = tmh >>> 8 & 255;
        b[i++] = 255 & tmh;
        b[i++] = tmh >>> 24 & 15 | 16;
        b[i++] = tmh >>> 16 & 255;
        b[i++] = clockseq >>> 8 | 128;
        b[i++] = 255 & clockseq;
        var node = options.node || _nodeId;
        for (var n = 0; n < 6; n++) b[i + n] = node[n];
        return buf ? buf : unparse(b);
    }
    function v4(options, buf, offset) {
        var i = buf && offset || 0;
        if ("string" == typeof options) {
            buf = "binary" == options ? new Array(16) : null;
            options = null;
        }
        options = options || {};
        var rnds = options.random || (options.rng || _rng)();
        rnds[6] = 15 & rnds[6] | 64;
        rnds[8] = 63 & rnds[8] | 128;
        if (buf) for (var ii = 0; ii < 16; ii++) buf[i + ii] = rnds[ii];
        return buf || unparse(rnds);
    }
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    uuid.parse = parse;
    uuid.unparse = unparse;
    module.exports = uuid;
}, function(module, exports) {
    (function(global) {
        var rng;
        var crypto = global.crypto || global.msCrypto;
        if (crypto && crypto.getRandomValues) {
            var _rnds8 = new Uint8Array(16);
            rng = function() {
                crypto.getRandomValues(_rnds8);
                return _rnds8;
            };
        }
        if (!rng) {
            var _rnds = new Array(16);
            rng = function() {
                for (var r, i = 0; i < 16; i++) {
                    if (0 === (3 & i)) r = 4294967296 * Math.random();
                    _rnds[i] = r >>> ((3 & i) << 3) & 255;
                }
                return _rnds;
            };
        }
        module.exports = rng;
    }).call(exports, function() {
        return this;
    }());
}, function(module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Model = function() {
        function Model() {
            _classCallCheck(this, Model);
            this.removed = false;
        }
        _createClass(Model, [ {
            key: "getId",
            value: function() {
                throw new Error("Not implemented");
            }
        }, {
            key: "merge",
            value: function() {
                throw new Error("Not implemented");
            }
        }, {
            key: "clone",
            value: function() {
                throw new Error("Not implemented");
            }
        } ]);
        return Model;
    }();
    exports["default"] = Model;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _lodash = __webpack_require__(318);
    var _lodash2 = _interopRequireDefault(_lodash);
    var Storage = function() {
        function Storage(CollectionConstructor) {
            _classCallCheck(this, Storage);
            this.cache = new Map();
            this.collections = [];
            this.collectionConstructor = CollectionConstructor;
        }
        _createClass(Storage, [ {
            key: "query",
            value: function(_query) {
                var collection = this._collectionFactory(_query);
                this.collections.push(collection);
                return collection;
            }
        }, {
            key: "snapshot",
            value: function(query) {
                return this._collectionFactory(query);
            }
        }, {
            key: "_collectionFactory",
            value: function(query) {
                var collection = new this.collectionConstructor(this, query);
                collection.update(this.cache.values());
                return collection;
            }
        }, {
            key: "getById",
            value: function(id) {
                return this.cache.has(id) ? this.cache.get(id).clone() : null;
            }
        }, {
            key: "update",
            value: function() {
                var _this = this;
                var items = arguments.length <= 0 || void 0 === arguments[0] ? [] : arguments[0];
                if (!Array.isArray(items)) items = [ items ];
                items.forEach(function(item) {
                    _this.cache.set(item.getId(), item);
                });
                this._updateCollections(items);
                return this;
            }
        }, {
            key: "merge",
            value: function() {
                var _this2 = this;
                var dataDiff = arguments.length <= 0 || void 0 === arguments[0] ? [] : arguments[0];
                var isArray = true;
                if (!Array.isArray(dataDiff)) {
                    dataDiff = [ dataDiff ];
                    isArray = false;
                }
                var items = (0, _lodash2["default"])(dataDiff).filter(function(_ref) {
                    var id = _ref.id;
                    return _this2.cache.has(id);
                }).map(function(_ref2) {
                    var id = _ref2.id;
                    var diff = _ref2.diff;
                    var item = _this2.cache.get(id).clone().merge(diff);
                    _this2.cache.set(id, item);
                    return item;
                }).value();
                this._updateCollections(items);
                return isArray ? items : items[0] || null;
            }
        }, {
            key: "getDiffObject",
            value: function(id, data) {
                return {
                    id: id,
                    diff: data
                };
            }
        }, {
            key: "remove",
            value: function() {
                var _this3 = this;
                var ids = arguments.length <= 0 || void 0 === arguments[0] ? [] : arguments[0];
                var isArray = true;
                if (!Array.isArray(ids)) {
                    ids = [ ids ];
                    isArray = false;
                }
                var items = (0, _lodash2["default"])(ids).filter(function(id) {
                    return _this3.cache.has(id);
                }).map(function(id) {
                    var item = _this3.cache.get(id);
                    item.removed = true;
                    _this3.cache["delete"](id);
                    return item;
                }).value();
                this._updateCollections(ids, "remove");
                return isArray ? items : items[0];
            }
        }, {
            key: "activateCollection",
            value: function(collection) {
                if (this.collections.indexOf(collection) === -1) this.collections.push(collection);
                return this.reloadCollection(collection);
            }
        }, {
            key: "reloadCollection",
            value: function(collection) {
                if (!collection.enabled) return collection;
                collection.update(this.cache.values());
                return collection;
            }
        }, {
            key: "removeCollection",
            value: function(collection) {
                var indexOfCollection = this.collections.indexOf(collection);
                if (indexOfCollection !== -1) this.collections.splice(indexOfCollection, 1);
            }
        }, {
            key: "_updateCollections",
            value: function(items) {
                var method = arguments.length <= 1 || void 0 === arguments[1] ? "update" : arguments[1];
                this.collections.forEach(function(collection) {
                    if (!collection.enabled) return;
                    collection[method](items);
                });
            }
        }, {
            key: "clear",
            value: function() {
                this.collections.length = 0;
                this.cache.clear();
            }
        } ]);
        return Storage;
    }();
    exports["default"] = Storage;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    (function(module, global) {
        (function() {
            var undefined;
            var VERSION = "3.10.1";
            var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256;
            var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
            var HOT_COUNT = 150, HOT_SPAN = 16;
            var LARGE_ARRAY_SIZE = 200;
            var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2;
            var FUNC_ERROR_TEXT = "Expected a function";
            var PLACEHOLDER = "__lodash_placeholder__";
            var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
            var arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
            var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
            var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
            var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g, reHasRegExpChars = RegExp(reRegExpChars.source);
            var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
            var reEscapeChar = /\\(\\)?/g;
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
            var reFlags = /\w*$/;
            var reHasHexPrefix = /^0[xX]/;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^\d+$/;
            var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
            var reNoMatch = /($^)/;
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
            var reWords = function() {
                var upper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", lower = "[a-z\\xdf-\\xf6\\xf8-\\xff]+";
                return RegExp(upper + "+(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g");
            }();
            var contextProps = [ "Array", "ArrayBuffer", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Math", "Number", "Object", "RegExp", "Set", "String", "_", "clearTimeout", "isFinite", "parseFloat", "parseInt", "setTimeout", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap" ];
            var templateCounter = -1;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
            var deburredLetters = {
                "À": "A",
                "Á": "A",
                "Â": "A",
                "Ã": "A",
                "Ä": "A",
                "Å": "A",
                "à": "a",
                "á": "a",
                "â": "a",
                "ã": "a",
                "ä": "a",
                "å": "a",
                "Ç": "C",
                "ç": "c",
                "Ð": "D",
                "ð": "d",
                "È": "E",
                "É": "E",
                "Ê": "E",
                "Ë": "E",
                "è": "e",
                "é": "e",
                "ê": "e",
                "ë": "e",
                "Ì": "I",
                "Í": "I",
                "Î": "I",
                "Ï": "I",
                "ì": "i",
                "í": "i",
                "î": "i",
                "ï": "i",
                "Ñ": "N",
                "ñ": "n",
                "Ò": "O",
                "Ó": "O",
                "Ô": "O",
                "Õ": "O",
                "Ö": "O",
                "Ø": "O",
                "ò": "o",
                "ó": "o",
                "ô": "o",
                "õ": "o",
                "ö": "o",
                "ø": "o",
                "Ù": "U",
                "Ú": "U",
                "Û": "U",
                "Ü": "U",
                "ù": "u",
                "ú": "u",
                "û": "u",
                "ü": "u",
                "Ý": "Y",
                "ý": "y",
                "ÿ": "y",
                "Æ": "Ae",
                "æ": "ae",
                "Þ": "Th",
                "þ": "th",
                "ß": "ss"
            };
            var htmlEscapes = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
                "`": "&#96;"
            };
            var htmlUnescapes = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'",
                "&#96;": "`"
            };
            var objectTypes = {
                function: true,
                object: true
            };
            var regexpEscapes = {
                "0": "x30",
                "1": "x31",
                "2": "x32",
                "3": "x33",
                "4": "x34",
                "5": "x35",
                "6": "x36",
                "7": "x37",
                "8": "x38",
                "9": "x39",
                A: "x41",
                B: "x42",
                C: "x43",
                D: "x44",
                E: "x45",
                F: "x46",
                a: "x61",
                b: "x62",
                c: "x63",
                d: "x64",
                e: "x65",
                f: "x66",
                n: "x6e",
                r: "x72",
                t: "x74",
                u: "x75",
                v: "x76",
                x: "x78"
            };
            var stringEscapes = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
            };
            var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
            var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
            var freeGlobal = freeExports && freeModule && "object" == typeof global && global && global.Object && global;
            var freeSelf = objectTypes[typeof self] && self && self.Object && self;
            var freeWindow = objectTypes[typeof window] && window && window.Object && window;
            var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
            var root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || freeSelf || this;
            function baseCompareAscending(value, other) {
                if (value !== other) {
                    var valIsNull = null === value, valIsUndef = value === undefined, valIsReflexive = value === value;
                    var othIsNull = null === other, othIsUndef = other === undefined, othIsReflexive = other === other;
                    if (value > other && !othIsNull || !valIsReflexive || valIsNull && !othIsUndef && othIsReflexive || valIsUndef && othIsReflexive) return 1;
                    if (value < other && !valIsNull || !othIsReflexive || othIsNull && !valIsUndef && valIsReflexive || othIsUndef && valIsReflexive) return -1;
                }
                return 0;
            }
            function baseFindIndex(array, predicate, fromRight) {
                var length = array.length, index = fromRight ? length : -1;
                while (fromRight ? index-- : ++index < length) if (predicate(array[index], index, array)) return index;
                return -1;
            }
            function baseIndexOf(array, value, fromIndex) {
                if (value !== value) return indexOfNaN(array, fromIndex);
                var index = fromIndex - 1, length = array.length;
                while (++index < length) if (array[index] === value) return index;
                return -1;
            }
            function baseIsFunction(value) {
                return "function" == typeof value || false;
            }
            function baseToString(value) {
                return null == value ? "" : value + "";
            }
            function charsLeftIndex(string, chars) {
                var index = -1, length = string.length;
                while (++index < length && chars.indexOf(string.charAt(index)) > -1) ;
                return index;
            }
            function charsRightIndex(string, chars) {
                var index = string.length;
                while (index-- && chars.indexOf(string.charAt(index)) > -1) ;
                return index;
            }
            function compareAscending(object, other) {
                return baseCompareAscending(object.criteria, other.criteria) || object.index - other.index;
            }
            function compareMultiple(object, other, orders) {
                var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                while (++index < length) {
                    var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
                    if (result) {
                        if (index >= ordersLength) return result;
                        var order = orders[index];
                        return result * ("asc" === order || true === order ? 1 : -1);
                    }
                }
                return object.index - other.index;
            }
            function deburrLetter(letter) {
                return deburredLetters[letter];
            }
            function escapeHtmlChar(chr) {
                return htmlEscapes[chr];
            }
            function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
                if (leadingChar) chr = regexpEscapes[chr]; else if (whitespaceChar) chr = stringEscapes[chr];
                return "\\" + chr;
            }
            function escapeStringChar(chr) {
                return "\\" + stringEscapes[chr];
            }
            function indexOfNaN(array, fromIndex, fromRight) {
                var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
                while (fromRight ? index-- : ++index < length) {
                    var other = array[index];
                    if (other !== other) return index;
                }
                return -1;
            }
            function isObjectLike(value) {
                return !!value && "object" == typeof value;
            }
            function isSpace(charCode) {
                return charCode <= 160 && charCode >= 9 && charCode <= 13 || 32 == charCode || 160 == charCode || 5760 == charCode || 6158 == charCode || charCode >= 8192 && (charCode <= 8202 || 8232 == charCode || 8233 == charCode || 8239 == charCode || 8287 == charCode || 12288 == charCode || 65279 == charCode);
            }
            function replaceHolders(array, placeholder) {
                var index = -1, length = array.length, resIndex = -1, result = [];
                while (++index < length) if (array[index] === placeholder) {
                    array[index] = PLACEHOLDER;
                    result[++resIndex] = index;
                }
                return result;
            }
            function sortedUniq(array, iteratee) {
                var seen, index = -1, length = array.length, resIndex = -1, result = [];
                while (++index < length) {
                    var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                    if (!index || seen !== computed) {
                        seen = computed;
                        result[++resIndex] = value;
                    }
                }
                return result;
            }
            function trimmedLeftIndex(string) {
                var index = -1, length = string.length;
                while (++index < length && isSpace(string.charCodeAt(index))) ;
                return index;
            }
            function trimmedRightIndex(string) {
                var index = string.length;
                while (index-- && isSpace(string.charCodeAt(index))) ;
                return index;
            }
            function unescapeHtmlChar(chr) {
                return htmlUnescapes[chr];
            }
            function runInContext(context) {
                context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                var arrayProto = Array.prototype, objectProto = Object.prototype, stringProto = String.prototype;
                var fnToString = Function.prototype.toString;
                var hasOwnProperty = objectProto.hasOwnProperty;
                var idCounter = 0;
                var objToString = objectProto.toString;
                var oldDash = root._;
                var reIsNative = RegExp("^" + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                var ArrayBuffer = context.ArrayBuffer, clearTimeout = context.clearTimeout, parseFloat = context.parseFloat, pow = Math.pow, propertyIsEnumerable = objectProto.propertyIsEnumerable, Set = getNative(context, "Set"), setTimeout = context.setTimeout, splice = arrayProto.splice, Uint8Array = context.Uint8Array, WeakMap = getNative(context, "WeakMap");
                var nativeCeil = Math.ceil, nativeCreate = getNative(Object, "create"), nativeFloor = Math.floor, nativeIsArray = getNative(Array, "isArray"), nativeIsFinite = context.isFinite, nativeKeys = getNative(Object, "keys"), nativeMax = Math.max, nativeMin = Math.min, nativeNow = getNative(Date, "now"), nativeParseInt = context.parseInt, nativeRandom = Math.random;
                var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
                var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
                var MAX_SAFE_INTEGER = 9007199254740991;
                var metaMap = WeakMap && new WeakMap();
                var realNames = {};
                function lodash(value) {
                    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                        if (value instanceof LodashWrapper) return value;
                        if (hasOwnProperty.call(value, "__chain__") && hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value);
                    }
                    return new LodashWrapper(value);
                }
                function baseLodash() {}
                function LodashWrapper(value, chainAll, actions) {
                    this.__wrapped__ = value;
                    this.__actions__ = actions || [];
                    this.__chain__ = !!chainAll;
                }
                lodash.support = {};
                lodash.templateSettings = {
                    escape: reEscape,
                    evaluate: reEvaluate,
                    interpolate: reInterpolate,
                    variable: "",
                    imports: {
                        _: lodash
                    }
                };
                function LazyWrapper(value) {
                    this.__wrapped__ = value;
                    this.__actions__ = [];
                    this.__dir__ = 1;
                    this.__filtered__ = false;
                    this.__iteratees__ = [];
                    this.__takeCount__ = POSITIVE_INFINITY;
                    this.__views__ = [];
                }
                function lazyClone() {
                    var result = new LazyWrapper(this.__wrapped__);
                    result.__actions__ = arrayCopy(this.__actions__);
                    result.__dir__ = this.__dir__;
                    result.__filtered__ = this.__filtered__;
                    result.__iteratees__ = arrayCopy(this.__iteratees__);
                    result.__takeCount__ = this.__takeCount__;
                    result.__views__ = arrayCopy(this.__views__);
                    return result;
                }
                function lazyReverse() {
                    if (this.__filtered__) {
                        var result = new LazyWrapper(this);
                        result.__dir__ = -1;
                        result.__filtered__ = true;
                    } else {
                        result = this.clone();
                        result.__dir__ *= -1;
                    }
                    return result;
                }
                function lazyValue() {
                    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                    if (!isArr || arrLength < LARGE_ARRAY_SIZE || arrLength == length && takeCount == length) return baseWrapperValue(isRight && isArr ? array.reverse() : array, this.__actions__);
                    var result = [];
                    outer: while (length-- && resIndex < takeCount) {
                        index += dir;
                        var iterIndex = -1, value = array[index];
                        while (++iterIndex < iterLength) {
                            var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                            if (type == LAZY_MAP_FLAG) value = computed; else if (!computed) if (type == LAZY_FILTER_FLAG) continue outer; else break outer;
                        }
                        result[resIndex++] = value;
                    }
                    return result;
                }
                function MapCache() {
                    this.__data__ = {};
                }
                function mapDelete(key) {
                    return this.has(key) && delete this.__data__[key];
                }
                function mapGet(key) {
                    return "__proto__" == key ? undefined : this.__data__[key];
                }
                function mapHas(key) {
                    return "__proto__" != key && hasOwnProperty.call(this.__data__, key);
                }
                function mapSet(key, value) {
                    if ("__proto__" != key) this.__data__[key] = value;
                    return this;
                }
                function SetCache(values) {
                    var length = values ? values.length : 0;
                    this.data = {
                        hash: nativeCreate(null),
                        set: new Set()
                    };
                    while (length--) this.push(values[length]);
                }
                function cacheIndexOf(cache, value) {
                    var data = cache.data, result = "string" == typeof value || isObject(value) ? data.set.has(value) : data.hash[value];
                    return result ? 0 : -1;
                }
                function cachePush(value) {
                    var data = this.data;
                    if ("string" == typeof value || isObject(value)) data.set.add(value); else data.hash[value] = true;
                }
                function arrayConcat(array, other) {
                    var index = -1, length = array.length, othIndex = -1, othLength = other.length, result = Array(length + othLength);
                    while (++index < length) result[index] = array[index];
                    while (++othIndex < othLength) result[index++] = other[othIndex];
                    return result;
                }
                function arrayCopy(source, array) {
                    var index = -1, length = source.length;
                    array || (array = Array(length));
                    while (++index < length) array[index] = source[index];
                    return array;
                }
                function arrayEach(array, iteratee) {
                    var index = -1, length = array.length;
                    while (++index < length) if (false === iteratee(array[index], index, array)) break;
                    return array;
                }
                function arrayEachRight(array, iteratee) {
                    var length = array.length;
                    while (length--) if (false === iteratee(array[length], length, array)) break;
                    return array;
                }
                function arrayEvery(array, predicate) {
                    var index = -1, length = array.length;
                    while (++index < length) if (!predicate(array[index], index, array)) return false;
                    return true;
                }
                function arrayExtremum(array, iteratee, comparator, exValue) {
                    var index = -1, length = array.length, computed = exValue, result = computed;
                    while (++index < length) {
                        var value = array[index], current = +iteratee(value);
                        if (comparator(current, computed)) {
                            computed = current;
                            result = value;
                        }
                    }
                    return result;
                }
                function arrayFilter(array, predicate) {
                    var index = -1, length = array.length, resIndex = -1, result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (predicate(value, index, array)) result[++resIndex] = value;
                    }
                    return result;
                }
                function arrayMap(array, iteratee) {
                    var index = -1, length = array.length, result = Array(length);
                    while (++index < length) result[index] = iteratee(array[index], index, array);
                    return result;
                }
                function arrayPush(array, values) {
                    var index = -1, length = values.length, offset = array.length;
                    while (++index < length) array[offset + index] = values[index];
                    return array;
                }
                function arrayReduce(array, iteratee, accumulator, initFromArray) {
                    var index = -1, length = array.length;
                    if (initFromArray && length) accumulator = array[++index];
                    while (++index < length) accumulator = iteratee(accumulator, array[index], index, array);
                    return accumulator;
                }
                function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
                    var length = array.length;
                    if (initFromArray && length) accumulator = array[--length];
                    while (length--) accumulator = iteratee(accumulator, array[length], length, array);
                    return accumulator;
                }
                function arraySome(array, predicate) {
                    var index = -1, length = array.length;
                    while (++index < length) if (predicate(array[index], index, array)) return true;
                    return false;
                }
                function arraySum(array, iteratee) {
                    var length = array.length, result = 0;
                    while (length--) result += +iteratee(array[length]) || 0;
                    return result;
                }
                function assignDefaults(objectValue, sourceValue) {
                    return objectValue === undefined ? sourceValue : objectValue;
                }
                function assignOwnDefaults(objectValue, sourceValue, key, object) {
                    return objectValue === undefined || !hasOwnProperty.call(object, key) ? sourceValue : objectValue;
                }
                function assignWith(object, source, customizer) {
                    var index = -1, props = keys(source), length = props.length;
                    while (++index < length) {
                        var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
                        if ((result === result ? result !== value : value === value) || value === undefined && !(key in object)) object[key] = result;
                    }
                    return object;
                }
                function baseAssign(object, source) {
                    return null == source ? object : baseCopy(source, keys(source), object);
                }
                function baseAt(collection, props) {
                    var index = -1, isNil = null == collection, isArr = !isNil && isArrayLike(collection), length = isArr ? collection.length : 0, propsLength = props.length, result = Array(propsLength);
                    while (++index < propsLength) {
                        var key = props[index];
                        if (isArr) result[index] = isIndex(key, length) ? collection[key] : undefined; else result[index] = isNil ? undefined : collection[key];
                    }
                    return result;
                }
                function baseCopy(source, props, object) {
                    object || (object = {});
                    var index = -1, length = props.length;
                    while (++index < length) {
                        var key = props[index];
                        object[key] = source[key];
                    }
                    return object;
                }
                function baseCallback(func, thisArg, argCount) {
                    var type = typeof func;
                    if ("function" == type) return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
                    if (null == func) return identity;
                    if ("object" == type) return baseMatches(func);
                    return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
                }
                function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                    var result;
                    if (customizer) result = object ? customizer(value, key, object) : customizer(value);
                    if (result !== undefined) return result;
                    if (!isObject(value)) return value;
                    var isArr = isArray(value);
                    if (isArr) {
                        result = initCloneArray(value);
                        if (!isDeep) return arrayCopy(value, result);
                    } else {
                        var tag = objToString.call(value), isFunc = tag == funcTag;
                        if (tag == objectTag || tag == argsTag || isFunc && !object) {
                            result = initCloneObject(isFunc ? {} : value);
                            if (!isDeep) return baseAssign(result, value);
                        } else return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
                    }
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    var length = stackA.length;
                    while (length--) if (stackA[length] == value) return stackB[length];
                    stackA.push(value);
                    stackB.push(result);
                    (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
                        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
                    });
                    return result;
                }
                var baseCreate = function() {
                    function object() {}
                    return function(prototype) {
                        if (isObject(prototype)) {
                            object.prototype = prototype;
                            var result = new object();
                            object.prototype = undefined;
                        }
                        return result || {};
                    };
                }();
                function baseDelay(func, wait, args) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return setTimeout(function() {
                        func.apply(undefined, args);
                    }, wait);
                }
                function baseDifference(array, values) {
                    var length = array ? array.length : 0, result = [];
                    if (!length) return result;
                    var index = -1, indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, cache = isCommon && values.length >= LARGE_ARRAY_SIZE ? createCache(values) : null, valuesLength = values.length;
                    if (cache) {
                        indexOf = cacheIndexOf;
                        isCommon = false;
                        values = cache;
                    }
                    outer: while (++index < length) {
                        var value = array[index];
                        if (isCommon && value === value) {
                            var valuesIndex = valuesLength;
                            while (valuesIndex--) if (values[valuesIndex] === value) continue outer;
                            result.push(value);
                        } else if (indexOf(values, value, 0) < 0) result.push(value);
                    }
                    return result;
                }
                var baseEach = createBaseEach(baseForOwn);
                var baseEachRight = createBaseEach(baseForOwnRight, true);
                function baseEvery(collection, predicate) {
                    var result = true;
                    baseEach(collection, function(value, index, collection) {
                        result = !!predicate(value, index, collection);
                        return result;
                    });
                    return result;
                }
                function baseExtremum(collection, iteratee, comparator, exValue) {
                    var computed = exValue, result = computed;
                    baseEach(collection, function(value, index, collection) {
                        var current = +iteratee(value, index, collection);
                        if (comparator(current, computed) || current === exValue && current === result) {
                            computed = current;
                            result = value;
                        }
                    });
                    return result;
                }
                function baseFill(array, value, start, end) {
                    var length = array.length;
                    start = null == start ? 0 : +start || 0;
                    if (start < 0) start = -start > length ? 0 : length + start;
                    end = end === undefined || end > length ? length : +end || 0;
                    if (end < 0) end += length;
                    length = start > end ? 0 : end >>> 0;
                    start >>>= 0;
                    while (start < length) array[start++] = value;
                    return array;
                }
                function baseFilter(collection, predicate) {
                    var result = [];
                    baseEach(collection, function(value, index, collection) {
                        if (predicate(value, index, collection)) result.push(value);
                    });
                    return result;
                }
                function baseFind(collection, predicate, eachFunc, retKey) {
                    var result;
                    eachFunc(collection, function(value, key, collection) {
                        if (predicate(value, key, collection)) {
                            result = retKey ? key : value;
                            return false;
                        }
                    });
                    return result;
                }
                function baseFlatten(array, isDeep, isStrict, result) {
                    result || (result = []);
                    var index = -1, length = array.length;
                    while (++index < length) {
                        var value = array[index];
                        if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) if (isDeep) baseFlatten(value, isDeep, isStrict, result); else arrayPush(result, value); else if (!isStrict) result[result.length] = value;
                    }
                    return result;
                }
                var baseFor = createBaseFor();
                var baseForRight = createBaseFor(true);
                function baseForIn(object, iteratee) {
                    return baseFor(object, iteratee, keysIn);
                }
                function baseForOwn(object, iteratee) {
                    return baseFor(object, iteratee, keys);
                }
                function baseForOwnRight(object, iteratee) {
                    return baseForRight(object, iteratee, keys);
                }
                function baseFunctions(object, props) {
                    var index = -1, length = props.length, resIndex = -1, result = [];
                    while (++index < length) {
                        var key = props[index];
                        if (isFunction(object[key])) result[++resIndex] = key;
                    }
                    return result;
                }
                function baseGet(object, path, pathKey) {
                    if (null == object) return;
                    if (pathKey !== undefined && pathKey in toObject(object)) path = [ pathKey ];
                    var index = 0, length = path.length;
                    while (null != object && index < length) object = object[path[index++]];
                    return index && index == length ? object : undefined;
                }
                function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                    if (value === other) return true;
                    if (null == value || null == other || !isObject(value) && !isObjectLike(other)) return value !== value && other !== other;
                    return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
                }
                function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
                    if (!objIsArr) {
                        objTag = objToString.call(object);
                        if (objTag == argsTag) objTag = objectTag; else if (objTag != objectTag) objIsArr = isTypedArray(object);
                    }
                    if (!othIsArr) {
                        othTag = objToString.call(other);
                        if (othTag == argsTag) othTag = objectTag; else if (othTag != objectTag) othIsArr = isTypedArray(other);
                    }
                    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                    if (isSameTag && !(objIsArr || objIsObj)) return equalByTag(object, other, objTag);
                    if (!isLoose) {
                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                        if (objIsWrapped || othIsWrapped) return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                    }
                    if (!isSameTag) return false;
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    var length = stackA.length;
                    while (length--) if (stackA[length] == object) return stackB[length] == other;
                    stackA.push(object);
                    stackB.push(other);
                    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
                    stackA.pop();
                    stackB.pop();
                    return result;
                }
                function baseIsMatch(object, matchData, customizer) {
                    var index = matchData.length, length = index, noCustomizer = !customizer;
                    if (null == object) return !length;
                    object = toObject(object);
                    while (index--) {
                        var data = matchData[index];
                        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
                    }
                    while (++index < length) {
                        data = matchData[index];
                        var key = data[0], objValue = object[key], srcValue = data[1];
                        if (noCustomizer && data[2]) {
                            if (objValue === undefined && !(key in object)) return false;
                        } else {
                            var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) return false;
                        }
                    }
                    return true;
                }
                function baseMap(collection, iteratee) {
                    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                    baseEach(collection, function(value, key, collection) {
                        result[++index] = iteratee(value, key, collection);
                    });
                    return result;
                }
                function baseMatches(source) {
                    var matchData = getMatchData(source);
                    if (1 == matchData.length && matchData[0][2]) {
                        var key = matchData[0][0], value = matchData[0][1];
                        return function(object) {
                            if (null == object) return false;
                            return object[key] === value && (value !== undefined || key in toObject(object));
                        };
                    }
                    return function(object) {
                        return baseIsMatch(object, matchData);
                    };
                }
                function baseMatchesProperty(path, srcValue) {
                    var isArr = isArray(path), isCommon = isKey(path) && isStrictComparable(srcValue), pathKey = path + "";
                    path = toPath(path);
                    return function(object) {
                        if (null == object) return false;
                        var key = pathKey;
                        object = toObject(object);
                        if ((isArr || !isCommon) && !(key in object)) {
                            object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1));
                            if (null == object) return false;
                            key = last(path);
                            object = toObject(object);
                        }
                        return object[key] === srcValue ? srcValue !== undefined || key in object : baseIsEqual(srcValue, object[key], undefined, true);
                    };
                }
                function baseMerge(object, source, customizer, stackA, stackB) {
                    if (!isObject(object)) return object;
                    var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)), props = isSrcArr ? undefined : keys(source);
                    arrayEach(props || source, function(srcValue, key) {
                        if (props) {
                            key = srcValue;
                            srcValue = source[key];
                        }
                        if (isObjectLike(srcValue)) {
                            stackA || (stackA = []);
                            stackB || (stackB = []);
                            baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                        } else {
                            var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = result === undefined;
                            if (isCommon) result = srcValue;
                            if ((result !== undefined || isSrcArr && !(key in object)) && (isCommon || (result === result ? result !== value : value === value))) object[key] = result;
                        }
                    });
                    return object;
                }
                function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
                    var length = stackA.length, srcValue = source[key];
                    while (length--) if (stackA[length] == srcValue) {
                        object[key] = stackB[length];
                        return;
                    }
                    var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = result === undefined;
                    if (isCommon) {
                        result = srcValue;
                        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) result = isArray(value) ? value : isArrayLike(value) ? arrayCopy(value) : []; else if (isPlainObject(srcValue) || isArguments(srcValue)) result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {}; else isCommon = false;
                    }
                    stackA.push(srcValue);
                    stackB.push(result);
                    if (isCommon) object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB); else if (result === result ? result !== value : value === value) object[key] = result;
                }
                function baseProperty(key) {
                    return function(object) {
                        return null == object ? undefined : object[key];
                    };
                }
                function basePropertyDeep(path) {
                    var pathKey = path + "";
                    path = toPath(path);
                    return function(object) {
                        return baseGet(object, path, pathKey);
                    };
                }
                function basePullAt(array, indexes) {
                    var length = array ? indexes.length : 0;
                    while (length--) {
                        var index = indexes[length];
                        if (index != previous && isIndex(index)) {
                            var previous = index;
                            splice.call(array, index, 1);
                        }
                    }
                    return array;
                }
                function baseRandom(min, max) {
                    return min + nativeFloor(nativeRandom() * (max - min + 1));
                }
                function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
                    eachFunc(collection, function(value, index, collection) {
                        accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
                    });
                    return accumulator;
                }
                var baseSetData = !metaMap ? identity : function(func, data) {
                    metaMap.set(func, data);
                    return func;
                };
                function baseSlice(array, start, end) {
                    var index = -1, length = array.length;
                    start = null == start ? 0 : +start || 0;
                    if (start < 0) start = -start > length ? 0 : length + start;
                    end = end === undefined || end > length ? length : +end || 0;
                    if (end < 0) end += length;
                    length = start > end ? 0 : end - start >>> 0;
                    start >>>= 0;
                    var result = Array(length);
                    while (++index < length) result[index] = array[index + start];
                    return result;
                }
                function baseSome(collection, predicate) {
                    var result;
                    baseEach(collection, function(value, index, collection) {
                        result = predicate(value, index, collection);
                        return !result;
                    });
                    return !!result;
                }
                function baseSortBy(array, comparer) {
                    var length = array.length;
                    array.sort(comparer);
                    while (length--) array[length] = array[length].value;
                    return array;
                }
                function baseSortByOrder(collection, iteratees, orders) {
                    var callback = getCallback(), index = -1;
                    iteratees = arrayMap(iteratees, function(iteratee) {
                        return callback(iteratee);
                    });
                    var result = baseMap(collection, function(value) {
                        var criteria = arrayMap(iteratees, function(iteratee) {
                            return iteratee(value);
                        });
                        return {
                            criteria: criteria,
                            index: ++index,
                            value: value
                        };
                    });
                    return baseSortBy(result, function(object, other) {
                        return compareMultiple(object, other, orders);
                    });
                }
                function baseSum(collection, iteratee) {
                    var result = 0;
                    baseEach(collection, function(value, index, collection) {
                        result += +iteratee(value, index, collection) || 0;
                    });
                    return result;
                }
                function baseUniq(array, iteratee) {
                    var index = -1, indexOf = getIndexOf(), length = array.length, isCommon = indexOf == baseIndexOf, isLarge = isCommon && length >= LARGE_ARRAY_SIZE, seen = isLarge ? createCache() : null, result = [];
                    if (seen) {
                        indexOf = cacheIndexOf;
                        isCommon = false;
                    } else {
                        isLarge = false;
                        seen = iteratee ? [] : result;
                    }
                    outer: while (++index < length) {
                        var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                        if (isCommon && value === value) {
                            var seenIndex = seen.length;
                            while (seenIndex--) if (seen[seenIndex] === computed) continue outer;
                            if (iteratee) seen.push(computed);
                            result.push(value);
                        } else if (indexOf(seen, computed, 0) < 0) {
                            if (iteratee || isLarge) seen.push(computed);
                            result.push(value);
                        }
                    }
                    return result;
                }
                function baseValues(object, props) {
                    var index = -1, length = props.length, result = Array(length);
                    while (++index < length) result[index] = object[props[index]];
                    return result;
                }
                function baseWhile(array, predicate, isDrop, fromRight) {
                    var length = array.length, index = fromRight ? length : -1;
                    while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) ;
                    return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                }
                function baseWrapperValue(value, actions) {
                    var result = value;
                    if (result instanceof LazyWrapper) result = result.value();
                    var index = -1, length = actions.length;
                    while (++index < length) {
                        var action = actions[index];
                        result = action.func.apply(action.thisArg, arrayPush([ result ], action.args));
                    }
                    return result;
                }
                function binaryIndex(array, value, retHighest) {
                    var low = 0, high = array ? array.length : low;
                    if ("number" == typeof value && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                        while (low < high) {
                            var mid = low + high >>> 1, computed = array[mid];
                            if ((retHighest ? computed <= value : computed < value) && null !== computed) low = mid + 1; else high = mid;
                        }
                        return high;
                    }
                    return binaryIndexBy(array, value, identity, retHighest);
                }
                function binaryIndexBy(array, value, iteratee, retHighest) {
                    value = iteratee(value);
                    var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsNull = null === value, valIsUndef = value === undefined;
                    while (low < high) {
                        var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), isDef = computed !== undefined, isReflexive = computed === computed;
                        if (valIsNaN) var setLow = isReflexive || retHighest; else if (valIsNull) setLow = isReflexive && isDef && (retHighest || null != computed); else if (valIsUndef) setLow = isReflexive && (retHighest || isDef); else if (null == computed) setLow = false; else setLow = retHighest ? computed <= value : computed < value;
                        if (setLow) low = mid + 1; else high = mid;
                    }
                    return nativeMin(high, MAX_ARRAY_INDEX);
                }
                function bindCallback(func, thisArg, argCount) {
                    if ("function" != typeof func) return identity;
                    if (thisArg === undefined) return func;
                    switch (argCount) {
                      case 1:
                        return function(value) {
                            return func.call(thisArg, value);
                        };

                      case 3:
                        return function(value, index, collection) {
                            return func.call(thisArg, value, index, collection);
                        };

                      case 4:
                        return function(accumulator, value, index, collection) {
                            return func.call(thisArg, accumulator, value, index, collection);
                        };

                      case 5:
                        return function(value, other, key, object, source) {
                            return func.call(thisArg, value, other, key, object, source);
                        };
                    }
                    return function() {
                        return func.apply(thisArg, arguments);
                    };
                }
                function bufferClone(buffer) {
                    var result = new ArrayBuffer(buffer.byteLength), view = new Uint8Array(result);
                    view.set(new Uint8Array(buffer));
                    return result;
                }
                function composeArgs(args, partials, holders) {
                    var holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), leftIndex = -1, leftLength = partials.length, result = Array(leftLength + argsLength);
                    while (++leftIndex < leftLength) result[leftIndex] = partials[leftIndex];
                    while (++argsIndex < holdersLength) result[holders[argsIndex]] = args[argsIndex];
                    while (argsLength--) result[leftIndex++] = args[argsIndex++];
                    return result;
                }
                function composeArgsRight(args, partials, holders) {
                    var holdersIndex = -1, holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), rightIndex = -1, rightLength = partials.length, result = Array(argsLength + rightLength);
                    while (++argsIndex < argsLength) result[argsIndex] = args[argsIndex];
                    var offset = argsIndex;
                    while (++rightIndex < rightLength) result[offset + rightIndex] = partials[rightIndex];
                    while (++holdersIndex < holdersLength) result[offset + holders[holdersIndex]] = args[argsIndex++];
                    return result;
                }
                function createAggregator(setter, initializer) {
                    return function(collection, iteratee, thisArg) {
                        var result = initializer ? initializer() : {};
                        iteratee = getCallback(iteratee, thisArg, 3);
                        if (isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                setter(result, value, iteratee(value, index, collection), collection);
                            }
                        } else baseEach(collection, function(value, key, collection) {
                            setter(result, value, iteratee(value, key, collection), collection);
                        });
                        return result;
                    };
                }
                function createAssigner(assigner) {
                    return restParam(function(object, sources) {
                        var index = -1, length = null == object ? 0 : sources.length, customizer = length > 2 ? sources[length - 2] : undefined, guard = length > 2 ? sources[2] : undefined, thisArg = length > 1 ? sources[length - 1] : undefined;
                        if ("function" == typeof customizer) {
                            customizer = bindCallback(customizer, thisArg, 5);
                            length -= 2;
                        } else {
                            customizer = "function" == typeof thisArg ? thisArg : undefined;
                            length -= customizer ? 1 : 0;
                        }
                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                            customizer = length < 3 ? undefined : customizer;
                            length = 1;
                        }
                        while (++index < length) {
                            var source = sources[index];
                            if (source) assigner(object, source, customizer);
                        }
                        return object;
                    });
                }
                function createBaseEach(eachFunc, fromRight) {
                    return function(collection, iteratee) {
                        var length = collection ? getLength(collection) : 0;
                        if (!isLength(length)) return eachFunc(collection, iteratee);
                        var index = fromRight ? length : -1, iterable = toObject(collection);
                        while (fromRight ? index-- : ++index < length) if (false === iteratee(iterable[index], index, iterable)) break;
                        return collection;
                    };
                }
                function createBaseFor(fromRight) {
                    return function(object, iteratee, keysFunc) {
                        var iterable = toObject(object), props = keysFunc(object), length = props.length, index = fromRight ? length : -1;
                        while (fromRight ? index-- : ++index < length) {
                            var key = props[index];
                            if (false === iteratee(iterable[key], key, iterable)) break;
                        }
                        return object;
                    };
                }
                function createBindWrapper(func, thisArg) {
                    var Ctor = createCtorWrapper(func);
                    function wrapper() {
                        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                        return fn.apply(thisArg, arguments);
                    }
                    return wrapper;
                }
                function createCache(values) {
                    return nativeCreate && Set ? new SetCache(values) : null;
                }
                function createCompounder(callback) {
                    return function(string) {
                        var index = -1, array = words(deburr(string)), length = array.length, result = "";
                        while (++index < length) result = callback(result, array[index], index);
                        return result;
                    };
                }
                function createCtorWrapper(Ctor) {
                    return function() {
                        var args = arguments;
                        switch (args.length) {
                          case 0:
                            return new Ctor();

                          case 1:
                            return new Ctor(args[0]);

                          case 2:
                            return new Ctor(args[0], args[1]);

                          case 3:
                            return new Ctor(args[0], args[1], args[2]);

                          case 4:
                            return new Ctor(args[0], args[1], args[2], args[3]);

                          case 5:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4]);

                          case 6:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

                          case 7:
                            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                        }
                        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                        return isObject(result) ? result : thisBinding;
                    };
                }
                function createCurry(flag) {
                    function curryFunc(func, arity, guard) {
                        if (guard && isIterateeCall(func, arity, guard)) arity = undefined;
                        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
                        result.placeholder = curryFunc.placeholder;
                        return result;
                    }
                    return curryFunc;
                }
                function createDefaults(assigner, customizer) {
                    return restParam(function(args) {
                        var object = args[0];
                        if (null == object) return object;
                        args.push(customizer);
                        return assigner.apply(undefined, args);
                    });
                }
                function createExtremum(comparator, exValue) {
                    return function(collection, iteratee, thisArg) {
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) iteratee = undefined;
                        iteratee = getCallback(iteratee, thisArg, 3);
                        if (1 == iteratee.length) {
                            collection = isArray(collection) ? collection : toIterable(collection);
                            var result = arrayExtremum(collection, iteratee, comparator, exValue);
                            if (!(collection.length && result === exValue)) return result;
                        }
                        return baseExtremum(collection, iteratee, comparator, exValue);
                    };
                }
                function createFind(eachFunc, fromRight) {
                    return function(collection, predicate, thisArg) {
                        predicate = getCallback(predicate, thisArg, 3);
                        if (isArray(collection)) {
                            var index = baseFindIndex(collection, predicate, fromRight);
                            return index > -1 ? collection[index] : undefined;
                        }
                        return baseFind(collection, predicate, eachFunc);
                    };
                }
                function createFindIndex(fromRight) {
                    return function(array, predicate, thisArg) {
                        if (!(array && array.length)) return -1;
                        predicate = getCallback(predicate, thisArg, 3);
                        return baseFindIndex(array, predicate, fromRight);
                    };
                }
                function createFindKey(objectFunc) {
                    return function(object, predicate, thisArg) {
                        predicate = getCallback(predicate, thisArg, 3);
                        return baseFind(object, predicate, objectFunc, true);
                    };
                }
                function createFlow(fromRight) {
                    return function() {
                        var wrapper, length = arguments.length, index = fromRight ? length : -1, leftIndex = 0, funcs = Array(length);
                        while (fromRight ? index-- : ++index < length) {
                            var func = funcs[leftIndex++] = arguments[index];
                            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                            if (!wrapper && LodashWrapper.prototype.thru && "wrapper" == getFuncName(func)) wrapper = new LodashWrapper([], true);
                        }
                        index = wrapper ? -1 : length;
                        while (++index < length) {
                            func = funcs[index];
                            var funcName = getFuncName(func), data = "wrapper" == funcName ? getData(func) : undefined;
                            if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && 1 == data[9]) wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]); else wrapper = 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                        }
                        return function() {
                            var args = arguments, value = args[0];
                            if (wrapper && 1 == args.length && isArray(value) && value.length >= LARGE_ARRAY_SIZE) return wrapper.plant(value).value();
                            var index = 0, result = length ? funcs[index].apply(this, args) : value;
                            while (++index < length) result = funcs[index].call(this, result);
                            return result;
                        };
                    };
                }
                function createForEach(arrayFunc, eachFunc) {
                    return function(collection, iteratee, thisArg) {
                        return "function" == typeof iteratee && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
                    };
                }
                function createForIn(objectFunc) {
                    return function(object, iteratee, thisArg) {
                        if ("function" != typeof iteratee || thisArg !== undefined) iteratee = bindCallback(iteratee, thisArg, 3);
                        return objectFunc(object, iteratee, keysIn);
                    };
                }
                function createForOwn(objectFunc) {
                    return function(object, iteratee, thisArg) {
                        if ("function" != typeof iteratee || thisArg !== undefined) iteratee = bindCallback(iteratee, thisArg, 3);
                        return objectFunc(object, iteratee);
                    };
                }
                function createObjectMapper(isMapKeys) {
                    return function(object, iteratee, thisArg) {
                        var result = {};
                        iteratee = getCallback(iteratee, thisArg, 3);
                        baseForOwn(object, function(value, key, object) {
                            var mapped = iteratee(value, key, object);
                            key = isMapKeys ? mapped : key;
                            value = isMapKeys ? value : mapped;
                            result[key] = value;
                        });
                        return result;
                    };
                }
                function createPadDir(fromRight) {
                    return function(string, length, chars) {
                        string = baseToString(string);
                        return (fromRight ? string : "") + createPadding(string, length, chars) + (fromRight ? "" : string);
                    };
                }
                function createPartial(flag) {
                    var partialFunc = restParam(function(func, partials) {
                        var holders = replaceHolders(partials, partialFunc.placeholder);
                        return createWrapper(func, flag, undefined, partials, holders);
                    });
                    return partialFunc;
                }
                function createReduce(arrayFunc, eachFunc) {
                    return function(collection, iteratee, accumulator, thisArg) {
                        var initFromArray = arguments.length < 3;
                        return "function" == typeof iteratee && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
                    };
                }
                function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                    var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurry = bitmask & CURRY_FLAG, isCurryBound = bitmask & CURRY_BOUND_FLAG, isCurryRight = bitmask & CURRY_RIGHT_FLAG, Ctor = isBindKey ? undefined : createCtorWrapper(func);
                    function wrapper() {
                        var length = arguments.length, index = length, args = Array(length);
                        while (index--) args[index] = arguments[index];
                        if (partials) args = composeArgs(args, partials, holders);
                        if (partialsRight) args = composeArgsRight(args, partialsRight, holdersRight);
                        if (isCurry || isCurryRight) {
                            var placeholder = wrapper.placeholder, argsHolders = replaceHolders(args, placeholder);
                            length -= argsHolders.length;
                            if (length < arity) {
                                var newArgPos = argPos ? arrayCopy(argPos) : undefined, newArity = nativeMax(arity - length, 0), newsHolders = isCurry ? argsHolders : undefined, newHoldersRight = isCurry ? undefined : argsHolders, newPartials = isCurry ? args : undefined, newPartialsRight = isCurry ? undefined : args;
                                bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                                if (!isCurryBound) bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                                var newData = [ func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity ], result = createHybridWrapper.apply(undefined, newData);
                                if (isLaziable(func)) setData(result, newData);
                                result.placeholder = placeholder;
                                return result;
                            }
                        }
                        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                        if (argPos) args = reorder(args, argPos);
                        if (isAry && ary < args.length) args.length = ary;
                        if (this && this !== root && this instanceof wrapper) fn = Ctor || createCtorWrapper(func);
                        return fn.apply(thisBinding, args);
                    }
                    return wrapper;
                }
                function createPadding(string, length, chars) {
                    var strLength = string.length;
                    length = +length;
                    if (strLength >= length || !nativeIsFinite(length)) return "";
                    var padLength = length - strLength;
                    chars = null == chars ? " " : chars + "";
                    return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
                }
                function createPartialWrapper(func, bitmask, thisArg, partials) {
                    var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
                    function wrapper() {
                        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength);
                        while (++leftIndex < leftLength) args[leftIndex] = partials[leftIndex];
                        while (argsLength--) args[leftIndex++] = arguments[++argsIndex];
                        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                        return fn.apply(isBind ? thisArg : this, args);
                    }
                    return wrapper;
                }
                function createRound(methodName) {
                    var func = Math[methodName];
                    return function(number, precision) {
                        precision = precision === undefined ? 0 : +precision || 0;
                        if (precision) {
                            precision = pow(10, precision);
                            return func(number * precision) / precision;
                        }
                        return func(number);
                    };
                }
                function createSortedIndex(retHighest) {
                    return function(array, value, iteratee, thisArg) {
                        var callback = getCallback(iteratee);
                        return null == iteratee && callback === baseCallback ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
                    };
                }
                function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                    var isBindKey = bitmask & BIND_KEY_FLAG;
                    if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    var length = partials ? partials.length : 0;
                    if (!length) {
                        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                        partials = holders = undefined;
                    }
                    length -= holders ? holders.length : 0;
                    if (bitmask & PARTIAL_RIGHT_FLAG) {
                        var partialsRight = partials, holdersRight = holders;
                        partials = holders = undefined;
                    }
                    var data = isBindKey ? undefined : getData(func), newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
                    if (data) {
                        mergeData(newData, data);
                        bitmask = newData[1];
                        arity = newData[9];
                    }
                    newData[9] = null == arity ? isBindKey ? 0 : func.length : nativeMax(arity - length, 0) || 0;
                    if (bitmask == BIND_FLAG) var result = createBindWrapper(newData[0], newData[2]); else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) result = createPartialWrapper.apply(undefined, newData); else result = createHybridWrapper.apply(undefined, newData);
                    var setter = data ? baseSetData : setData;
                    return setter(result, newData);
                }
                function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                    var index = -1, arrLength = array.length, othLength = other.length;
                    if (arrLength != othLength && !(isLoose && othLength > arrLength)) return false;
                    while (++index < arrLength) {
                        var arrValue = array[index], othValue = other[index], result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
                        if (result !== undefined) {
                            if (result) continue;
                            return false;
                        }
                        if (isLoose) {
                            if (!arraySome(other, function(othValue) {
                                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                            })) return false;
                        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) return false;
                    }
                    return true;
                }
                function equalByTag(object, other, tag) {
                    switch (tag) {
                      case boolTag:
                      case dateTag:
                        return +object == +other;

                      case errorTag:
                        return object.name == other.name && object.message == other.message;

                      case numberTag:
                        return object != +object ? other != +other : object == +other;

                      case regexpTag:
                      case stringTag:
                        return object == other + "";
                    }
                    return false;
                }
                function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                    var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
                    if (objLength != othLength && !isLoose) return false;
                    var index = objLength;
                    while (index--) {
                        var key = objProps[index];
                        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) return false;
                    }
                    var skipCtor = isLoose;
                    while (++index < objLength) {
                        key = objProps[index];
                        var objValue = object[key], othValue = other[key], result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;
                        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) return false;
                        skipCtor || (skipCtor = "constructor" == key);
                    }
                    if (!skipCtor) {
                        var objCtor = object.constructor, othCtor = other.constructor;
                        if (objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor)) return false;
                    }
                    return true;
                }
                function getCallback(func, thisArg, argCount) {
                    var result = lodash.callback || callback;
                    result = result === callback ? baseCallback : result;
                    return argCount ? result(func, thisArg, argCount) : result;
                }
                var getData = !metaMap ? noop : function(func) {
                    return metaMap.get(func);
                };
                function getFuncName(func) {
                    var result = func.name, array = realNames[result], length = array ? array.length : 0;
                    while (length--) {
                        var data = array[length], otherFunc = data.func;
                        if (null == otherFunc || otherFunc == func) return data.name;
                    }
                    return result;
                }
                function getIndexOf(collection, target, fromIndex) {
                    var result = lodash.indexOf || indexOf;
                    result = result === indexOf ? baseIndexOf : result;
                    return collection ? result(collection, target, fromIndex) : result;
                }
                var getLength = baseProperty("length");
                function getMatchData(object) {
                    var result = pairs(object), length = result.length;
                    while (length--) result[length][2] = isStrictComparable(result[length][1]);
                    return result;
                }
                function getNative(object, key) {
                    var value = null == object ? undefined : object[key];
                    return isNative(value) ? value : undefined;
                }
                function getView(start, end, transforms) {
                    var index = -1, length = transforms.length;
                    while (++index < length) {
                        var data = transforms[index], size = data.size;
                        switch (data.type) {
                          case "drop":
                            start += size;
                            break;

                          case "dropRight":
                            end -= size;
                            break;

                          case "take":
                            end = nativeMin(end, start + size);
                            break;

                          case "takeRight":
                            start = nativeMax(start, end - size);
                        }
                    }
                    return {
                        start: start,
                        end: end
                    };
                }
                function initCloneArray(array) {
                    var length = array.length, result = new array.constructor(length);
                    if (length && "string" == typeof array[0] && hasOwnProperty.call(array, "index")) {
                        result.index = array.index;
                        result.input = array.input;
                    }
                    return result;
                }
                function initCloneObject(object) {
                    var Ctor = object.constructor;
                    if (!("function" == typeof Ctor && Ctor instanceof Ctor)) Ctor = Object;
                    return new Ctor();
                }
                function initCloneByTag(object, tag, isDeep) {
                    var Ctor = object.constructor;
                    switch (tag) {
                      case arrayBufferTag:
                        return bufferClone(object);

                      case boolTag:
                      case dateTag:
                        return new Ctor(+object);

                      case float32Tag:
                      case float64Tag:
                      case int8Tag:
                      case int16Tag:
                      case int32Tag:
                      case uint8Tag:
                      case uint8ClampedTag:
                      case uint16Tag:
                      case uint32Tag:
                        var buffer = object.buffer;
                        return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                      case numberTag:
                      case stringTag:
                        return new Ctor(object);

                      case regexpTag:
                        var result = new Ctor(object.source, reFlags.exec(object));
                        result.lastIndex = object.lastIndex;
                    }
                    return result;
                }
                function invokePath(object, path, args) {
                    if (null != object && !isKey(path, object)) {
                        path = toPath(path);
                        object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1));
                        path = last(path);
                    }
                    var func = null == object ? object : object[path];
                    return null == func ? undefined : func.apply(object, args);
                }
                function isArrayLike(value) {
                    return null != value && isLength(getLength(value));
                }
                function isIndex(value, length) {
                    value = "number" == typeof value || reIsUint.test(value) ? +value : -1;
                    length = null == length ? MAX_SAFE_INTEGER : length;
                    return value > -1 && value % 1 == 0 && value < length;
                }
                function isIterateeCall(value, index, object) {
                    if (!isObject(object)) return false;
                    var type = typeof index;
                    if ("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) {
                        var other = object[index];
                        return value === value ? value === other : other !== other;
                    }
                    return false;
                }
                function isKey(value, object) {
                    var type = typeof value;
                    if ("string" == type && reIsPlainProp.test(value) || "number" == type) return true;
                    if (isArray(value)) return false;
                    var result = !reIsDeepProp.test(value);
                    return result || null != object && value in toObject(object);
                }
                function isLaziable(func) {
                    var funcName = getFuncName(func);
                    if (!(funcName in LazyWrapper.prototype)) return false;
                    var other = lodash[funcName];
                    if (func === other) return true;
                    var data = getData(other);
                    return !!data && func === data[0];
                }
                function isLength(value) {
                    return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }
                function isStrictComparable(value) {
                    return value === value && !isObject(value);
                }
                function mergeData(data, source) {
                    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < ARY_FLAG;
                    var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG;
                    if (!(isCommon || isCombo)) return data;
                    if (srcBitmask & BIND_FLAG) {
                        data[2] = source[2];
                        newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
                    }
                    var value = source[3];
                    if (value) {
                        var partials = data[3];
                        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
                    }
                    value = source[5];
                    if (value) {
                        partials = data[5];
                        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
                    }
                    value = source[7];
                    if (value) data[7] = arrayCopy(value);
                    if (srcBitmask & ARY_FLAG) data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8]);
                    if (null == data[9]) data[9] = source[9];
                    data[0] = source[0];
                    data[1] = newBitmask;
                    return data;
                }
                function mergeDefaults(objectValue, sourceValue) {
                    return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
                }
                function pickByArray(object, props) {
                    object = toObject(object);
                    var index = -1, length = props.length, result = {};
                    while (++index < length) {
                        var key = props[index];
                        if (key in object) result[key] = object[key];
                    }
                    return result;
                }
                function pickByCallback(object, predicate) {
                    var result = {};
                    baseForIn(object, function(value, key, object) {
                        if (predicate(value, key, object)) result[key] = value;
                    });
                    return result;
                }
                function reorder(array, indexes) {
                    var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = arrayCopy(array);
                    while (length--) {
                        var index = indexes[length];
                        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                    }
                    return array;
                }
                var setData = function() {
                    var count = 0, lastCalled = 0;
                    return function(key, value) {
                        var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                        lastCalled = stamp;
                        if (remaining > 0) {
                            if (++count >= HOT_COUNT) return key;
                        } else count = 0;
                        return baseSetData(key, value);
                    };
                }();
                function shimKeys(object) {
                    var props = keysIn(object), propsLength = props.length, length = propsLength && object.length;
                    var allowIndexes = !!length && isLength(length) && (isArray(object) || isArguments(object));
                    var index = -1, result = [];
                    while (++index < propsLength) {
                        var key = props[index];
                        if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) result.push(key);
                    }
                    return result;
                }
                function toIterable(value) {
                    if (null == value) return [];
                    if (!isArrayLike(value)) return values(value);
                    return isObject(value) ? value : Object(value);
                }
                function toObject(value) {
                    return isObject(value) ? value : Object(value);
                }
                function toPath(value) {
                    if (isArray(value)) return value;
                    var result = [];
                    baseToString(value).replace(rePropName, function(match, number, quote, string) {
                        result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
                    });
                    return result;
                }
                function wrapperClone(wrapper) {
                    return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
                }
                function chunk(array, size, guard) {
                    if (guard ? isIterateeCall(array, size, guard) : null == size) size = 1; else size = nativeMax(nativeFloor(size) || 1, 1);
                    var index = 0, length = array ? array.length : 0, resIndex = -1, result = Array(nativeCeil(length / size));
                    while (index < length) result[++resIndex] = baseSlice(array, index, index += size);
                    return result;
                }
                function compact(array) {
                    var index = -1, length = array ? array.length : 0, resIndex = -1, result = [];
                    while (++index < length) {
                        var value = array[index];
                        if (value) result[++resIndex] = value;
                    }
                    return result;
                }
                var difference = restParam(function(array, values) {
                    return isObjectLike(array) && isArrayLike(array) ? baseDifference(array, baseFlatten(values, false, true)) : [];
                });
                function drop(array, n, guard) {
                    var length = array ? array.length : 0;
                    if (!length) return [];
                    if (guard ? isIterateeCall(array, n, guard) : null == n) n = 1;
                    return baseSlice(array, n < 0 ? 0 : n);
                }
                function dropRight(array, n, guard) {
                    var length = array ? array.length : 0;
                    if (!length) return [];
                    if (guard ? isIterateeCall(array, n, guard) : null == n) n = 1;
                    n = length - (+n || 0);
                    return baseSlice(array, 0, n < 0 ? 0 : n);
                }
                function dropRightWhile(array, predicate, thisArg) {
                    return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
                }
                function dropWhile(array, predicate, thisArg) {
                    return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
                }
                function fill(array, value, start, end) {
                    var length = array ? array.length : 0;
                    if (!length) return [];
                    if (start && "number" != typeof start && isIterateeCall(array, value, start)) {
                        start = 0;
                        end = length;
                    }
                    return baseFill(array, value, start, end);
                }
                var findIndex = createFindIndex();
                var findLastIndex = createFindIndex(true);
                function first(array) {
                    return array ? array[0] : undefined;
                }
                function flatten(array, isDeep, guard) {
                    var length = array ? array.length : 0;
                    if (guard && isIterateeCall(array, isDeep, guard)) isDeep = false;
                    return length ? baseFlatten(array, isDeep) : [];
                }
                function flattenDeep(array) {
                    var length = array ? array.length : 0;
                    return length ? baseFlatten(array, true) : [];
                }
                function indexOf(array, value, fromIndex) {
                    var length = array ? array.length : 0;
                    if (!length) return -1;
                    if ("number" == typeof fromIndex) fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex; else if (fromIndex) {
                        var index = binaryIndex(array, value);
                        if (index < length && (value === value ? value === array[index] : array[index] !== array[index])) return index;
                        return -1;
                    }
                    return baseIndexOf(array, value, fromIndex || 0);
                }
                function initial(array) {
                    return dropRight(array, 1);
                }
                var intersection = restParam(function(arrays) {
                    var othLength = arrays.length, othIndex = othLength, caches = Array(length), indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, result = [];
                    while (othIndex--) {
                        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
                        caches[othIndex] = isCommon && value.length >= 120 ? createCache(othIndex && value) : null;
                    }
                    var array = arrays[0], index = -1, length = array ? array.length : 0, seen = caches[0];
                    outer: while (++index < length) {
                        value = array[index];
                        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                            var othIndex = othLength;
                            while (--othIndex) {
                                var cache = caches[othIndex];
                                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) continue outer;
                            }
                            if (seen) seen.push(value);
                            result.push(value);
                        }
                    }
                    return result;
                });
                function last(array) {
                    var length = array ? array.length : 0;
                    return length ? array[length - 1] : undefined;
                }
                function lastIndexOf(array, value, fromIndex) {
                    var length = array ? array.length : 0;
                    if (!length) return -1;
                    var index = length;
                    if ("number" == typeof fromIndex) index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1; else if (fromIndex) {
                        index = binaryIndex(array, value, true) - 1;
                        var other = array[index];
                        if (value === value ? value === other : other !== other) return index;
                        return -1;
                    }
                    if (value !== value) return indexOfNaN(array, index, true);
                    while (index--) if (array[index] === value) return index;
                    return -1;
                }
                function pull() {
                    var args = arguments, array = args[0];
                    if (!(array && array.length)) return array;
                    var index = 0, indexOf = getIndexOf(), length = args.length;
                    while (++index < length) {
                        var fromIndex = 0, value = args[index];
                        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) splice.call(array, fromIndex, 1);
                    }
                    return array;
                }
                var pullAt = restParam(function(array, indexes) {
                    indexes = baseFlatten(indexes);
                    var result = baseAt(array, indexes);
                    basePullAt(array, indexes.sort(baseCompareAscending));
                    return result;
                });
                function remove(array, predicate, thisArg) {
                    var result = [];
                    if (!(array && array.length)) return result;
                    var index = -1, indexes = [], length = array.length;
                    predicate = getCallback(predicate, thisArg, 3);
                    while (++index < length) {
                        var value = array[index];
                        if (predicate(value, index, array)) {
                            result.push(value);
                            indexes.push(index);
                        }
                    }
                    basePullAt(array, indexes);
                    return result;
                }
                function rest(array) {
                    return drop(array, 1);
                }
                function slice(array, start, end) {
                    var length = array ? array.length : 0;
                    if (!length) return [];
                    if (end && "number" != typeof end && isIterateeCall(array, start, end)) {
                        start = 0;
                        end = length;
                    }
                    return baseSlice(array, start, end);
                }
                var sortedIndex = createSortedIndex();
                var sortedLastIndex = createSortedIndex(true);
                function take(array, n, guard) {
                    var length = array ? array.length : 0;
                    if (!length) return [];
                    if (guard ? isIterateeCall(array, n, guard) : null == n) n = 1;
                    return baseSlice(array, 0, n < 0 ? 0 : n);
                }
                function takeRight(array, n, guard) {
                    var length = array ? array.length : 0;
                    if (!length) return [];
                    if (guard ? isIterateeCall(array, n, guard) : null == n) n = 1;
                    n = length - (+n || 0);
                    return baseSlice(array, n < 0 ? 0 : n);
                }
                function takeRightWhile(array, predicate, thisArg) {
                    return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
                }
                function takeWhile(array, predicate, thisArg) {
                    return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
                }
                var union = restParam(function(arrays) {
                    return baseUniq(baseFlatten(arrays, false, true));
                });
                function uniq(array, isSorted, iteratee, thisArg) {
                    var length = array ? array.length : 0;
                    if (!length) return [];
                    if (null != isSorted && "boolean" != typeof isSorted) {
                        thisArg = iteratee;
                        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
                        isSorted = false;
                    }
                    var callback = getCallback();
                    if (!(null == iteratee && callback === baseCallback)) iteratee = callback(iteratee, thisArg, 3);
                    return isSorted && getIndexOf() == baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
                }
                function unzip(array) {
                    if (!(array && array.length)) return [];
                    var index = -1, length = 0;
                    array = arrayFilter(array, function(group) {
                        if (isArrayLike(group)) {
                            length = nativeMax(group.length, length);
                            return true;
                        }
                    });
                    var result = Array(length);
                    while (++index < length) result[index] = arrayMap(array, baseProperty(index));
                    return result;
                }
                function unzipWith(array, iteratee, thisArg) {
                    var length = array ? array.length : 0;
                    if (!length) return [];
                    var result = unzip(array);
                    if (null == iteratee) return result;
                    iteratee = bindCallback(iteratee, thisArg, 4);
                    return arrayMap(result, function(group) {
                        return arrayReduce(group, iteratee, undefined, true);
                    });
                }
                var without = restParam(function(array, values) {
                    return isArrayLike(array) ? baseDifference(array, values) : [];
                });
                function xor() {
                    var index = -1, length = arguments.length;
                    while (++index < length) {
                        var array = arguments[index];
                        if (isArrayLike(array)) var result = result ? arrayPush(baseDifference(result, array), baseDifference(array, result)) : array;
                    }
                    return result ? baseUniq(result) : [];
                }
                var zip = restParam(unzip);
                function zipObject(props, values) {
                    var index = -1, length = props ? props.length : 0, result = {};
                    if (length && !values && !isArray(props[0])) values = [];
                    while (++index < length) {
                        var key = props[index];
                        if (values) result[key] = values[index]; else if (key) result[key[0]] = key[1];
                    }
                    return result;
                }
                var zipWith = restParam(function(arrays) {
                    var length = arrays.length, iteratee = length > 2 ? arrays[length - 2] : undefined, thisArg = length > 1 ? arrays[length - 1] : undefined;
                    if (length > 2 && "function" == typeof iteratee) length -= 2; else {
                        iteratee = length > 1 && "function" == typeof thisArg ? (--length, thisArg) : undefined;
                        thisArg = undefined;
                    }
                    arrays.length = length;
                    return unzipWith(arrays, iteratee, thisArg);
                });
                function chain(value) {
                    var result = lodash(value);
                    result.__chain__ = true;
                    return result;
                }
                function tap(value, interceptor, thisArg) {
                    interceptor.call(thisArg, value);
                    return value;
                }
                function thru(value, interceptor, thisArg) {
                    return interceptor.call(thisArg, value);
                }
                function wrapperChain() {
                    return chain(this);
                }
                function wrapperCommit() {
                    return new LodashWrapper(this.value(), this.__chain__);
                }
                var wrapperConcat = restParam(function(values) {
                    values = baseFlatten(values);
                    return this.thru(function(array) {
                        return arrayConcat(isArray(array) ? array : [ toObject(array) ], values);
                    });
                });
                function wrapperPlant(value) {
                    var result, parent = this;
                    while (parent instanceof baseLodash) {
                        var clone = wrapperClone(parent);
                        if (result) previous.__wrapped__ = clone; else result = clone;
                        var previous = clone;
                        parent = parent.__wrapped__;
                    }
                    previous.__wrapped__ = value;
                    return result;
                }
                function wrapperReverse() {
                    var value = this.__wrapped__;
                    var interceptor = function(value) {
                        return wrapped && wrapped.__dir__ < 0 ? value : value.reverse();
                    };
                    if (value instanceof LazyWrapper) {
                        var wrapped = value;
                        if (this.__actions__.length) wrapped = new LazyWrapper(this);
                        wrapped = wrapped.reverse();
                        wrapped.__actions__.push({
                            func: thru,
                            args: [ interceptor ],
                            thisArg: undefined
                        });
                        return new LodashWrapper(wrapped, this.__chain__);
                    }
                    return this.thru(interceptor);
                }
                function wrapperToString() {
                    return this.value() + "";
                }
                function wrapperValue() {
                    return baseWrapperValue(this.__wrapped__, this.__actions__);
                }
                var at = restParam(function(collection, props) {
                    return baseAt(collection, baseFlatten(props));
                });
                var countBy = createAggregator(function(result, value, key) {
                    hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
                });
                function every(collection, predicate, thisArg) {
                    var func = isArray(collection) ? arrayEvery : baseEvery;
                    if (thisArg && isIterateeCall(collection, predicate, thisArg)) predicate = undefined;
                    if ("function" != typeof predicate || thisArg !== undefined) predicate = getCallback(predicate, thisArg, 3);
                    return func(collection, predicate);
                }
                function filter(collection, predicate, thisArg) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    predicate = getCallback(predicate, thisArg, 3);
                    return func(collection, predicate);
                }
                var find = createFind(baseEach);
                var findLast = createFind(baseEachRight, true);
                function findWhere(collection, source) {
                    return find(collection, baseMatches(source));
                }
                var forEach = createForEach(arrayEach, baseEach);
                var forEachRight = createForEach(arrayEachRight, baseEachRight);
                var groupBy = createAggregator(function(result, value, key) {
                    if (hasOwnProperty.call(result, key)) result[key].push(value); else result[key] = [ value ];
                });
                function includes(collection, target, fromIndex, guard) {
                    var length = collection ? getLength(collection) : 0;
                    if (!isLength(length)) {
                        collection = values(collection);
                        length = collection.length;
                    }
                    if ("number" != typeof fromIndex || guard && isIterateeCall(target, fromIndex, guard)) fromIndex = 0; else fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
                    return "string" == typeof collection || !isArray(collection) && isString(collection) ? fromIndex <= length && collection.indexOf(target, fromIndex) > -1 : !!length && getIndexOf(collection, target, fromIndex) > -1;
                }
                var indexBy = createAggregator(function(result, value, key) {
                    result[key] = value;
                });
                var invoke = restParam(function(collection, path, args) {
                    var index = -1, isFunc = "function" == typeof path, isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
                    baseEach(collection, function(value) {
                        var func = isFunc ? path : isProp && null != value ? value[path] : undefined;
                        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
                    });
                    return result;
                });
                function map(collection, iteratee, thisArg) {
                    var func = isArray(collection) ? arrayMap : baseMap;
                    iteratee = getCallback(iteratee, thisArg, 3);
                    return func(collection, iteratee);
                }
                var partition = createAggregator(function(result, value, key) {
                    result[key ? 0 : 1].push(value);
                }, function() {
                    return [ [], [] ];
                });
                function pluck(collection, path) {
                    return map(collection, property(path));
                }
                var reduce = createReduce(arrayReduce, baseEach);
                var reduceRight = createReduce(arrayReduceRight, baseEachRight);
                function reject(collection, predicate, thisArg) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    predicate = getCallback(predicate, thisArg, 3);
                    return func(collection, function(value, index, collection) {
                        return !predicate(value, index, collection);
                    });
                }
                function sample(collection, n, guard) {
                    if (guard ? isIterateeCall(collection, n, guard) : null == n) {
                        collection = toIterable(collection);
                        var length = collection.length;
                        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
                    }
                    var index = -1, result = toArray(collection), length = result.length, lastIndex = length - 1;
                    n = nativeMin(n < 0 ? 0 : +n || 0, length);
                    while (++index < n) {
                        var rand = baseRandom(index, lastIndex), value = result[rand];
                        result[rand] = result[index];
                        result[index] = value;
                    }
                    result.length = n;
                    return result;
                }
                function shuffle(collection) {
                    return sample(collection, POSITIVE_INFINITY);
                }
                function size(collection) {
                    var length = collection ? getLength(collection) : 0;
                    return isLength(length) ? length : keys(collection).length;
                }
                function some(collection, predicate, thisArg) {
                    var func = isArray(collection) ? arraySome : baseSome;
                    if (thisArg && isIterateeCall(collection, predicate, thisArg)) predicate = undefined;
                    if ("function" != typeof predicate || thisArg !== undefined) predicate = getCallback(predicate, thisArg, 3);
                    return func(collection, predicate);
                }
                function sortBy(collection, iteratee, thisArg) {
                    if (null == collection) return [];
                    if (thisArg && isIterateeCall(collection, iteratee, thisArg)) iteratee = undefined;
                    var index = -1;
                    iteratee = getCallback(iteratee, thisArg, 3);
                    var result = baseMap(collection, function(value, key, collection) {
                        return {
                            criteria: iteratee(value, key, collection),
                            index: ++index,
                            value: value
                        };
                    });
                    return baseSortBy(result, compareAscending);
                }
                var sortByAll = restParam(function(collection, iteratees) {
                    if (null == collection) return [];
                    var guard = iteratees[2];
                    if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) iteratees.length = 1;
                    return baseSortByOrder(collection, baseFlatten(iteratees), []);
                });
                function sortByOrder(collection, iteratees, orders, guard) {
                    if (null == collection) return [];
                    if (guard && isIterateeCall(iteratees, orders, guard)) orders = undefined;
                    if (!isArray(iteratees)) iteratees = null == iteratees ? [] : [ iteratees ];
                    if (!isArray(orders)) orders = null == orders ? [] : [ orders ];
                    return baseSortByOrder(collection, iteratees, orders);
                }
                function where(collection, source) {
                    return filter(collection, baseMatches(source));
                }
                var now = nativeNow || function() {
                    return new Date().getTime();
                };
                function after(n, func) {
                    if ("function" != typeof func) if ("function" == typeof n) {
                        var temp = n;
                        n = func;
                        func = temp;
                    } else throw new TypeError(FUNC_ERROR_TEXT);
                    n = nativeIsFinite(n = +n) ? n : 0;
                    return function() {
                        if (--n < 1) return func.apply(this, arguments);
                    };
                }
                function ary(func, n, guard) {
                    if (guard && isIterateeCall(func, n, guard)) n = undefined;
                    n = func && null == n ? func.length : nativeMax(+n || 0, 0);
                    return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
                }
                function before(n, func) {
                    var result;
                    if ("function" != typeof func) if ("function" == typeof n) {
                        var temp = n;
                        n = func;
                        func = temp;
                    } else throw new TypeError(FUNC_ERROR_TEXT);
                    return function() {
                        if (--n > 0) result = func.apply(this, arguments);
                        if (n <= 1) func = undefined;
                        return result;
                    };
                }
                var bind = restParam(function(func, thisArg, partials) {
                    var bitmask = BIND_FLAG;
                    if (partials.length) {
                        var holders = replaceHolders(partials, bind.placeholder);
                        bitmask |= PARTIAL_FLAG;
                    }
                    return createWrapper(func, bitmask, thisArg, partials, holders);
                });
                var bindAll = restParam(function(object, methodNames) {
                    methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
                    var index = -1, length = methodNames.length;
                    while (++index < length) {
                        var key = methodNames[index];
                        object[key] = createWrapper(object[key], BIND_FLAG, object);
                    }
                    return object;
                });
                var bindKey = restParam(function(object, key, partials) {
                    var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                    if (partials.length) {
                        var holders = replaceHolders(partials, bindKey.placeholder);
                        bitmask |= PARTIAL_FLAG;
                    }
                    return createWrapper(key, bitmask, object, partials, holders);
                });
                var curry = createCurry(CURRY_FLAG);
                var curryRight = createCurry(CURRY_RIGHT_FLAG);
                function debounce(func, wait, options) {
                    var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    wait = wait < 0 ? 0 : +wait || 0;
                    if (true === options) {
                        var leading = true;
                        trailing = false;
                    } else if (isObject(options)) {
                        leading = !!options.leading;
                        maxWait = "maxWait" in options && nativeMax(+options.maxWait || 0, wait);
                        trailing = "trailing" in options ? !!options.trailing : trailing;
                    }
                    function cancel() {
                        if (timeoutId) clearTimeout(timeoutId);
                        if (maxTimeoutId) clearTimeout(maxTimeoutId);
                        lastCalled = 0;
                        maxTimeoutId = timeoutId = trailingCall = undefined;
                    }
                    function complete(isCalled, id) {
                        if (id) clearTimeout(id);
                        maxTimeoutId = timeoutId = trailingCall = undefined;
                        if (isCalled) {
                            lastCalled = now();
                            result = func.apply(thisArg, args);
                            if (!timeoutId && !maxTimeoutId) args = thisArg = undefined;
                        }
                    }
                    function delayed() {
                        var remaining = wait - (now() - stamp);
                        if (remaining <= 0 || remaining > wait) complete(trailingCall, maxTimeoutId); else timeoutId = setTimeout(delayed, remaining);
                    }
                    function maxDelayed() {
                        complete(trailing, timeoutId);
                    }
                    function debounced() {
                        args = arguments;
                        stamp = now();
                        thisArg = this;
                        trailingCall = trailing && (timeoutId || !leading);
                        if (false === maxWait) var leadingCall = leading && !timeoutId; else {
                            if (!maxTimeoutId && !leading) lastCalled = stamp;
                            var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0 || remaining > maxWait;
                            if (isCalled) {
                                if (maxTimeoutId) maxTimeoutId = clearTimeout(maxTimeoutId);
                                lastCalled = stamp;
                                result = func.apply(thisArg, args);
                            } else if (!maxTimeoutId) maxTimeoutId = setTimeout(maxDelayed, remaining);
                        }
                        if (isCalled && timeoutId) timeoutId = clearTimeout(timeoutId); else if (!timeoutId && wait !== maxWait) timeoutId = setTimeout(delayed, wait);
                        if (leadingCall) {
                            isCalled = true;
                            result = func.apply(thisArg, args);
                        }
                        if (isCalled && !timeoutId && !maxTimeoutId) args = thisArg = undefined;
                        return result;
                    }
                    debounced.cancel = cancel;
                    return debounced;
                }
                var defer = restParam(function(func, args) {
                    return baseDelay(func, 1, args);
                });
                var delay = restParam(function(func, wait, args) {
                    return baseDelay(func, wait, args);
                });
                var flow = createFlow();
                var flowRight = createFlow(true);
                function memoize(func, resolver) {
                    if ("function" != typeof func || resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT);
                    var memoized = function() {
                        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                        if (cache.has(key)) return cache.get(key);
                        var result = func.apply(this, args);
                        memoized.cache = cache.set(key, result);
                        return result;
                    };
                    memoized.cache = new memoize.Cache();
                    return memoized;
                }
                var modArgs = restParam(function(func, transforms) {
                    transforms = baseFlatten(transforms);
                    if ("function" != typeof func || !arrayEvery(transforms, baseIsFunction)) throw new TypeError(FUNC_ERROR_TEXT);
                    var length = transforms.length;
                    return restParam(function(args) {
                        var index = nativeMin(args.length, length);
                        while (index--) args[index] = transforms[index](args[index]);
                        return func.apply(this, args);
                    });
                });
                function negate(predicate) {
                    if ("function" != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT);
                    return function() {
                        return !predicate.apply(this, arguments);
                    };
                }
                function once(func) {
                    return before(2, func);
                }
                var partial = createPartial(PARTIAL_FLAG);
                var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
                var rearg = restParam(function(func, indexes) {
                    return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
                });
                function restParam(func, start) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    start = nativeMax(start === undefined ? func.length - 1 : +start || 0, 0);
                    return function() {
                        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), rest = Array(length);
                        while (++index < length) rest[index] = args[start + index];
                        switch (start) {
                          case 0:
                            return func.call(this, rest);

                          case 1:
                            return func.call(this, args[0], rest);

                          case 2:
                            return func.call(this, args[0], args[1], rest);
                        }
                        var otherArgs = Array(start + 1);
                        index = -1;
                        while (++index < start) otherArgs[index] = args[index];
                        otherArgs[start] = rest;
                        return func.apply(this, otherArgs);
                    };
                }
                function spread(func) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return function(array) {
                        return func.apply(this, array);
                    };
                }
                function throttle(func, wait, options) {
                    var leading = true, trailing = true;
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    if (false === options) leading = false; else if (isObject(options)) {
                        leading = "leading" in options ? !!options.leading : leading;
                        trailing = "trailing" in options ? !!options.trailing : trailing;
                    }
                    return debounce(func, wait, {
                        leading: leading,
                        maxWait: +wait,
                        trailing: trailing
                    });
                }
                function wrap(value, wrapper) {
                    wrapper = null == wrapper ? identity : wrapper;
                    return createWrapper(wrapper, PARTIAL_FLAG, undefined, [ value ], []);
                }
                function clone(value, isDeep, customizer, thisArg) {
                    if (isDeep && "boolean" != typeof isDeep && isIterateeCall(value, isDeep, customizer)) isDeep = false; else if ("function" == typeof isDeep) {
                        thisArg = customizer;
                        customizer = isDeep;
                        isDeep = false;
                    }
                    return "function" == typeof customizer ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1)) : baseClone(value, isDeep);
                }
                function cloneDeep(value, customizer, thisArg) {
                    return "function" == typeof customizer ? baseClone(value, true, bindCallback(customizer, thisArg, 1)) : baseClone(value, true);
                }
                function gt(value, other) {
                    return value > other;
                }
                function gte(value, other) {
                    return value >= other;
                }
                function isArguments(value) {
                    return isObjectLike(value) && isArrayLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                }
                var isArray = nativeIsArray || function(value) {
                    return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
                };
                function isBoolean(value) {
                    return true === value || false === value || isObjectLike(value) && objToString.call(value) == boolTag;
                }
                function isDate(value) {
                    return isObjectLike(value) && objToString.call(value) == dateTag;
                }
                function isElement(value) {
                    return !!value && 1 === value.nodeType && isObjectLike(value) && !isPlainObject(value);
                }
                function isEmpty(value) {
                    if (null == value) return true;
                    if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice))) return !value.length;
                    return !keys(value).length;
                }
                function isEqual(value, other, customizer, thisArg) {
                    customizer = "function" == typeof customizer ? bindCallback(customizer, thisArg, 3) : undefined;
                    var result = customizer ? customizer(value, other) : undefined;
                    return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
                }
                function isError(value) {
                    return isObjectLike(value) && "string" == typeof value.message && objToString.call(value) == errorTag;
                }
                function isFinite(value) {
                    return "number" == typeof value && nativeIsFinite(value);
                }
                function isFunction(value) {
                    return isObject(value) && objToString.call(value) == funcTag;
                }
                function isObject(value) {
                    var type = typeof value;
                    return !!value && ("object" == type || "function" == type);
                }
                function isMatch(object, source, customizer, thisArg) {
                    customizer = "function" == typeof customizer ? bindCallback(customizer, thisArg, 3) : undefined;
                    return baseIsMatch(object, getMatchData(source), customizer);
                }
                function isNaN(value) {
                    return isNumber(value) && value != +value;
                }
                function isNative(value) {
                    if (null == value) return false;
                    if (isFunction(value)) return reIsNative.test(fnToString.call(value));
                    return isObjectLike(value) && reIsHostCtor.test(value);
                }
                function isNull(value) {
                    return null === value;
                }
                function isNumber(value) {
                    return "number" == typeof value || isObjectLike(value) && objToString.call(value) == numberTag;
                }
                function isPlainObject(value) {
                    var Ctor;
                    if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) || !hasOwnProperty.call(value, "constructor") && (Ctor = value.constructor, 
                    "function" == typeof Ctor && !(Ctor instanceof Ctor))) return false;
                    var result;
                    baseForIn(value, function(subValue, key) {
                        result = key;
                    });
                    return result === undefined || hasOwnProperty.call(value, result);
                }
                function isRegExp(value) {
                    return isObject(value) && objToString.call(value) == regexpTag;
                }
                function isString(value) {
                    return "string" == typeof value || isObjectLike(value) && objToString.call(value) == stringTag;
                }
                function isTypedArray(value) {
                    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
                }
                function isUndefined(value) {
                    return value === undefined;
                }
                function lt(value, other) {
                    return value < other;
                }
                function lte(value, other) {
                    return value <= other;
                }
                function toArray(value) {
                    var length = value ? getLength(value) : 0;
                    if (!isLength(length)) return values(value);
                    if (!length) return [];
                    return arrayCopy(value);
                }
                function toPlainObject(value) {
                    return baseCopy(value, keysIn(value));
                }
                var merge = createAssigner(baseMerge);
                var assign = createAssigner(function(object, source, customizer) {
                    return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
                });
                function create(prototype, properties, guard) {
                    var result = baseCreate(prototype);
                    if (guard && isIterateeCall(prototype, properties, guard)) properties = undefined;
                    return properties ? baseAssign(result, properties) : result;
                }
                var defaults = createDefaults(assign, assignDefaults);
                var defaultsDeep = createDefaults(merge, mergeDefaults);
                var findKey = createFindKey(baseForOwn);
                var findLastKey = createFindKey(baseForOwnRight);
                var forIn = createForIn(baseFor);
                var forInRight = createForIn(baseForRight);
                var forOwn = createForOwn(baseForOwn);
                var forOwnRight = createForOwn(baseForOwnRight);
                function functions(object) {
                    return baseFunctions(object, keysIn(object));
                }
                function get(object, path, defaultValue) {
                    var result = null == object ? undefined : baseGet(object, toPath(path), path + "");
                    return result === undefined ? defaultValue : result;
                }
                function has(object, path) {
                    if (null == object) return false;
                    var result = hasOwnProperty.call(object, path);
                    if (!result && !isKey(path)) {
                        path = toPath(path);
                        object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1));
                        if (null == object) return false;
                        path = last(path);
                        result = hasOwnProperty.call(object, path);
                    }
                    return result || isLength(object.length) && isIndex(path, object.length) && (isArray(object) || isArguments(object));
                }
                function invert(object, multiValue, guard) {
                    if (guard && isIterateeCall(object, multiValue, guard)) multiValue = undefined;
                    var index = -1, props = keys(object), length = props.length, result = {};
                    while (++index < length) {
                        var key = props[index], value = object[key];
                        if (multiValue) if (hasOwnProperty.call(result, value)) result[value].push(key); else result[value] = [ key ]; else result[value] = key;
                    }
                    return result;
                }
                var keys = !nativeKeys ? shimKeys : function(object) {
                    var Ctor = null == object ? undefined : object.constructor;
                    if ("function" == typeof Ctor && Ctor.prototype === object || "function" != typeof object && isArrayLike(object)) return shimKeys(object);
                    return isObject(object) ? nativeKeys(object) : [];
                };
                function keysIn(object) {
                    if (null == object) return [];
                    if (!isObject(object)) object = Object(object);
                    var length = object.length;
                    length = length && isLength(length) && (isArray(object) || isArguments(object)) && length || 0;
                    var Ctor = object.constructor, index = -1, isProto = "function" == typeof Ctor && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0;
                    while (++index < length) result[index] = index + "";
                    for (var key in object) if (!(skipIndexes && isIndex(key, length)) && !("constructor" == key && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
                    return result;
                }
                var mapKeys = createObjectMapper(true);
                var mapValues = createObjectMapper();
                var omit = restParam(function(object, props) {
                    if (null == object) return {};
                    if ("function" != typeof props[0]) {
                        var props = arrayMap(baseFlatten(props), String);
                        return pickByArray(object, baseDifference(keysIn(object), props));
                    }
                    var predicate = bindCallback(props[0], props[1], 3);
                    return pickByCallback(object, function(value, key, object) {
                        return !predicate(value, key, object);
                    });
                });
                function pairs(object) {
                    object = toObject(object);
                    var index = -1, props = keys(object), length = props.length, result = Array(length);
                    while (++index < length) {
                        var key = props[index];
                        result[index] = [ key, object[key] ];
                    }
                    return result;
                }
                var pick = restParam(function(object, props) {
                    if (null == object) return {};
                    return "function" == typeof props[0] ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
                });
                function result(object, path, defaultValue) {
                    var result = null == object ? undefined : object[path];
                    if (result === undefined) {
                        if (null != object && !isKey(path, object)) {
                            path = toPath(path);
                            object = 1 == path.length ? object : baseGet(object, baseSlice(path, 0, -1));
                            result = null == object ? undefined : object[last(path)];
                        }
                        result = result === undefined ? defaultValue : result;
                    }
                    return isFunction(result) ? result.call(object) : result;
                }
                function set(object, path, value) {
                    if (null == object) return object;
                    var pathKey = path + "";
                    path = null != object[pathKey] || isKey(path, object) ? [ pathKey ] : toPath(path);
                    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                    while (null != nested && ++index < length) {
                        var key = path[index];
                        if (isObject(nested)) if (index == lastIndex) nested[key] = value; else if (null == nested[key]) nested[key] = isIndex(path[index + 1]) ? [] : {};
                        nested = nested[key];
                    }
                    return object;
                }
                function transform(object, iteratee, accumulator, thisArg) {
                    var isArr = isArray(object) || isTypedArray(object);
                    iteratee = getCallback(iteratee, thisArg, 4);
                    if (null == accumulator) if (isArr || isObject(object)) {
                        var Ctor = object.constructor;
                        if (isArr) accumulator = isArray(object) ? new Ctor() : []; else accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
                    } else accumulator = {};
                    (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
                        return iteratee(accumulator, value, index, object);
                    });
                    return accumulator;
                }
                function values(object) {
                    return baseValues(object, keys(object));
                }
                function valuesIn(object) {
                    return baseValues(object, keysIn(object));
                }
                function inRange(value, start, end) {
                    start = +start || 0;
                    if (end === undefined) {
                        end = start;
                        start = 0;
                    } else end = +end || 0;
                    return value >= nativeMin(start, end) && value < nativeMax(start, end);
                }
                function random(min, max, floating) {
                    if (floating && isIterateeCall(min, max, floating)) max = floating = undefined;
                    var noMin = null == min, noMax = null == max;
                    if (null == floating) if (noMax && "boolean" == typeof min) {
                        floating = min;
                        min = 1;
                    } else if ("boolean" == typeof max) {
                        floating = max;
                        noMax = true;
                    }
                    if (noMin && noMax) {
                        max = 1;
                        noMax = false;
                    }
                    min = +min || 0;
                    if (noMax) {
                        max = min;
                        min = 0;
                    } else max = +max || 0;
                    if (floating || min % 1 || max % 1) {
                        var rand = nativeRandom();
                        return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                    }
                    return baseRandom(min, max);
                }
                var camelCase = createCompounder(function(result, word, index) {
                    word = word.toLowerCase();
                    return result + (index ? word.charAt(0).toUpperCase() + word.slice(1) : word);
                });
                function capitalize(string) {
                    string = baseToString(string);
                    return string && string.charAt(0).toUpperCase() + string.slice(1);
                }
                function deburr(string) {
                    string = baseToString(string);
                    return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, "");
                }
                function endsWith(string, target, position) {
                    string = baseToString(string);
                    target += "";
                    var length = string.length;
                    position = position === undefined ? length : nativeMin(position < 0 ? 0 : +position || 0, length);
                    position -= target.length;
                    return position >= 0 && string.indexOf(target, position) == position;
                }
                function escape(string) {
                    string = baseToString(string);
                    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                }
                function escapeRegExp(string) {
                    string = baseToString(string);
                    return string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, escapeRegExpChar) : string || "(?:)";
                }
                var kebabCase = createCompounder(function(result, word, index) {
                    return result + (index ? "-" : "") + word.toLowerCase();
                });
                function pad(string, length, chars) {
                    string = baseToString(string);
                    length = +length;
                    var strLength = string.length;
                    if (strLength >= length || !nativeIsFinite(length)) return string;
                    var mid = (length - strLength) / 2, leftLength = nativeFloor(mid), rightLength = nativeCeil(mid);
                    chars = createPadding("", rightLength, chars);
                    return chars.slice(0, leftLength) + string + chars;
                }
                var padLeft = createPadDir();
                var padRight = createPadDir(true);
                function parseInt(string, radix, guard) {
                    if (guard ? isIterateeCall(string, radix, guard) : null == radix) radix = 0; else if (radix) radix = +radix;
                    string = trim(string);
                    return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
                }
                function repeat(string, n) {
                    var result = "";
                    string = baseToString(string);
                    n = +n;
                    if (n < 1 || !string || !nativeIsFinite(n)) return result;
                    do {
                        if (n % 2) result += string;
                        n = nativeFloor(n / 2);
                        string += string;
                    } while (n);
                    return result;
                }
                var snakeCase = createCompounder(function(result, word, index) {
                    return result + (index ? "_" : "") + word.toLowerCase();
                });
                var startCase = createCompounder(function(result, word, index) {
                    return result + (index ? " " : "") + (word.charAt(0).toUpperCase() + word.slice(1));
                });
                function startsWith(string, target, position) {
                    string = baseToString(string);
                    position = null == position ? 0 : nativeMin(position < 0 ? 0 : +position || 0, string.length);
                    return string.lastIndexOf(target, position) == position;
                }
                function template(string, options, otherOptions) {
                    var settings = lodash.templateSettings;
                    if (otherOptions && isIterateeCall(string, options, otherOptions)) options = otherOptions = undefined;
                    string = baseToString(string);
                    options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
                    var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                    var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                    var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                    var sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                        interpolateValue || (interpolateValue = esTemplateValue);
                        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                        if (escapeValue) {
                            isEscaping = true;
                            source += "' +\n__e(" + escapeValue + ") +\n'";
                        }
                        if (evaluateValue) {
                            isEvaluating = true;
                            source += "';\n" + evaluateValue + ";\n__p += '";
                        }
                        if (interpolateValue) source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                        index = offset + match.length;
                        return match;
                    });
                    source += "';\n";
                    var variable = options.variable;
                    if (!variable) source = "with (obj) {\n" + source + "\n}\n";
                    source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                    source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                    var result = attempt(function() {
                        return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
                    });
                    result.source = source;
                    if (isError(result)) throw result;
                    return result;
                }
                function trim(string, chars, guard) {
                    var value = string;
                    string = baseToString(string);
                    if (!string) return string;
                    if (guard ? isIterateeCall(value, chars, guard) : null == chars) return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
                    chars += "";
                    return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
                }
                function trimLeft(string, chars, guard) {
                    var value = string;
                    string = baseToString(string);
                    if (!string) return string;
                    if (guard ? isIterateeCall(value, chars, guard) : null == chars) return string.slice(trimmedLeftIndex(string));
                    return string.slice(charsLeftIndex(string, chars + ""));
                }
                function trimRight(string, chars, guard) {
                    var value = string;
                    string = baseToString(string);
                    if (!string) return string;
                    if (guard ? isIterateeCall(value, chars, guard) : null == chars) return string.slice(0, trimmedRightIndex(string) + 1);
                    return string.slice(0, charsRightIndex(string, chars + "") + 1);
                }
                function trunc(string, options, guard) {
                    if (guard && isIterateeCall(string, options, guard)) options = undefined;
                    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                    if (null != options) if (isObject(options)) {
                        var separator = "separator" in options ? options.separator : separator;
                        length = "length" in options ? +options.length || 0 : length;
                        omission = "omission" in options ? baseToString(options.omission) : omission;
                    } else length = +options || 0;
                    string = baseToString(string);
                    if (length >= string.length) return string;
                    var end = length - omission.length;
                    if (end < 1) return omission;
                    var result = string.slice(0, end);
                    if (null == separator) return result + omission;
                    if (isRegExp(separator)) {
                        if (string.slice(end).search(separator)) {
                            var match, newEnd, substring = string.slice(0, end);
                            if (!separator.global) separator = RegExp(separator.source, (reFlags.exec(separator) || "") + "g");
                            separator.lastIndex = 0;
                            while (match = separator.exec(substring)) newEnd = match.index;
                            result = result.slice(0, null == newEnd ? end : newEnd);
                        }
                    } else if (string.indexOf(separator, end) != end) {
                        var index = result.lastIndexOf(separator);
                        if (index > -1) result = result.slice(0, index);
                    }
                    return result + omission;
                }
                function unescape(string) {
                    string = baseToString(string);
                    return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                }
                function words(string, pattern, guard) {
                    if (guard && isIterateeCall(string, pattern, guard)) pattern = undefined;
                    string = baseToString(string);
                    return string.match(pattern || reWords) || [];
                }
                var attempt = restParam(function(func, args) {
                    try {
                        return func.apply(undefined, args);
                    } catch (e) {
                        return isError(e) ? e : new Error(e);
                    }
                });
                function callback(func, thisArg, guard) {
                    if (guard && isIterateeCall(func, thisArg, guard)) thisArg = undefined;
                    return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
                }
                function constant(value) {
                    return function() {
                        return value;
                    };
                }
                function identity(value) {
                    return value;
                }
                function matches(source) {
                    return baseMatches(baseClone(source, true));
                }
                function matchesProperty(path, srcValue) {
                    return baseMatchesProperty(path, baseClone(srcValue, true));
                }
                var method = restParam(function(path, args) {
                    return function(object) {
                        return invokePath(object, path, args);
                    };
                });
                var methodOf = restParam(function(object, args) {
                    return function(path) {
                        return invokePath(object, path, args);
                    };
                });
                function mixin(object, source, options) {
                    if (null == options) {
                        var isObj = isObject(source), props = isObj ? keys(source) : undefined, methodNames = props && props.length ? baseFunctions(source, props) : undefined;
                        if (!(methodNames ? methodNames.length : isObj)) {
                            methodNames = false;
                            options = source;
                            source = object;
                            object = this;
                        }
                    }
                    if (!methodNames) methodNames = baseFunctions(source, keys(source));
                    var chain = true, index = -1, isFunc = isFunction(object), length = methodNames.length;
                    if (false === options) chain = false; else if (isObject(options) && "chain" in options) chain = options.chain;
                    while (++index < length) {
                        var methodName = methodNames[index], func = source[methodName];
                        object[methodName] = func;
                        if (isFunc) object.prototype[methodName] = function(func) {
                            return function() {
                                var chainAll = this.__chain__;
                                if (chain || chainAll) {
                                    var result = object(this.__wrapped__), actions = result.__actions__ = arrayCopy(this.__actions__);
                                    actions.push({
                                        func: func,
                                        args: arguments,
                                        thisArg: object
                                    });
                                    result.__chain__ = chainAll;
                                    return result;
                                }
                                return func.apply(object, arrayPush([ this.value() ], arguments));
                            };
                        }(func);
                    }
                    return object;
                }
                function noConflict() {
                    root._ = oldDash;
                    return this;
                }
                function noop() {}
                function property(path) {
                    return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
                }
                function propertyOf(object) {
                    return function(path) {
                        return baseGet(object, toPath(path), path + "");
                    };
                }
                function range(start, end, step) {
                    if (step && isIterateeCall(start, end, step)) end = step = undefined;
                    start = +start || 0;
                    step = null == step ? 1 : +step || 0;
                    if (null == end) {
                        end = start;
                        start = 0;
                    } else end = +end || 0;
                    var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                    while (++index < length) {
                        result[index] = start;
                        start += step;
                    }
                    return result;
                }
                function times(n, iteratee, thisArg) {
                    n = nativeFloor(n);
                    if (n < 1 || !nativeIsFinite(n)) return [];
                    var index = -1, result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
                    iteratee = bindCallback(iteratee, thisArg, 1);
                    while (++index < n) if (index < MAX_ARRAY_LENGTH) result[index] = iteratee(index); else iteratee(index);
                    return result;
                }
                function uniqueId(prefix) {
                    var id = ++idCounter;
                    return baseToString(prefix) + id;
                }
                function add(augend, addend) {
                    return (+augend || 0) + (+addend || 0);
                }
                var ceil = createRound("ceil");
                var floor = createRound("floor");
                var max = createExtremum(gt, NEGATIVE_INFINITY);
                var min = createExtremum(lt, POSITIVE_INFINITY);
                var round = createRound("round");
                function sum(collection, iteratee, thisArg) {
                    if (thisArg && isIterateeCall(collection, iteratee, thisArg)) iteratee = undefined;
                    iteratee = getCallback(iteratee, thisArg, 3);
                    return 1 == iteratee.length ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee);
                }
                lodash.prototype = baseLodash.prototype;
                LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                LodashWrapper.prototype.constructor = LodashWrapper;
                LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                LazyWrapper.prototype.constructor = LazyWrapper;
                MapCache.prototype["delete"] = mapDelete;
                MapCache.prototype.get = mapGet;
                MapCache.prototype.has = mapHas;
                MapCache.prototype.set = mapSet;
                SetCache.prototype.push = cachePush;
                memoize.Cache = MapCache;
                lodash.after = after;
                lodash.ary = ary;
                lodash.assign = assign;
                lodash.at = at;
                lodash.before = before;
                lodash.bind = bind;
                lodash.bindAll = bindAll;
                lodash.bindKey = bindKey;
                lodash.callback = callback;
                lodash.chain = chain;
                lodash.chunk = chunk;
                lodash.compact = compact;
                lodash.constant = constant;
                lodash.countBy = countBy;
                lodash.create = create;
                lodash.curry = curry;
                lodash.curryRight = curryRight;
                lodash.debounce = debounce;
                lodash.defaults = defaults;
                lodash.defaultsDeep = defaultsDeep;
                lodash.defer = defer;
                lodash.delay = delay;
                lodash.difference = difference;
                lodash.drop = drop;
                lodash.dropRight = dropRight;
                lodash.dropRightWhile = dropRightWhile;
                lodash.dropWhile = dropWhile;
                lodash.fill = fill;
                lodash.filter = filter;
                lodash.flatten = flatten;
                lodash.flattenDeep = flattenDeep;
                lodash.flow = flow;
                lodash.flowRight = flowRight;
                lodash.forEach = forEach;
                lodash.forEachRight = forEachRight;
                lodash.forIn = forIn;
                lodash.forInRight = forInRight;
                lodash.forOwn = forOwn;
                lodash.forOwnRight = forOwnRight;
                lodash.functions = functions;
                lodash.groupBy = groupBy;
                lodash.indexBy = indexBy;
                lodash.initial = initial;
                lodash.intersection = intersection;
                lodash.invert = invert;
                lodash.invoke = invoke;
                lodash.keys = keys;
                lodash.keysIn = keysIn;
                lodash.map = map;
                lodash.mapKeys = mapKeys;
                lodash.mapValues = mapValues;
                lodash.matches = matches;
                lodash.matchesProperty = matchesProperty;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.method = method;
                lodash.methodOf = methodOf;
                lodash.mixin = mixin;
                lodash.modArgs = modArgs;
                lodash.negate = negate;
                lodash.omit = omit;
                lodash.once = once;
                lodash.pairs = pairs;
                lodash.partial = partial;
                lodash.partialRight = partialRight;
                lodash.partition = partition;
                lodash.pick = pick;
                lodash.pluck = pluck;
                lodash.property = property;
                lodash.propertyOf = propertyOf;
                lodash.pull = pull;
                lodash.pullAt = pullAt;
                lodash.range = range;
                lodash.rearg = rearg;
                lodash.reject = reject;
                lodash.remove = remove;
                lodash.rest = rest;
                lodash.restParam = restParam;
                lodash.set = set;
                lodash.shuffle = shuffle;
                lodash.slice = slice;
                lodash.sortBy = sortBy;
                lodash.sortByAll = sortByAll;
                lodash.sortByOrder = sortByOrder;
                lodash.spread = spread;
                lodash.take = take;
                lodash.takeRight = takeRight;
                lodash.takeRightWhile = takeRightWhile;
                lodash.takeWhile = takeWhile;
                lodash.tap = tap;
                lodash.throttle = throttle;
                lodash.thru = thru;
                lodash.times = times;
                lodash.toArray = toArray;
                lodash.toPlainObject = toPlainObject;
                lodash.transform = transform;
                lodash.union = union;
                lodash.uniq = uniq;
                lodash.unzip = unzip;
                lodash.unzipWith = unzipWith;
                lodash.values = values;
                lodash.valuesIn = valuesIn;
                lodash.where = where;
                lodash.without = without;
                lodash.wrap = wrap;
                lodash.xor = xor;
                lodash.zip = zip;
                lodash.zipObject = zipObject;
                lodash.zipWith = zipWith;
                lodash.backflow = flowRight;
                lodash.collect = map;
                lodash.compose = flowRight;
                lodash.each = forEach;
                lodash.eachRight = forEachRight;
                lodash.extend = assign;
                lodash.iteratee = callback;
                lodash.methods = functions;
                lodash.object = zipObject;
                lodash.select = filter;
                lodash.tail = rest;
                lodash.unique = uniq;
                mixin(lodash, lodash);
                lodash.add = add;
                lodash.attempt = attempt;
                lodash.camelCase = camelCase;
                lodash.capitalize = capitalize;
                lodash.ceil = ceil;
                lodash.clone = clone;
                lodash.cloneDeep = cloneDeep;
                lodash.deburr = deburr;
                lodash.endsWith = endsWith;
                lodash.escape = escape;
                lodash.escapeRegExp = escapeRegExp;
                lodash.every = every;
                lodash.find = find;
                lodash.findIndex = findIndex;
                lodash.findKey = findKey;
                lodash.findLast = findLast;
                lodash.findLastIndex = findLastIndex;
                lodash.findLastKey = findLastKey;
                lodash.findWhere = findWhere;
                lodash.first = first;
                lodash.floor = floor;
                lodash.get = get;
                lodash.gt = gt;
                lodash.gte = gte;
                lodash.has = has;
                lodash.identity = identity;
                lodash.includes = includes;
                lodash.indexOf = indexOf;
                lodash.inRange = inRange;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray;
                lodash.isBoolean = isBoolean;
                lodash.isDate = isDate;
                lodash.isElement = isElement;
                lodash.isEmpty = isEmpty;
                lodash.isEqual = isEqual;
                lodash.isError = isError;
                lodash.isFinite = isFinite;
                lodash.isFunction = isFunction;
                lodash.isMatch = isMatch;
                lodash.isNaN = isNaN;
                lodash.isNative = isNative;
                lodash.isNull = isNull;
                lodash.isNumber = isNumber;
                lodash.isObject = isObject;
                lodash.isPlainObject = isPlainObject;
                lodash.isRegExp = isRegExp;
                lodash.isString = isString;
                lodash.isTypedArray = isTypedArray;
                lodash.isUndefined = isUndefined;
                lodash.kebabCase = kebabCase;
                lodash.last = last;
                lodash.lastIndexOf = lastIndexOf;
                lodash.lt = lt;
                lodash.lte = lte;
                lodash.max = max;
                lodash.min = min;
                lodash.noConflict = noConflict;
                lodash.noop = noop;
                lodash.now = now;
                lodash.pad = pad;
                lodash.padLeft = padLeft;
                lodash.padRight = padRight;
                lodash.parseInt = parseInt;
                lodash.random = random;
                lodash.reduce = reduce;
                lodash.reduceRight = reduceRight;
                lodash.repeat = repeat;
                lodash.result = result;
                lodash.round = round;
                lodash.runInContext = runInContext;
                lodash.size = size;
                lodash.snakeCase = snakeCase;
                lodash.some = some;
                lodash.sortedIndex = sortedIndex;
                lodash.sortedLastIndex = sortedLastIndex;
                lodash.startCase = startCase;
                lodash.startsWith = startsWith;
                lodash.sum = sum;
                lodash.template = template;
                lodash.trim = trim;
                lodash.trimLeft = trimLeft;
                lodash.trimRight = trimRight;
                lodash.trunc = trunc;
                lodash.unescape = unescape;
                lodash.uniqueId = uniqueId;
                lodash.words = words;
                lodash.all = every;
                lodash.any = some;
                lodash.contains = includes;
                lodash.eq = isEqual;
                lodash.detect = find;
                lodash.foldl = reduce;
                lodash.foldr = reduceRight;
                lodash.head = first;
                lodash.include = includes;
                lodash.inject = reduce;
                mixin(lodash, function() {
                    var source = {};
                    baseForOwn(lodash, function(func, methodName) {
                        if (!lodash.prototype[methodName]) source[methodName] = func;
                    });
                    return source;
                }(), false);
                lodash.sample = sample;
                lodash.prototype.sample = function(n) {
                    if (!this.__chain__ && null == n) return sample(this.value());
                    return this.thru(function(value) {
                        return sample(value, n);
                    });
                };
                lodash.VERSION = VERSION;
                arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
                    lodash[methodName].placeholder = lodash;
                });
                arrayEach([ "drop", "take" ], function(methodName, index) {
                    LazyWrapper.prototype[methodName] = function(n) {
                        var filtered = this.__filtered__;
                        if (filtered && !index) return new LazyWrapper(this);
                        n = null == n ? 1 : nativeMax(nativeFloor(n) || 0, 0);
                        var result = this.clone();
                        if (filtered) result.__takeCount__ = nativeMin(result.__takeCount__, n); else result.__views__.push({
                            size: n,
                            type: methodName + (result.__dir__ < 0 ? "Right" : "")
                        });
                        return result;
                    };
                    LazyWrapper.prototype[methodName + "Right"] = function(n) {
                        return this.reverse()[methodName](n).reverse();
                    };
                });
                arrayEach([ "filter", "map", "takeWhile" ], function(methodName, index) {
                    var type = index + 1, isFilter = type != LAZY_MAP_FLAG;
                    LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
                        var result = this.clone();
                        result.__iteratees__.push({
                            iteratee: getCallback(iteratee, thisArg, 1),
                            type: type
                        });
                        result.__filtered__ = result.__filtered__ || isFilter;
                        return result;
                    };
                });
                arrayEach([ "first", "last" ], function(methodName, index) {
                    var takeName = "take" + (index ? "Right" : "");
                    LazyWrapper.prototype[methodName] = function() {
                        return this[takeName](1).value()[0];
                    };
                });
                arrayEach([ "initial", "rest" ], function(methodName, index) {
                    var dropName = "drop" + (index ? "" : "Right");
                    LazyWrapper.prototype[methodName] = function() {
                        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                    };
                });
                arrayEach([ "pluck", "where" ], function(methodName, index) {
                    var operationName = index ? "filter" : "map", createCallback = index ? baseMatches : property;
                    LazyWrapper.prototype[methodName] = function(value) {
                        return this[operationName](createCallback(value));
                    };
                });
                LazyWrapper.prototype.compact = function() {
                    return this.filter(identity);
                };
                LazyWrapper.prototype.reject = function(predicate, thisArg) {
                    predicate = getCallback(predicate, thisArg, 1);
                    return this.filter(function(value) {
                        return !predicate(value);
                    });
                };
                LazyWrapper.prototype.slice = function(start, end) {
                    start = null == start ? 0 : +start || 0;
                    var result = this;
                    if (result.__filtered__ && (start > 0 || end < 0)) return new LazyWrapper(result);
                    if (start < 0) result = result.takeRight(-start); else if (start) result = result.drop(start);
                    if (end !== undefined) {
                        end = +end || 0;
                        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                    }
                    return result;
                };
                LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
                    return this.reverse().takeWhile(predicate, thisArg).reverse();
                };
                LazyWrapper.prototype.toArray = function() {
                    return this.take(POSITIVE_INFINITY);
                };
                baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName), retUnwrapped = /^(?:first|last)$/.test(methodName), lodashFunc = lodash[retUnwrapped ? "take" + ("last" == methodName ? "Right" : "") : methodName];
                    if (!lodashFunc) return;
                    lodash.prototype[methodName] = function() {
                        var args = retUnwrapped ? [ 1 ] : arguments, chainAll = this.__chain__, value = this.__wrapped__, isHybrid = !!this.__actions__.length, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                        if (useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length) isLazy = useLazy = false;
                        var interceptor = function(value) {
                            return retUnwrapped && chainAll ? lodashFunc(value, 1)[0] : lodashFunc.apply(undefined, arrayPush([ value ], args));
                        };
                        var action = {
                            func: thru,
                            args: [ interceptor ],
                            thisArg: undefined
                        }, onlyLazy = isLazy && !isHybrid;
                        if (retUnwrapped && !chainAll) {
                            if (onlyLazy) {
                                value = value.clone();
                                value.__actions__.push(action);
                                return func.call(value);
                            }
                            return lodashFunc.call(undefined, this.value())[0];
                        }
                        if (!retUnwrapped && useLazy) {
                            value = onlyLazy ? value : new LazyWrapper(this);
                            var result = func.apply(value, args);
                            result.__actions__.push(action);
                            return new LodashWrapper(result, chainAll);
                        }
                        return this.thru(interceptor);
                    };
                });
                arrayEach([ "join", "pop", "push", "replace", "shift", "sort", "splice", "split", "unshift" ], function(methodName) {
                    var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
                    lodash.prototype[methodName] = function() {
                        var args = arguments;
                        if (retUnwrapped && !this.__chain__) return func.apply(this.value(), args);
                        return this[chainName](function(value) {
                            return func.apply(value, args);
                        });
                    };
                });
                baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var lodashFunc = lodash[methodName];
                    if (lodashFunc) {
                        var key = lodashFunc.name, names = realNames[key] || (realNames[key] = []);
                        names.push({
                            name: methodName,
                            func: lodashFunc
                        });
                    }
                });
                realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [ {
                    name: "wrapper",
                    func: undefined
                } ];
                LazyWrapper.prototype.clone = lazyClone;
                LazyWrapper.prototype.reverse = lazyReverse;
                LazyWrapper.prototype.value = lazyValue;
                lodash.prototype.chain = wrapperChain;
                lodash.prototype.commit = wrapperCommit;
                lodash.prototype.concat = wrapperConcat;
                lodash.prototype.plant = wrapperPlant;
                lodash.prototype.reverse = wrapperReverse;
                lodash.prototype.toString = wrapperToString;
                lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                lodash.prototype.collect = lodash.prototype.map;
                lodash.prototype.head = lodash.prototype.first;
                lodash.prototype.select = lodash.prototype.filter;
                lodash.prototype.tail = lodash.prototype.rest;
                return lodash;
            }
            var _ = runInContext();
            if (true) {
                root._ = _;
                !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return _;
                }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (freeExports && freeModule) if (moduleExports) (freeModule.exports = _)._ = _; else freeExports._ = _; else root._ = _;
        }).call(this);
    }).call(exports, __webpack_require__(35)(module), function() {
        return this;
    }());
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
            return arr2;
        } else return Array.from(arr);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _signals = __webpack_require__(311);
    var _signals2 = _interopRequireDefault(_signals);
    var Collection = function() {
        function Collection(storage, query) {
            _classCallCheck(this, Collection);
            this.onUpdated = new _signals2["default"]();
            this.storage = storage;
            this.cache = new Map();
            this.enabled = true;
            this.query = query;
        }
        _createClass(Collection, [ {
            key: "update",
            value: function() {
                var items = arguments.length <= 0 || void 0 === arguments[0] ? [] : arguments[0];
                var old = [];
                var inserted = [];
                var updated = [];
                var excluded = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = void 0;
                try {
                    for (var _step, _iterator = items[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var item = _step.value;
                        this._processItem(item, inserted, excluded, updated, old);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) _iterator["return"]();
                    } finally {
                        if (_didIteratorError) throw _iteratorError;
                    }
                }
                var wasUpdated = [ inserted, updated, excluded ].some(function(collection) {
                    return collection.length;
                });
                if (wasUpdated) this.onUpdated.dispatch(this, {
                    inserted: inserted,
                    excluded: excluded,
                    updated: updated,
                    old: old
                });
                return this;
            }
        }, {
            key: "_processItem",
            value: function(item, inserted, excluded, updated, old) {
                var id = item.getId();
                var isExists = this.cache.has(id);
                var isAcceptable = this.query(item);
                if (!isAcceptable && !isExists) return;
                if (!isExists) {
                    this._insertItem(id, item, inserted);
                    return;
                }
                if (!isAcceptable) {
                    this._excludeItem(id, excluded);
                    return;
                }
                this._updateItem(id, item, updated, old);
            }
        }, {
            key: "_insertItem",
            value: function(id, item, inserted) {
                item = item.clone();
                this.cache.set(id, item);
                inserted.push(item);
            }
        }, {
            key: "_excludeItem",
            value: function(id, excluded) {
                var oldItem = this.cache.get(id);
                excluded.push(oldItem);
                this.cache["delete"](id);
            }
        }, {
            key: "_updateItem",
            value: function(id, item, updated, old) {
                var oldItem = this.cache.get(id);
                item = item.clone();
                old.push(oldItem);
                updated.push(item);
                this.cache.set(id, item);
            }
        }, {
            key: "remove",
            value: function() {
                var _this = this;
                var ids = arguments.length <= 0 || void 0 === arguments[0] ? [] : arguments[0];
                var removed = [];
                ids.forEach(function(id) {
                    if (_this.cache.has(id)) {
                        removed.push(_this.cache.get(id));
                        _this.cache["delete"](id);
                    }
                });
                if (removed.length) this.onUpdated.dispatch(this, {
                    removed: removed
                });
                return this;
            }
        }, {
            key: "reload",
            value: function() {
                this.storage.reloadCollection(this);
                return this;
            }
        }, {
            key: "destroy",
            value: function() {
                this.storage.removeCollection(this);
                this.onUpdated.removeAll();
                this.cache.clear();
                return this;
            }
        }, {
            key: "enable",
            value: function() {
                this.enabled = true;
                this.storage.activateCollection(this);
                return this;
            }
        }, {
            key: "disable",
            value: function() {
                this.enabled = false;
                return this;
            }
        }, {
            key: "forEach",
            value: function(callback, scope) {
                this.toArray().forEach(callback, scope);
            }
        }, {
            key: "map",
            value: function(callback, scope) {
                return this.toArray().map(callback, scope);
            }
        }, {
            key: "reduce",
            value: function(callback, initialValue) {
                return this.toArray().reduce(callback, initialValue);
            }
        }, {
            key: "some",
            value: function(callback, scope) {
                return this.toArray().some(callback, scope);
            }
        }, {
            key: "every",
            value: function(callback, scope) {
                return this.toArray().every(callback, scope);
            }
        }, {
            key: "toArray",
            value: function() {
                return [].concat(_toConsumableArray(this.values));
            }
        }, {
            key: "values",
            get: function() {
                return this.cache.values();
            }
        }, {
            key: "size",
            get: function() {
                return this.cache.size;
            }
        } ]);
        return Collection;
    }();
    exports["default"] = Collection;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _signals = __webpack_require__(311);
    var _signals2 = _interopRequireDefault(_signals);
    var _navigation = __webpack_require__(313);
    var BEFORE_NAVIGATE = _navigation.NAVIGATION_STATUS.BEFORE_NAVIGATE;
    var COMMITTED = _navigation.NAVIGATION_STATUS.COMMITTED;
    var DOM_CONTENT_LOADED = _navigation.NAVIGATION_STATUS.DOM_CONTENT_LOADED;
    var COMPLETED = _navigation.NAVIGATION_STATUS.COMPLETED;
    var ERROR_OCCURRED = _navigation.NAVIGATION_STATUS.ERROR_OCCURRED;
    var HISTORY_STATE_UPDATED = _navigation.NAVIGATION_STATUS.HISTORY_STATE_UPDATED;
    var REFERENCE_FRAGMENT_UPDATED = _navigation.NAVIGATION_STATUS.REFERENCE_FRAGMENT_UPDATED;
    var NavListener = function() {
        function NavListener() {
            _classCallCheck(this, NavListener);
            this._createSignals();
            this._listenNav();
        }
        _createClass(NavListener, [ {
            key: "_createSignals",
            value: function() {
                this.onNavigationUpdated = new _signals2["default"]();
            }
        }, {
            key: "_listenNav",
            value: function() {
                chrome.webNavigation.onBeforeNavigate.addListener(this._onBeforeNavigate.bind(this));
                chrome.webNavigation.onCommitted.addListener(this._onCommitted.bind(this));
                chrome.webNavigation.onDOMContentLoaded.addListener(this._onDOMContentLoaded.bind(this));
                chrome.webNavigation.onCompleted.addListener(this._onCompleted.bind(this));
                chrome.webNavigation.onErrorOccurred.addListener(this._onErrorOccurred.bind(this));
                if (chrome.webNavigation.onReferenceFragmentUpdated) chrome.webNavigation.onReferenceFragmentUpdated.addListener(this._onNavigationUpdated.bind(this, REFERENCE_FRAGMENT_UPDATED));
                if (chrome.webNavigation.onHistoryStateUpdated) chrome.webNavigation.onHistoryStateUpdated.addListener(this._onNavigationUpdated.bind(this, HISTORY_STATE_UPDATED));
            }
        }, {
            key: "_onNavigationUpdated",
            value: function(status, details) {
                this._onCommitted(details, status);
            }
        }, {
            key: "_onErrorOccurred",
            value: function(_ref) {
                var frameId = _ref.frameId;
                var url = _ref.url;
                var tabId = _ref.tabId;
                var error = _ref.error;
                if (0 !== frameId) return;
                this.onNavigationUpdated.dispatch({
                    tabId: tabId,
                    error: error,
                    url: url,
                    status: ERROR_OCCURRED
                });
            }
        }, {
            key: "_onCompleted",
            value: function(_ref2) {
                var frameId = _ref2.frameId;
                var tabId = _ref2.tabId;
                var url = _ref2.url;
                if (0 !== frameId) return;
                this.onNavigationUpdated.dispatch({
                    tabId: tabId,
                    url: url,
                    status: COMPLETED
                });
            }
        }, {
            key: "_onDOMContentLoaded",
            value: function(_ref3) {
                var frameId = _ref3.frameId;
                var url = _ref3.url;
                var tabId = _ref3.tabId;
                if (0 !== frameId) return;
                this.onNavigationUpdated.dispatch({
                    tabId: tabId,
                    url: url,
                    status: DOM_CONTENT_LOADED
                });
            }
        }, {
            key: "_onCommitted",
            value: function(_ref4) {
                var frameId = _ref4.frameId;
                var transitionType = _ref4.transitionType;
                var transitionQualifiers = _ref4.transitionQualifiers;
                var url = _ref4.url;
                var tabId = _ref4.tabId;
                var status = arguments.length <= 1 || void 0 === arguments[1] ? COMMITTED : arguments[1];
                if (0 !== frameId) return;
                this.onNavigationUpdated.dispatch({
                    tabId: tabId,
                    transitionType: transitionType,
                    transitionQualifiers: transitionQualifiers,
                    url: url,
                    status: status
                });
            }
        }, {
            key: "_onBeforeNavigate",
            value: function(_ref5) {
                var frameId = _ref5.frameId;
                var tabId = _ref5.tabId;
                var url = _ref5.url;
                if (0 !== frameId) return;
                this.onNavigationUpdated.dispatch({
                    tabId: tabId,
                    url: url,
                    status: BEFORE_NAVIGATE
                });
            }
        } ]);
        return NavListener;
    }();
    exports["default"] = NavListener;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    var urlUtils = __webpack_require__(83);
    var browserInfo = __webpack_require__(22);
    var faviconYandex = __webpack_require__(258);
    var CLOSED_WINDOWS_PREFIX = "win-";
    exports.isWindowId = function(id) {
        return id && id.indexOf(CLOSED_WINDOWS_PREFIX) > -1;
    };
    exports.createClosedTab = function(url, tabData, removeInfo) {
        return {
            id: String(tabData.id),
            url: url,
            isWindow: false,
            title: tabData.title || url,
            favicon: getFaviconUrl(tabData, url),
            windowId: tabData.windowId,
            closedTime: Date.now(),
            closedWithWindow: removeInfo.isWindowClosing
        };
    };
    function getFaviconUrl(tabData, url) {
        var favUrl = tabData.favIconUrl;
        if (!favUrl && urlUtils.isRemote(url)) favUrl = faviconYandex.getUrl(url);
        return favUrl;
    }
    exports.createClosedWindow = function(urls, windowId) {
        if (browserInfo.isFirefox()) urls.reverse();
        return {
            id: CLOSED_WINDOWS_PREFIX + windowId,
            isWindow: true,
            windowId: windowId,
            urls: urls,
            domains: getReadableParts(urls),
            closedTime: Date.now()
        };
    };
    function getReadableParts(urls) {
        return urls.map(function(url) {
            if (!urlUtils.isSpecialUrl(url)) return urlUtils.getReadableDomain(url) || urlUtils.getReadableUrl(url) || url;
            return url;
        });
    }
}, function(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(44);
    var regexpTag = "[object RegExp]";
    var objectProto = Object.prototype;
    var objToString = objectProto.toString;
    function isRegExp(value) {
        return isObject(value) && objToString.call(value) == regexpTag;
    }
    module.exports = isRegExp;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var take = __webpack_require__(324);
    var MAX_CLOSED_WINDOWS_COUNT = 5;
    var MAX_CLOSED_TOTAL_COUNT = 15;
    exports.sortItems = function(items, windowId) {
        var windows = exports.getWindows(items).sort(compareByClosedTime);
        var tabs = exports.getTabs(items, windowId).sort(compareByClosedTime);
        windows = take(windows, MAX_CLOSED_WINDOWS_COUNT);
        tabs = take(tabs, MAX_CLOSED_TOTAL_COUNT - windows.length);
        return tabs.concat(windows);
    };
    exports.getWindows = function(items) {
        return items.reduce(function(list, item) {
            if (isAcceptableAsWindow(item)) list.push(item);
            return list;
        }, []);
    };
    exports.getTabs = function(items, windowId) {
        var existingUrls = {};
        return items.reduce(function(list, item) {
            if (isAcceptableAsTab(item, windowId, existingUrls)) {
                existingUrls[item.url] = true;
                list.push(item);
            }
            return list;
        }, []);
    };
    function isAcceptableAsWindow(item) {
        return item.isWindow && item.domains && item.domains.length;
    }
    function isAcceptableAsTab(item, windowId, existingUrls) {
        if (item.isWindow) return false;
        if (windowId && item.windowId !== windowId) return false;
        if (existingUrls[item.url]) return false;
        return true;
    }
    function compareByClosedTime(a, b) {
        return b.closedTime - a.closedTime;
    }
}, function(module, exports, __webpack_require__) {
    var baseSlice = __webpack_require__(118), isIterateeCall = __webpack_require__(98);
    function take(array, n, guard) {
        var length = array ? array.length : 0;
        if (!length) return [];
        if (guard ? isIterateeCall(array, n, guard) : null == n) n = 1;
        return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    module.exports = take;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var browserInfo = __webpack_require__(22);
    exports.restoreWindow = function(closedTabs, windowId, callback) {
        for (var i = 0; i < closedTabs.length; i++) {
            var tab = closedTabs[i];
            if (tab.id === windowId) {
                createWindow(tab.urls, tab.windowId, callback);
                return i;
            }
        }
        return -1;
    };
    exports.restoreTab = function(closedTabs, tabId, callback) {
        for (var i = 0; i < closedTabs.length; i++) {
            var tab = closedTabs[i];
            if (tab.id === tabId) {
                createTab(tab.url, tabId, callback);
                return i;
            }
        }
        return -1;
    };
    function createTab(url, restoredTabId, callback) {
        chrome.tabs.create({
            url: url
        }, function(tab) {
            if (callback) callback(chrome.runtime.lastError, restoredTabId, tab);
        });
    }
    function createWindow(urls, restoredWinId, callback) {
        var createData = {
            url: urls
        };
        if (!browserInfo.isFirefox()) createData.focused = true;
        chrome.windows.create(createData, function(window) {
            if (callback) callback(chrome.runtime.lastError, restoredWinId, window);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var take = __webpack_require__(324);
    var merge = __webpack_require__(157);
    var channel = __webpack_require__(27);
    var urlUtils = __webpack_require__(83);
    var storage = __webpack_require__(327);
    var CLOSED_TABS_LIMIT = 1e3;
    exports.onUpdated = channel.create();
    exports.unshift = function(tab) {
        var closedTabs = storage.get();
        closedTabs.unshift(tab);
        updateState(closedTabs);
    };
    exports.remove = function(index) {
        var closedTabs = storage.get();
        if (index < closedTabs.length) {
            closedTabs.splice(index, 1);
            updateState(closedTabs);
        }
    };
    exports.get = function() {
        return storage.get();
    };
    exports.clear = function() {
        updateState([]);
    };
    exports.upsert = function(tab) {
        var list = storage.get();
        var existingTabIndex = findSameTabIndex(list, tab);
        if (existingTabIndex !== -1) tab = merge(list.splice(existingTabIndex, 1)[0], tab);
        list.unshift(tab);
        updateState(list);
    };
    exports.removeClosedWithWindowTabs = function(windowId) {
        var tabs = storage.get();
        var result = {
            windowTabs: [],
            restTabs: []
        };
        result.restTabs = tabs.filter(function(tab) {
            if (isTabClosedWithWindow(tab, windowId)) {
                result.windowTabs.push(tab);
                return false;
            }
            return true;
        });
        updateState(result.restTabs);
        return result.windowTabs;
    };
    exports.replaceWindowIds = function(oldId, newId) {
        var tabs = storage.get();
        tabs.forEach(function(tab) {
            if (tab.windowId === oldId) tab.windowId = newId;
        });
        updateState(tabs);
    };
    function findSameTabIndex(list, tab) {
        for (var i = 0; i < list.length; i++) {
            var existingTab = list[i];
            if (isSameTabs(existingTab, tab)) return i;
        }
        return -1;
    }
    function isSameTabs(tab1, tab2) {
        return tab1.windowId === tab2.windowId && urlUtils.isEqualUrls(tab1.url, tab2.url);
    }
    function isTabClosedWithWindow(tab, windowId) {
        return tab.windowId === windowId && tab.closedWithWindow;
    }
    function updateState(closedTabs) {
        closedTabs = take(closedTabs, CLOSED_TABS_LIMIT);
        storage.set(closedTabs);
        exports.onUpdated.dispatch(closedTabs);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var debounce = __webpack_require__(149);
    var CLOSED_TABS_PREF = "closedTabs";
    var STORE_DELAY_TIME = 1e3;
    var cache = null;
    var storeCacheDelayed = debounce(function() {
        settings.set(CLOSED_TABS_PREF, cache);
    }, STORE_DELAY_TIME);
    exports.get = function() {
        if (!cache) cache = settings.get(CLOSED_TABS_PREF) || [];
        return cache;
    };
    exports.set = function(tabs) {
        cache = tabs;
        storeCacheDelayed();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var Experimentator = __webpack_require__(329);
    var Experiment = __webpack_require__(330);
    var platformConfigure = __webpack_require__(331);
    var alarms = __webpack_require__(3);
    var runstate = __webpack_require__(344);
    var actualConfigs = __webpack_require__(357);
    var logger = __webpack_require__(5).create("Experiments");
    var _ = __webpack_require__(318);
    var EXPERIMENTS_PREF = "experiments";
    var ALARM = {
        name: "experiments",
        periodInMinutes: 60 * 24
    };
    exports.init = function() {
        alarms.register(ALARM, removeOutdatedExperiments);
        if (runstate.isInstall()) install();
        if (runstate.isUpgrade()) upgrade();
        logExistingExperiments();
    };
    exports.getExperimentsList = function() {
        var experiments = settings.get(EXPERIMENTS_PREF);
        if (Array.isArray(experiments)) return experiments.map(function(data) {
            return new Experiment(data);
        }); else return [];
    };
    exports.getExperimentData = function(experimentName) {
        var experiment = _.find(this.getExperimentsList(), {
            name: experimentName
        });
        return experiment ? experiment.data : null;
    };
    function install() {
        var configs = actualConfigs.get();
        var existing = [];
        var experiments = new Experimentator().createExperiments(configs, existing, {
            isInstall: true
        });
        store(experiments);
    }
    function upgrade() {
        var configs = actualConfigs.get();
        var existing = exports.getExperimentsList();
        var experiments = new Experimentator().createExperiments(configs, existing, {
            isInstall: false
        });
        store(experiments);
    }
    function store(experiments) {
        settings.set(EXPERIMENTS_PREF, experiments);
        platformConfigure({
            experiments: experiments
        });
    }
    function removeOutdatedExperiments() {
        var experiments = exports.getExperimentsList();
        var filtered = new Experimentator().getActualExistingExperiments(experiments, actualConfigs.get());
        store(filtered);
    }
    function logExistingExperiments() {
        logger.info("Selected experiments: %j", exports.getExperimentsList());
        logger.info("Possible experiments: %j", actualConfigs.get());
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _experiment = __webpack_require__(330);
    var _experiment2 = _interopRequireDefault(_experiment);
    var Experimentator = function() {
        function Experimentator() {
            _classCallCheck(this, Experimentator);
        }
        _createClass(Experimentator, [ {
            key: "createExperiments",
            value: function(experimentConfigs, existingExperiments, options) {
                if (void 0 === existingExperiments) existingExperiments = [];
                var actualExistingExperiments = this.getActualExistingExperiments(existingExperiments, experimentConfigs);
                if (actualExistingExperiments.length) return actualExistingExperiments;
                var newExperiment = this.createNewExperiment(experimentConfigs, options);
                return newExperiment ? [ newExperiment ] : [];
            }
        }, {
            key: "createNewExperiment",
            value: function(experimentConfigs, options) {
                var actualExperimentConfigs = experimentConfigs.filter(function(config) {
                    return !isDisabledByRunState(config, options.isInstall);
                }).filter(function(config) {
                    return !isDisabledByTime(config);
                });
                assertPercentSum(actualExperimentConfigs);
                var filtered = filterByPercent(actualExperimentConfigs);
                return filtered.length ? this._createExperiment(filtered[0]) : null;
            }
        }, {
            key: "getActualExistingExperiments",
            value: function(existingExperiments, experimentConfigs) {
                return existingExperiments.filter(function(experiment) {
                    return !isDisabledByTime(experiment.config);
                }).filter(function(experiment) {
                    return isExperimentTestIdInConfigs(experiment, experimentConfigs);
                });
            }
        }, {
            key: "createExperimentInstance",
            value: function(config) {
                return new _experiment2["default"](config);
            }
        }, {
            key: "_createExperiment",
            value: function(config) {
                var _chooseExperiment = chooseExperiment(config.types);
                var _chooseExperiment2 = _slicedToArray(_chooseExperiment, 2);
                var testId = _chooseExperiment2[0];
                var testData = _chooseExperiment2[1];
                return this.createExperimentInstance({
                    name: config.name,
                    testId: testId,
                    data: testData,
                    bucket: generateBucket(),
                    config: config
                });
            }
        } ]);
        return Experimentator;
    }();
    exports["default"] = Experimentator;
    function isDisabledByTime(config) {
        var now = Date.now();
        return now < config.startTime || now > config.endTime;
    }
    function chooseExperiment(expTypes) {
        var idList = Object.keys(expTypes);
        var variantsCount = idList.length;
        var testId = idList[Math.floor(Math.random() * variantsCount)];
        return [ testId, expTypes[testId] ];
    }
    function generateBucket() {
        return Math.floor(1 + 100 * Math.random());
    }
    function filterByPercent(configs) {
        var random = getRandomPercent();
        var upper = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
            for (var _step, _iterator = configs[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var config = _step.value;
                upper += config.percent;
                if (random <= upper) return [ config ];
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) _iterator["return"]();
            } finally {
                if (_didIteratorError) throw _iteratorError;
            }
        }
        return [];
    }
    function isDisabledByRunState(expConfig, isInstall) {
        return expConfig.installOnly && !isInstall;
    }
    function getRandomPercent() {
        return 100 * Math.random();
    }
    function assertPercentSum(configs) {
        var sum = configs.reduce(function(res, config) {
            return res + config.percent;
        }, 0);
        if (sum > 100) throw new Error("Experiments percent sum must be <= 100, you have: " + sum);
    }
    function isExperimentTestIdInConfigs(experiment, configs) {
        return configs.some(function(config) {
            return String(experiment.testId) in config.types;
        });
    }
    module.exports = exports["default"];
}, function(module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Experiment = function Experiment(params) {
        _classCallCheck(this, Experiment);
        this.name = params.name;
        this.testId = params.testId;
        this.bucket = params.bucket;
        this.data = params.data;
        this.config = params.config;
    };
    exports["default"] = Experiment;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    var platformBranding = __webpack_require__(278);
    var fileDownloader = __webpack_require__(332);
    var softExport = __webpack_require__(333);
    var barNavig = __webpack_require__(341);
    var about = __webpack_require__(23);
    var logger = __webpack_require__(5).create("Platform/configure");
    module.exports = function(params) {
        params = params || {};
        if (params.branding) platformBranding.init();
        if (params.fileDownloader) fileDownloader.init();
        if ("init" === params.softExport) softExport.init(); else if ("send" === params.softExport) softExport.send(); else if ("setUninstallURL" === params.softExport) {
            var url = softExport.getGoodbyePageUrl();
            setUninstallUrl(url);
        }
        if ("init" === params.barNavig) barNavig.init();
        if (params.browserAction) setBrowserAction();
    };
    function setUninstallUrl(url) {
        try {
            chrome.runtime.setUninstallURL(url);
            logger.info("Set uninstallUrl: %s", url);
        } catch (e) {
            logger.error("Can not set uninstallUrl: %j", e);
        }
    }
    function setBrowserAction() {
        chrome.action.onClicked.addListener(function() {
            chrome.tabs.create({
                url: about.visbookmarksUrl,
                active: true
            });
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var fs = __webpack_require__(264);
    var xhr = __webpack_require__(32);
    var logger = __webpack_require__(5).create("file-downloader");
    var formatMessage = __webpack_require__(58);
    var MAX_DOWNLOAD_TIMEOUT_MS = 1e3 * 30;
    exports.init = function() {
        fs.download = exports.download;
    };
    exports.download = function(url, fileName, callback) {
        var options = {
            url: url,
            fileName: fileName,
            callback: callback
        };
        xhr({
            url: url,
            timeout: MAX_DOWNLOAD_TIMEOUT_MS,
            parse: "blob"
        }, function(err, response) {
            if (err) onDownloadError(options, err); else if (response.size > 0) onDownloadSuccess(options, response); else onDownloadEmpty(options);
        }, this);
    };
    function onDownloadSuccess(options, response) {
        var reader = new FileReader();
        reader.onload = function(event) {
            onDownloadSuccessInternal(options, event.target.result);
        };
        reader.onerror = function(err) {
            options.callback(err);
        };
        reader.readAsDataURL(response);
    }
    function onDownloadSuccessInternal(options, response) {
        fs.createDirectory(options.fileName, function() {
            fs.write(options.fileName, response, options.callback);
        }, options.callback);
    }
    function onDownloadEmpty(options) {
        var message = formatMessage("Empty response for url: %s", options.url);
        logger.error(message);
        options.callback(new Error(message));
    }
    function onDownloadError(options, err) {
        var message = formatMessage("Download of %s failed for url: %s, with error: %s", options.fileName, options.url, err.message);
        logger.error(message);
        options.callback(new Error(message));
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var urlUtils = __webpack_require__(83);
    var platform = __webpack_require__(334);
    var platformAbout = __webpack_require__(23);
    var platformBuildInfo = __webpack_require__(20);
    var i18n = __webpack_require__(280);
    var platformClid = __webpack_require__(288);
    var branding = __webpack_require__(277);
    var DayusePoller = __webpack_require__(335);
    var xhr = __webpack_require__(32);
    var logger = __webpack_require__(5).create("Statistics/soft-export");
    var settings = __webpack_require__(216);
    var bannerId = __webpack_require__(337);
    var INSTALL_SETTING = "appInstallTime";
    var STAT_URL = "https://soft.export.yandex.ru/status.xml";
    var LAST_SENDING_TIME_SETTING = "lastDayUseSendTime";
    var MAX_GOODBYE_URL_LENGTH = 255;
    var poller;
    exports.init = function() {
        poller = new DayusePoller(LAST_SENDING_TIME_SETTING);
        poller.onTrigger.addListener(exports.send);
    };
    exports.send = function() {
        var lastSendTime = poller.getLastSendTime();
        var stat = lastSendTime ? "dayuse" : "install";
        var params = exports.getParams(stat);
        var url = urlUtils.createURI(STAT_URL).setSearch(params).toString();
        logger.info("Sending %s to %s", stat, url);
        xhr({
            url: url
        }, function(error) {
            if (error) logger.error("Error while sending: %s", error.message); else poller.updateLastSendTime();
        });
    };
    exports.getParams = function(stat) {
        var installTime = settings.get(INSTALL_SETTING);
        var output = {
            stat: stat,
            ui: platform.guid,
            ver: platformBuildInfo.getVersion(),
            lang: i18n.locale,
            bv: utils.browserInfo.version,
            os: "win" === utils.browserInfo.os ? "winnt" : "mac" === utils.browserInfo.os ? "darwin" : "",
            yasoft: platformAbout.yasoft,
            gchid: platformAbout.extensionId,
            brandID: branding.vars.regionId,
            fd: utils.formatDate(new Date(1e3 * installTime), "%Y.%M.%D")
        };
        var lastSendTime = poller.getLastSendTime();
        if (lastSendTime) output.tl = lastSendTime;
        var clid = utils.browserInfo.isFirefox() ? platformClid.getByNumber(1) : platformClid.getPortalClidByNumber(1);
        if (clid) output.clid = clid;
        var bannerIdValue = bannerId.getBannerId();
        if (bannerIdValue) output.bnrd = bannerIdValue;
        return output;
    };
    exports.getGoodbyePageUrl = function() {
        var url = branding.settings.goodbyeUrl;
        var uri = urlUtils.createURI(url);
        if (!uri) return "";
        uri.setSearch(exports.getParams("uninstall"));
        var paramsToTrim = [ "os", "brandID", "bnrd", "gchid", "ver", "bv", "lang", "fd", "clid" ];
        var index = 0;
        while (uri.toString().length > MAX_GOODBYE_URL_LENGTH && index < paramsToTrim.length) uri.removeSearch(paramsToTrim[index++]);
        return uri.toString();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var miscUtils = __webpack_require__(31);
    var logger = __webpack_require__(5).create("Platform");
    var GUID_SETTING = "statUID";
    module.exports = {
        get guid() {
            var guid = settings.get(GUID_SETTING);
            if (!guid) {
                guid = "{" + miscUtils.guid() + "}";
                settings.set(GUID_SETTING, guid);
                logger.info("Generated guid: %s", guid);
            }
            return guid;
        },
        getBarnavigParams: function(options, callback) {
            if (!options) {
                callback();
                return;
            }
            chrome.tabs.sendMessage(options.tabId, {
                contentScriptAction: "getBarnavigParams",
                isYandexHost: options.isYandexHost
            }, callback);
        },
        export: function(data) {
            chrome.storage.local.set({
                ybimport: data
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var alarms = __webpack_require__(3);
    var channel = __webpack_require__(27);
    var dayuseHelper = __webpack_require__(336);
    var ALARM = {
        name: "dayusePoll",
        periodInMinutes: 60,
        delayInMinutes: 1
    };
    DayusePoller.onPoll = channel.create();
    DayusePoller.init = function() {
        alarms.register(ALARM, function() {
            DayusePoller.onPoll.dispatch();
        });
    };
    function DayusePoller(settingName) {
        this._settingName = settingName;
        this.onTrigger = channel.create();
        DayusePoller.onPoll.addListener(this._tryTrigger.bind(this));
    }
    DayusePoller.prototype.updateLastSendTime = function() {
        settings.set(this._settingName, Math.floor(Date.now() / 1e3));
    };
    DayusePoller.prototype.getLastSendTime = function() {
        return settings.get(this._settingName);
    };
    DayusePoller.prototype._tryTrigger = function() {
        var lastSendTime = settings.get(this._settingName);
        if (!lastSendTime || lastSendTime < dayuseHelper.getEndOfDayTime()) this.onTrigger.dispatch();
    };
    module.exports = DayusePoller;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var INSTALL_SETTING = "appInstallTime";
    var SECONDS_IN_DAY = 60 * 60 * 24;
    var END_OF_STAT_DAY_HOUR = 3;
    exports.getEndOfDayTime = function(timestampSec) {
        var now = isNaN(timestampSec) ? new Date() : new Date(1e3 * timestampSec);
        var dateNumber = now.getHours() < END_OF_STAT_DAY_HOUR ? now.getDate() - 1 : now.getDate();
        var treeAMDate = new Date(now.getFullYear(), now.getMonth(), dateNumber, END_OF_STAT_DAY_HOUR).getTime();
        return parseInt(treeAMDate / 1e3, 10);
    };
    exports.getDayuseCount = function() {
        var installTime = settings.get(INSTALL_SETTING);
        var now = Date.now() / 1e3;
        var endOfInstallDayTime = exports.getEndOfDayTime(installTime);
        return Math.floor((now - endOfInstallDayTime) / SECONDS_IN_DAY);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("cookies bannerid");
    var settings = __webpack_require__(216);
    var branding = __webpack_require__(277);
    var BannerID = __webpack_require__(338);
    var YsCookie = __webpack_require__(339);
    var BANNER_ID_PREF = "bannerid";
    exports.processCookie = function() {
        var bannerId = exports.getBannerId();
        return bannerId ? Promise.resolve(bannerId) : createBannerId().run().then(saveBannerId);
    };
    exports.getBannerId = function() {
        return settings.get(BANNER_ID_PREF);
    };
    function createBannerId() {
        var domains = branding.bannerid.domains.map(function(domain) {
            return branding.expandUrl(domain);
        });
        logger.info("Search bannerid in ys cookie on domains: %s", domains.join(", "));
        return new BannerID({
            domainsQueue: domains
        }, YsCookie);
    }
    function saveBannerId(bannerId) {
        logger.info("Banner id value from cookie: %s", bannerId);
        if (bannerId) settings.set(BANNER_ID_PREF, bannerId);
        return bannerId;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _lodashObjectDefaults = __webpack_require__(92);
    var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
    var _lodashCollectionFilter = __webpack_require__(204);
    var _lodashCollectionFilter2 = _interopRequireDefault(_lodashCollectionFilter);
    var _lodashCollectionFind = __webpack_require__(197);
    var _lodashCollectionFind2 = _interopRequireDefault(_lodashCollectionFind);
    var DEFAULT_OPTIONS = {
        cookieName: "ys",
        cookiePart: "bnrd"
    };
    var BannerID = function() {
        function BannerID(options, YsCookie) {
            _classCallCheck(this, BannerID);
            options = (0, _lodashObjectDefaults2["default"])(options, DEFAULT_OPTIONS);
            this._cookieName = options.cookieName;
            this._cookiePart = options.cookiePart;
            this._domainsQueue = options.domainsQueue;
            this._YsCookie = YsCookie;
        }
        _createClass(BannerID, [ {
            key: "run",
            value: function() {
                var cookies = this._createCookiesForDomains();
                return this._updateBannerId(cookies);
            }
        }, {
            key: "_createCookiesForDomains",
            value: function() {
                var _this = this;
                return this._domainsQueue.map(function(domain) {
                    return new _this._YsCookie(domain);
                });
            }
        }, {
            key: "_updateBannerId",
            value: function(cookies) {
                var _this2 = this;
                return this._getBannerIdValues(cookies).then(function(results) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = void 0;
                    try {
                        var _loop = function() {
                            var domain = _step.value;
                            var data = _this2._findCookieForDomain(domain, results);
                            if (data) return {
                                v: data.cookie.deletePart(_this2._cookiePart).then(function() {
                                    return Promise.resolve(data.bannerId);
                                })
                            };
                        };
                        for (var _step, _iterator = _this2._domainsQueue[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var _ret = _loop();
                            if ("object" === typeof _ret) return _ret.v;
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"]) _iterator["return"]();
                        } finally {
                            if (_didIteratorError) throw _iteratorError;
                        }
                    }
                    return Promise.resolve(null);
                });
            }
        }, {
            key: "_getBannerIdValues",
            value: function(cookies) {
                var _this3 = this;
                var tasks = cookies.map(function(cookie) {
                    return cookie.getValue(_this3._cookiePart).then(function(bannerId) {
                        return {
                            cookie: cookie,
                            bannerId: bannerId
                        };
                    });
                });
                return Promise.all(tasks).then(function(values) {
                    return (0, _lodashCollectionFilter2["default"])(values, "bannerId");
                });
            }
        }, {
            key: "_findCookieForDomain",
            value: function(domain, data) {
                return (0, _lodashCollectionFind2["default"])(data, function(result) {
                    return result.cookie.domain === domain;
                });
            }
        } ]);
        return BannerID;
    }();
    exports["default"] = BannerID;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _thenChrome = __webpack_require__(283);
    var _thenChrome2 = _interopRequireDefault(_thenChrome);
    var _lodashCollectionFind = __webpack_require__(197);
    var _lodashCollectionFind2 = _interopRequireDefault(_lodashCollectionFind);
    var _ysSerializer = __webpack_require__(340);
    var _ysSerializer2 = _interopRequireDefault(_ysSerializer);
    var YS_COOKIE_NAME = "ys";
    var YS_COOKIE_PROTOCOL = "https";
    var YsCookie = function() {
        function YsCookie(domain) {
            _classCallCheck(this, YsCookie);
            this.domain = domain;
            this.name = YS_COOKIE_NAME;
            this.protocol = YS_COOKIE_PROTOCOL;
            this._ysSerializer = new _ysSerializer2["default"]();
        }
        _createClass(YsCookie, [ {
            key: "getCookie",
            value: function() {
                var params = {
                    domain: this.domain,
                    name: this.name
                };
                return _thenChrome2["default"].cookies.getAll(params).then(this._getFirstCookie.bind(this));
            }
        }, {
            key: "addPart",
            value: function(key, value) {
                var _this = this;
                return this.getCookie().then(function(cookie) {
                    var existingValue = cookie ? cookie.value : "";
                    var newValue = _this._ysSerializer.addPart(existingValue, key, value);
                    return _this._saveIfChanged(newValue, existingValue, key);
                });
            }
        }, {
            key: "deletePart",
            value: function(key) {
                var _this2 = this;
                return this.getCookie().then(function(cookie) {
                    if (cookie) {
                        var existingValue = cookie.value;
                        var newValue = _this2._ysSerializer.deletePart(existingValue, key);
                        return _this2._saveIfChanged(newValue, existingValue, key);
                    }
                    return null;
                });
            }
        }, {
            key: "updatePart",
            value: function(key, value) {
                var _this3 = this;
                return this.getCookie().then(function(cookie) {
                    if (cookie) {
                        var existingValue = cookie.value;
                        var newValue = _this3._ysSerializer.updatePart(existingValue, key, value);
                        return _this3._saveIfChanged(newValue, existingValue, key);
                    }
                    return null;
                });
            }
        }, {
            key: "upsertPart",
            value: function(key, value) {
                var _this4 = this;
                return this.getCookie().then(function(cookie) {
                    var existingValue = cookie ? cookie.value : "";
                    var newValue = _this4._ysSerializer.upsertPart(existingValue, key, value);
                    return _this4._saveIfChanged(newValue, existingValue, key);
                });
            }
        }, {
            key: "getValue",
            value: function(key) {
                var _this5 = this;
                return this.getCookie().then(function(cookie) {
                    if (cookie) return _this5._ysSerializer.getValue(cookie.value, key);
                    return null;
                });
            }
        }, {
            key: "_saveIfChanged",
            value: function(newCookieValue, oldCookieValue, changedPart) {
                if (this._ysSerializer.isPartChanged(newCookieValue, oldCookieValue, changedPart)) return this._saveCookie(newCookieValue); else return Promise.resolve(newCookieValue);
            }
        }, {
            key: "_saveCookie",
            value: function(cookieValue) {
                return this._setCookie(cookieValue).then(function() {
                    return Promise.resolve(cookieValue);
                });
            }
        }, {
            key: "_getFirstCookie",
            value: function(cookies) {
                return (0, _lodashCollectionFind2["default"])(cookies, function(cookie) {
                    return false === cookie.hostOnly;
                }) || cookies[0];
            }
        }, {
            key: "_setCookie",
            value: function(cookieValue) {
                return _thenChrome2["default"].cookies.set({
                    url: this.protocol + "://" + this.domain.replace(/^\./, "") + "/",
                    domain: this.domain,
                    name: this.name,
                    value: cookieValue
                });
            }
        } ]);
        return YsCookie;
    }();
    exports["default"] = YsCookie;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _lodashObjectDefaults = __webpack_require__(92);
    var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
    var DEFAULT_OPTIONS = {
        partsDelimiter: "#",
        keyValueDelimiter: "."
    };
    var YsSerializer = function() {
        function YsSerializer(options) {
            _classCallCheck(this, YsSerializer);
            options = (0, _lodashObjectDefaults2["default"])({}, options, DEFAULT_OPTIONS);
            this._partsDelimiter = options.partsDelimiter;
            this._keyValueDelimiter = options.keyValueDelimiter;
        }
        _createClass(YsSerializer, [ {
            key: "getParts",
            value: function(cookieValue) {
                return cookieValue.split(this._partsDelimiter).filter(Boolean);
            }
        }, {
            key: "addPart",
            value: function(cookieValue, key, value) {
                var data = this.getParts(cookieValue);
                data.push(this._createPart(key, value));
                return this._toCookieValue(data);
            }
        }, {
            key: "deletePart",
            value: function(cookieValue, key) {
                var data = this.getParts(cookieValue).filter(function(part) {
                    var _part$split = part.split(this._keyValueDelimiter);
                    var _part$split2 = _slicedToArray(_part$split, 1);
                    var keyPart = _part$split2[0];
                    return key !== keyPart;
                }, this);
                return this._toCookieValue(data);
            }
        }, {
            key: "updatePart",
            value: function(cookieValue, key, value) {
                var _this = this;
                var data = this.getParts(cookieValue).map(function(part) {
                    var _part$split3 = part.split(_this._keyValueDelimiter);
                    var _part$split32 = _slicedToArray(_part$split3, 1);
                    var keyPart = _part$split32[0];
                    if (keyPart === key) return _this._createPart(keyPart, value);
                    return part;
                });
                return this._toCookieValue(data);
            }
        }, {
            key: "upsertPart",
            value: function(cookieValue, key, value) {
                var existingValue = this.getValue(cookieValue, key);
                if (existingValue) return this.updatePart(cookieValue, key, value); else return this.addPart(cookieValue, key, value);
            }
        }, {
            key: "getValue",
            value: function(cookieValue, key) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = void 0;
                try {
                    for (var _step, _iterator = this.getParts(cookieValue)[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var cookiePart = _step.value;
                        var keyValue = this._parsePart(cookiePart);
                        if (keyValue.key === key) return keyValue.value;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) _iterator["return"]();
                    } finally {
                        if (_didIteratorError) throw _iteratorError;
                    }
                }
                return null;
            }
        }, {
            key: "getValues",
            value: function(cookieValue) {
                return this.getParts(cookieValue).map(this._parsePart, this);
            }
        }, {
            key: "isPartChanged",
            value: function(newCookieValue, oldCookieValue, part) {
                var oldValue = this.getValue(oldCookieValue, part);
                var newValue = this.getValue(newCookieValue, part);
                return newValue !== oldValue;
            }
        }, {
            key: "_createPart",
            value: function(key, value) {
                return key + this._keyValueDelimiter + encodeURIComponent(value);
            }
        }, {
            key: "_toCookieValue",
            value: function(data) {
                return data.join(this._partsDelimiter);
            }
        }, {
            key: "_parsePart",
            value: function(part) {
                var pos = part.indexOf(this._keyValueDelimiter);
                var key = pos === -1 ? part : part.substr(0, pos);
                var value = pos === -1 ? null : part.substr(pos + 1);
                return {
                    key: key,
                    value: value ? decodeURIComponent(value) : "",
                    source: part
                };
            }
        } ]);
        return YsSerializer;
    }();
    exports["default"] = YsSerializer;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var platform = __webpack_require__(334);
    var platformAbout = __webpack_require__(23);
    var platformBuildInfo = __webpack_require__(20);
    var platformClid = __webpack_require__(288);
    var branding = __webpack_require__(277);
    var settings = __webpack_require__(216);
    var tabsWatcher = __webpack_require__(309);
    var xhr = __webpack_require__(32);
    var xml = __webpack_require__(61);
    var barNavigThumbs = __webpack_require__(342);
    var logger = __webpack_require__(5).create("Statistics/bar-navig");
    var R1_SETTING = "r1String";
    exports.init = function() {
        tabsWatcher.events.onCompleted.addListener(onTabLoaded);
        barNavigThumbs.init();
    };
    function onTabLoaded(tabId, tab) {
        var url = tab.data && tab.data.url;
        if (settings.get("sendUsageStat") && utils.url.isRemote(url)) collectData(tabId, tab.data, url, trySendWithBackup);
    }
    function trySendWithBackup(params) {
        trySend(branding.statistics.barnavigPrimaryUrl, params, function(err) {
            if (err) trySend(branding.statistics.barnavigBackupUrl, params, logSendWithBackupErrors);
        });
    }
    function trySend(url, params, callback) {
        callback = callback || utils.noop;
        if (url) send(url, params, callback); else callback(new Error("Url is empty"));
    }
    function logSendWithBackupErrors(err) {
        if (err) logger.error("Problem in trySendWithBackup method: %o", err);
    }
    function send(url, params, callback) {
        logger.info("Sending bar-navig to %s: %j", url, params);
        xhr({
            url: url,
            withCredentials: true,
            parse: "xml",
            body: params
        }, function(error, xmlDoc) {
            if (error) {
                logger.error("Error while sending to %s: %s", url, error.message);
                callback(error);
            } else {
                updateR1(xmlDoc);
                callback();
            }
        });
    }
    function collectData(tabId, tabData, url, callback) {
        var params = getBaseParams();
        params.url = url;
        params.title = tabData.title || "";
        params.target = tabData.navInNewWindow ? "w" : tabData.navInExistingTab ? "c" : "t";
        var vtbNum = barNavigThumbs.getPosition(tabId, tabData.url);
        if ("number" === typeof vtbNum) params.vtbNum = vtbNum;
        var options = {
            tabId: tabId,
            isYandexHost: utils.url.isYandexHost(url)
        };
        platform.getBarnavigParams(options, function(platformParams) {
            if (platformParams) {
                params.referer = platformParams.referer || void 0;
                params.yamm = platformParams.yamm || void 0;
            }
            callback(params);
        });
    }
    function getBaseParams() {
        return {
            ver: platformBuildInfo.getVersion(),
            clid: platformClid.getByNumber(4) || platformClid.getByNumber(1),
            yasoft: platformAbout.yasoft,
            brandID: branding.getRegionBrandId(),
            ui: platform.guid,
            show: 1,
            urlinfo: 0,
            r1: settings.get(R1_SETTING) || void 0
        };
    }
    function updateR1(xmlDoc) {
        if (xmlDoc) {
            var r1 = xml.getText(xmlDoc, "urlinfo > r1");
            if (r1) settings.set(R1_SETTING, r1);
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var navigations = __webpack_require__(343);
    var settings = __webpack_require__(216);
    var tabsWatcher = __webpack_require__(309);
    var urlUtils = __webpack_require__(83);
    var CLEAR_DATA_DELAY_MS = 1e3;
    var thumbClicks = {};
    exports.init = function() {
        navigations.onThumbNavigated.addListener(onThumbNavigated);
        tabsWatcher.events.onCompleted.addListener(onTabLoaded);
    };
    exports.getPosition = function(tabId, url) {
        var thumbClick = thumbClicks[tabId];
        if (thumbClick && urlUtils.isEqualUrls(thumbClick.url, url)) {
            var position = thumbClick.position;
            clearTimeout(thumbClick.timeout);
            clear(tabId);
            return position;
        } else return null;
    };
    function onThumbNavigated(data) {
        if (settings.get("sendUsageStat")) thumbClicks[data.tabId] = {
            position: data.thumbPosition,
            url: data.url
        };
    }
    function onTabLoaded(tabId) {
        if (thumbClicks[tabId]) thumbClicks[tabId].timeout = setTimeout(clear.bind(null, tabId), CLEAR_DATA_DELAY_MS);
    }
    function clear(tabId) {
        delete thumbClicks[tabId];
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Navigations");
    var channel = __webpack_require__(27);
    var TARGET = exports.TARGET = {
        TAB: "tab",
        NEW_TAB: "new tab",
        NEW_ACTIVE_TAB: "new active tab",
        NEW_WINDOW: "new window"
    };
    exports.go = function(params) {
        params = params || {};
        var url = params.url;
        if (!url) {
            logger.error("Can not navigate empty url, params %j", params);
            return;
        }
        var isThumb = void 0 !== params.thumbPosition;
        if (isThumb) logger.info("Navigate to %s %s (from thumb %i)", params.target, url, params.thumbPosition); else logger.info("Navigate to %s %s", params.target, url);
        var callback = onNavigated.bind(null, params);
        switch (params.target) {
          case TARGET.TAB:
            chrome.tabs.update(params.tabId, {
                url: url
            }, callback);
            break;

          case TARGET.NEW_WINDOW:
            chrome.windows.create({
                url: url
            }, callback);
            break;

          case TARGET.NEW_ACTIVE_TAB:
            chrome.tabs.create({
                url: url,
                active: true
            }, callback);
            break;

          case TARGET.NEW_TAB:
          default:
            chrome.tabs.create({
                url: url,
                active: false
            }, callback);
        }
    };
    exports.onThumbNavigated = channel.create();
    function onNavigated(params, data) {
        if (void 0 !== params.thumbPosition) {
            var isWindow = Array.isArray(data.tabs);
            var dispatchData = {
                url: params.url,
                tabId: isWindow ? data.tabs[0].id : data.id,
                thumbPosition: params.thumbPosition
            };
            exports.onThumbNavigated.dispatch(dispatchData);
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var versions = __webpack_require__(345);
    var utils = __webpack_require__(30);
    var platformAbout = __webpack_require__(23);
    var getMigrationData = __webpack_require__(346);
    var migration223 = __webpack_require__(348);
    var logger = __webpack_require__(5).create("Startup/runstate");
    var STATES = {
        INSTALL: 0,
        UPGRADE: 1,
        NORMAL: 2
    };
    var state;
    var migrationData;
    var isReady = false;
    exports.detect = function(callback) {
        var previousVersion = versions.getPrevious();
        if (!previousVersion) initNoPrevVersion(callback); else initHasPrevVersion(previousVersion, callback);
    };
    exports.isInstall = function() {
        return state === STATES.INSTALL;
    };
    exports.isUpgrade = function() {
        return state === STATES.UPGRADE;
    };
    exports.isNormal = function() {
        return state === STATES.NORMAL;
    };
    exports.isReady = function() {
        return isReady;
    };
    exports.setReady = function() {
        isReady = true;
    };
    exports.getMigrationDataCommonBackend = function() {
        return migrationData;
    };
    function initNoPrevVersion(callback) {
        if (platformAbout.isChr || platformAbout.isFx) {
            state = STATES.INSTALL;
            callback();
        } else checkMigrationData223(callback);
    }
    function initHasPrevVersion(previousVersion, callback) {
        var currentVersion = versions.getCurrent();
        state = utils.versionCompare(currentVersion, previousVersion) > 0 ? STATES.UPGRADE : STATES.NORMAL;
        var isUpgradeToCommonBackend = exports.isUpgrade() && utils.versionCompare(previousVersion, migration223.COMMON_BACKЕND_VERSION) < 0;
        if (isUpgradeToCommonBackend) checkMigrationData223(callback); else callback();
    }
    function checkMigrationData223(callback) {
        getMigrationData(function(aMigrationData) {
            if (aMigrationData) {
                logger.info("Got migrationData: %j", aMigrationData);
                state = STATES.UPGRADE;
                migrationData = aMigrationData;
                migration223.migrateVersionsHistory(aMigrationData);
            } else {
                logger.info("Empty migrationData");
                state = STATES.INSTALL;
            }
            callback();
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var buildInfo = __webpack_require__(20);
    var logger = __webpack_require__(5).create("Startup/versions");
    var VERSIONS_SETTING_NAME = "versionsHistory";
    exports.getPrevious = function() {
        var versionsHistory = exports.getHistory();
        return getMainVersion(versionsHistory[versionsHistory.length - 1]);
    };
    exports.getCurrent = function() {
        return getMainVersion(buildInfo.getVersion());
    };
    exports.getHistory = function() {
        var versionsHistory = settings.get(VERSIONS_SETTING_NAME);
        return Array.isArray(versionsHistory) ? versionsHistory : [];
    };
    exports.addToHistory = function(version) {
        var versionsHistory = exports.getHistory();
        version = getMainVersion(version);
        if (versionsHistory.indexOf(version) >= 0) logger.error("Trying add version %s that already exists in history %j", version, versionsHistory); else {
            versionsHistory.push(version);
            logger.info("Add to versions history: %s", version);
            exports.setHistory(versionsHistory);
        }
    };
    exports.setHistory = function(versionsHistory) {
        if (Array.isArray(versionsHistory)) {
            versionsHistory = versionsHistory.map(getMainVersion);
            logger.info("Set versions history: %j", versionsHistory);
            settings.set(VERSIONS_SETTING_NAME, versionsHistory);
        } else logger.error("Trying to set versions history that is not array %j", versionsHistory);
    };
    function getMainVersion(version) {
        if (version && "string" === typeof version) {
            var matches = version.match(/(^\d+\.\d+(\.\d+)?)/);
            return matches ? matches[1] : "";
        } else return "";
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asyncLib = __webpack_require__(209);
    var logger = __webpack_require__(5).create("Platform/getMigrationData");
    var database = __webpack_require__(295);
    var fs = __webpack_require__(264);
    var md5 = __webpack_require__(347).md5;
    var urlUtils = __webpack_require__(83);
    module.exports = function(callback) {
        logger.info("Collecting migration data..");
        asyncLib.parallel({
            thumbsShown: loadTable.bind(null, "thumbs_shown"),
            thumbs: loadTable.bind(null, "thumbs"),
            users: loadTable.bind(null, "users"),
            userBackgroundPath: tryGetUserBackgroundPath
        }, function(err, results) {
            var users = formatUsers(results.users);
            var thumbs = mergeThumbs(results.thumbsShown, results.thumbs);
            fillScreenshots(thumbs, function() {
                var migrationData = {
                    thumbs: thumbs,
                    users: users,
                    userBackgroundPath: results.userBackgroundPath
                };
                logger.info("Collected migration data %j", migrationData);
                callback(migrationData);
            });
        });
    };
    function loadTable(tableName, callback) {
        database.get(tableName, {}, function(err, records) {
            if (err) logger.error("Error while load %s %s", tableName, err.message);
            callback(null, Array.isArray(records) ? records : []);
        });
    }
    function mergeThumbs(thumbsShown, thumbs) {
        return thumbsShown.map(function(thumbShown) {
            thumbShown.uri = urlUtils.createURI(thumbShown.url);
            return thumbShown;
        }).filter(function(thumbShown) {
            return Boolean(thumbShown.uri);
        }).map(function(thumbShown) {
            var uri = thumbShown.uri;
            var foundInThumbs = thumbs.filter(function(item) {
                return urlUtils.isEqualUrls(uri, item.url);
            })[0];
            if (foundInThumbs) logger.info("Merge (position, url, pinned) with (visits, title) : (%i %s %s) (%s %s)", thumbShown.position, thumbShown.url, thumbShown.pinned, foundInThumbs.visits, foundInThumbs.title); else logger.info("Not found in `thumbs` table: %i %s", thumbShown.position, thumbShown.url);
            return {
                position: parseInt(thumbShown.position, 10),
                url: thumbShown.url,
                pinned: thumbShown.pinned ? 1 : 0,
                title: foundInThumbs ? foundInThumbs.title : null,
                visits: foundInThumbs ? foundInThumbs.visits : 0
            };
        });
    }
    function fillScreenshots(thumbs, callback) {
        var dir = "/screenshots/";
        var tasks = thumbs.map(function(thumb) {
            var url = normalizeUrlOld(thumb.url);
            var filepath = dir + md5(url) + ".png";
            return function(callback) {
                fs.getFileUrl(filepath, function(err, screenshotUrl) {
                    if (!err && screenshotUrl) {
                        logger.info("Migrate screenshot for %s", thumb.url);
                        thumb.screenshotFsPath = filepath;
                        thumb.screenshotImage = screenshotUrl;
                    }
                    callback();
                });
            };
        });
        asyncLib.parallel(tasks, function() {
            callback(null, thumbs);
        });
    }
    function normalizeUrlOld(url) {
        var uri = urlUtils.createURI(url);
        if (!uri) return url;
        if ("" === uri.query()) {
            url = url.replace(/\?$/, "");
            if ("/" === uri.pathname()) url = url.replace(/\/$/, "");
        }
        return url;
    }
    function formatUsers(oldUsers) {
        return oldUsers.map(function(user) {
            var status = isNaN(user.status) ? 0 : user.status;
            return {
                displayName: user.displayName,
                lastAuthTime: user.lastAuthTime,
                login: user.login,
                uid: user.uid,
                hasAuth: status > 0,
                isDefault: 2 === status
            };
        });
    }
    function tryGetUserBackgroundPath(callback) {
        var pathBefore223 = "backgrounds/user.jpg";
        fs.getFileUrl(pathBefore223, function(err, url) {
            if (!err && url) callback(null, pathBefore223); else callback();
        });
    }
}, function(module, exports) {
    "use strict";
    exports.md5 = hex_md5;
    var hexcase = 0;
    function hex_md5(s) {
        return rstr2hex(rstr_md5(str2rstr_utf8(s)));
    }
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), 8 * s.length));
    }
    function rstr2hex(input) {
        try {} catch (e) {
            hexcase = 0;
        }
        var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
        var output = "";
        var x;
        for (var i = 0; i < input.length; i++) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt(x >>> 4 & 15) + hex_tab.charAt(15 & x);
        }
        return output;
    }
    function str2rstr_utf8(input) {
        var output = "";
        var i = -1;
        var x, y;
        while (++i < input.length) {
            x = input.charCodeAt(i);
            y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
            if (55296 <= x && x <= 56319 && 56320 <= y && y <= 57343) {
                x = 65536 + ((1023 & x) << 10) + (1023 & y);
                i++;
            }
            if (x <= 127) output += String.fromCharCode(x); else if (x <= 2047) output += String.fromCharCode(192 | x >>> 6 & 31, 128 | 63 & x); else if (x <= 65535) output += String.fromCharCode(224 | x >>> 12 & 15, 128 | x >>> 6 & 63, 128 | 63 & x); else if (x <= 2097151) output += String.fromCharCode(240 | x >>> 18 & 7, 128 | x >>> 12 & 63, 128 | x >>> 6 & 63, 128 | 63 & x);
        }
        return output;
    }
    function rstr2binl(input) {
        var output = Array(input.length >> 2);
        for (var i = 0; i < output.length; i++) output[i] = 0;
        for (var i = 0; i < 8 * input.length; i += 8) output[i >> 5] |= (255 & input.charCodeAt(i / 8)) << i % 32;
        return output;
    }
    function binl2rstr(input) {
        var output = "";
        for (var i = 0; i < 32 * input.length; i += 8) output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
        return output;
    }
    function binl_md5(x, len) {
        x[len >> 5] |= 128 << len % 32;
        x[(len + 64 >>> 9 << 4) + 14] = len;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        for (var i = 0; i < x.length; i += 16) {
            var olda = a;
            var oldb = b;
            var oldc = c;
            var oldd = d;
            a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
            d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
            a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
            d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return Array(a, b, c, d);
    }
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    function safe_add(x, y) {
        var lsw = (65535 & x) + (65535 & y);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | 65535 & lsw;
    }
    function bit_rol(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.VERSION = "2.23.0";
    var asyncLib = __webpack_require__(209);
    var logger = __webpack_require__(5).create("Migration " + exports.VERSION);
    var settings = __webpack_require__(216);
    var localBlacklist = __webpack_require__(349);
    var urlUtils = __webpack_require__(83);
    var database = __webpack_require__(295);
    var screenshots = __webpack_require__(350);
    var userBackground = __webpack_require__(353);
    var brandingBackgrounds = __webpack_require__(356);
    var FileStorage = __webpack_require__(263);
    var backgroundsStorage = __webpack_require__(354);
    var backgroundsFontColors = __webpack_require__(355);
    var platformAbout = __webpack_require__(23);
    var versions = __webpack_require__(345);
    var fs = new FileStorage("/");
    var COMMON_BACKEND_PREV_VERSION = "2.22.0";
    var migrationData = {};
    exports.COMMON_BACKЕND_VERSION = "2.23.0";
    exports.run = function(options, callback) {
        logger.info("Starting...");
        if (!options.migrationData) {
            logger.error("No migration data!");
            callback(new Error("No migration data!"));
        } else {
            migrationData = options.migrationData;
            migrateSettings();
            migrateAdvertisement();
            asyncLib.series([ migrateThumbs, migrateBlacklist, migrateUsers, migrateUserBackground, setBackgroundImagePath ], callback);
        }
    };
    exports.migrateVersionsHistory = function(aMigrationData) {
        if (!platformAbout.isChr && !platformAbout.isFx) {
            var value = aMigrationData && aMigrationData.settings && aMigrationData.settings.versionsHistory;
            value = Array.isArray(value) && value.length ? value : [ COMMON_BACKEND_PREV_VERSION ];
            versions.setHistory(value);
        }
    };
    function migrateSettings() {
        if (migrationData.settings) {
            logger.info("Migrating settings..");
            migrateSetting("appInstallTime", "number");
            migrateSetting("backgroundImage", "string");
            migrateSetting("lastDayUseSendTime", "number");
            migrateSetting("maxAvailableIncreased", "boolean");
            migrateSetting("showBookmarks", "boolean");
            migrateSetting("showSearchForm", "boolean");
            migrateSetting("showAdvertisement", "boolean");
            migrateSetting("uiThumbsType", "number");
        } else logger.warn("No `settings` key in migrationData");
    }
    function migrateSetting(name, type) {
        var value = migrationData.settings[name];
        if (("undefined" === typeof value ? "undefined" : _typeof(value)) === type) {
            settings.set(name, value);
            logger.info("Migrate setting: %s with value %s", name, value);
        } else logger.warn("Incorrect type of setting %s: got %s, expected %s", name, "undefined" === typeof value ? "undefined" : _typeof(value), type);
    }
    function setBackgroundImagePath(callback) {
        var backgroundId = settings.get("backgroundImage");
        var brandedBackgrounds = brandingBackgrounds.getBackgrounds();
        if (backgroundId) if (backgroundId in brandedBackgrounds) {
            var url = brandedBackgrounds[backgroundId].image;
            writeBackgroundImagePath(url);
            calcBackgroundImageFontColor(backgroundId, url, callback);
        } else backgroundsStorage.getLocalUrl(backgroundId, function(err, data) {
            if (!err && data && data.url) {
                writeBackgroundImagePath(data.url);
                calcBackgroundImageFontColor(backgroundId, data.url, callback);
            } else {
                logger.warn("Error while setting backgroundImagePath for id %s %s", backgroundId, err && err.message);
                callback();
            }
        }); else {
            logger.warn("Can not set backgroundImagePath as backgroundImage is empty");
            callback();
        }
    }
    function writeBackgroundImagePath(path) {
        logger.info("backgroundImagePath set to %s", path);
        settings.set("backgroundImagePath", path);
    }
    function calcBackgroundImageFontColor(backgroundId, backgroundUrl, callback) {
        backgroundsFontColors.get(backgroundId, backgroundUrl, function() {
            callback();
        });
    }
    function migrateBlacklist(callback) {
        if (Array.isArray(migrationData.blacklist)) {
            logger.info("Migrating blacklist..");
            var domains = migrationData.blacklist.filter(Boolean).map(urlUtils.getNormalDomain);
            var tasks = domains.map(function(domain) {
                return function(callback) {
                    localBlacklist.upsertOne(domain, function() {
                        callback();
                    });
                };
            });
            asyncLib.series(tasks, callback);
        } else {
            logger.warn("No `blacklist` key in migrationData");
            callback();
        }
    }
    function migrateThumbs(callback) {
        if (Array.isArray(migrationData.thumbs) && migrationData.thumbs.length) {
            logger.info("Migrating thumbs: %i", migrationData.thumbs.length);
            var tableName = "thumbs_shown";
            var dbItems = migrationData.thumbs.filter(function(item) {
                return item && item.url;
            }).map(function(item, position) {
                var dbItem = {
                    url: item.url,
                    position: position,
                    pinned: item.pinned ? 1 : 0,
                    title: item.title,
                    visits: isNaN(item.visits) ? 0 : item.visits
                };
                if (item.screenshotFsPath) dbItem.screenshotFsPath = item.screenshotFsPath;
                if (item.screenshotImage) dbItem.screenshotImage = item.screenshotImage;
                return dbItem;
            });
            dbItems = limitThumbsCount(dbItems);
            calcScreenshotData(dbItems, function() {
                dbItems.forEach(function(dbItem) {
                    logger.info("Upserting item %i %s %j", dbItem.position, dbItem.url, dbItem);
                });
                database.upsert(tableName, dbItems, function(err) {
                    if (err) {
                        logger.error("Error while upsert items: %s %j", err.message, dbItems);
                        callback();
                    } else cleanUnusedThumbs(dbItems.length, function() {
                        callback();
                    });
                });
            });
        } else {
            logger.warn("No correct `thumbs` key in migrationData");
            callback();
        }
    }
    function limitThumbsCount(dbItems) {
        var maxCount = settings.get("maxAvailableIncreased") ? 49 : 25;
        if (dbItems.length > maxCount) {
            logger.info("Limit thumbs count from %i to %i", dbItems.length, maxCount);
            return dbItems.slice(0, maxCount);
        } else return dbItems;
    }
    function cleanUnusedThumbs(currentCount, callback) {
        logger.info("Deleting thumbs with position >= %i", currentCount);
        database.get("thumbs_shown", {}, function(err, records) {
            if (err) callback(err); else {
                records = records || [];
                var positionsToDelete = records.filter(function(record) {
                    return record && record.position >= currentCount;
                }).map(function(record) {
                    return record.position;
                });
                logger.info("Deleting positions: %s", positionsToDelete);
                database.delete("thumbs_shown", positionsToDelete, function(err) {
                    if (err) logger.warn("Can not delete positions %s", err.message);
                    callback();
                });
            }
        });
    }
    function calcScreenshotData(dbItems, callback) {
        var tasks = dbItems.filter(function(dbItem) {
            return Boolean(dbItem.screenshotFsPath);
        }).map(function(dbItem) {
            var getLocalUrl = function(callback) {
                if (dbItem.screenshotImage) callback(null, dbItem.screenshotImage); else fs.getLocalUrl(dbItem.screenshotFsPath, callback);
            };
            var calcColors = function(screenshotUrl, callback) {
                if (!screenshotUrl) {
                    logger.error("Empty localUrl for %s with path %s", dbItem.url, dbItem.screenshotFsPath);
                    callback(new Error("Empty localUrl"));
                    return;
                } else logger.info("Got screenshot localUrl for %s %s", dbItem.url, screenshotUrl);
                dbItem.screenshotImage = screenshotUrl;
                screenshots.calcScreenshotColorsByUrl(screenshotUrl, function(err, colorData) {
                    if (err) {
                        logger.error(err.message);
                        callback(err);
                    } else {
                        logger.info("Calculated screenshot colors for %s %j", dbItem.url, colorData);
                        dbItem.screenshotFontColor = colorData.fontColor;
                        dbItem.screenshotBgColor = colorData.bgColor;
                        dbItem.screenshotUpdateTime = Date.now();
                        callback();
                    }
                });
            };
            return function(callback) {
                asyncLib.waterfall([ getLocalUrl, calcColors ], function() {
                    callback();
                });
            };
        });
        asyncLib.parallel(tasks, callback);
    }
    function migrateUsers(callback) {
        if (Array.isArray(migrationData.users)) {
            logger.info("Migrating users: %i", migrationData.users.length);
            var dbUsers = migrationData.users.filter(function(user) {
                return user && user.uid;
            }).map(function(user) {
                var dbUser = {
                    name: user.displayName || "",
                    lastAuthTime: user.lastAuthTime || 0,
                    login: user.login,
                    uid: user.uid,
                    hasAuth: Boolean(user.hasAuth),
                    isDefault: Boolean(user.isDefault)
                };
                logger.info("Migrating user: %s %s", dbUser.uid, dbUser.name);
                return dbUser;
            });
            database.clearAndInsert("users", dbUsers, function(err) {
                if (err) logger.error("Error while inserting users %s %j", err.message, dbUsers);
                callback();
            });
        } else {
            logger.warn("No `users` key in migrationData");
            callback();
        }
    }
    function migrateAdvertisement() {
        if (migrationData.advertisement && migrationData.advertisement.blocks) {
            var result = {
                lastShownBlockId: migrationData.advertisement.lastShownBlockId || null,
                blocks: {}
            };
            var blocks = migrationData.advertisement.blocks;
            var excludeBlocks = [ "vbadbbdoc", "vbadbbnewver", "vbadbbnewverrun" ];
            Object.keys(blocks).filter(function(blockId) {
                return excludeBlocks.indexOf(blockId) === -1;
            }).forEach(function(blockId) {
                result.blocks[blockId] = {
                    lastShown: blocks[blockId].lastShown || 0,
                    refuseCount: blocks[blockId].refuseCount || 0,
                    shownCount: blocks[blockId].shownCount || 0
                };
            });
            settings.set("advertisementState", result);
        } else logger.warn("No `advertisement / blocks` key in migrationData");
    }
    function migrateUserBackground(callback) {
        var oldPath = migrationData.userBackgroundPath;
        var newPath = userBackground.getUserFilePath();
        if (!oldPath || oldPath === newPath) callback(); else {
            logger.info("Migrating user background from %s to %s", oldPath, newPath);
            moveFileSafe(oldPath, newPath, callback);
        }
    }
    function moveFileSafe(oldPath, newPath, callback) {
        fs.move(oldPath, newPath, function(error) {
            if (error) logger.error("Error while moving file %s to %s: %j", oldPath, newPath, error);
            callback();
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var database = __webpack_require__(295);
    var logger = __webpack_require__(5).create("Blacklist/local");
    var pluck = __webpack_require__(156);
    var TABLE_NAME = "blacklist";
    module.exports = {
        get: function(callback) {
            database.get(TABLE_NAME, {}, function(error, result) {
                callback(error, pluck(result, "domain"));
            });
        },
        upsertOne: function(domain, callback) {
            logger.info("Adding: %s", domain);
            database.upsert(TABLE_NAME, {
                domain: domain
            }, function(err) {
                if (err) logger.error("Can not upsert domain %s %s", domain, err.message);
                if (callback) callback(err);
            });
        },
        deleteOne: function(domain, callback) {
            logger.info("Removing: %s", domain);
            database.delete(TABLE_NAME, domain, function(err) {
                if (err) logger.error("Can not delete domain %s %s", domain, err.message);
                if (callback) callback(err);
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asyncLib = __webpack_require__(209);
    var _ = __webpack_require__(91);
    var watcher = __webpack_require__(351);
    var cache = __webpack_require__(292);
    var collection = __webpack_require__(270);
    var logger = __webpack_require__(5).create("Screenshots");
    var dateUtils = __webpack_require__(4);
    var colorUtils = __webpack_require__(259);
    var fileUtils = __webpack_require__(266);
    var FileStorage = __webpack_require__(263);
    var urlUtils = __webpack_require__(83);
    var adjustScreenshot = __webpack_require__(352);
    var loadImage = __webpack_require__(224);
    var storage;
    var SCREENSHOT_FORMAT = "png";
    var COLLECTION_ON_CHANGED_DELAY_MS = 300;
    exports.SCREENSHOT_DIR = "screenshots";
    exports.init = function() {
        storage = new FileStorage(exports.SCREENSHOT_DIR);
        watcher.init();
        watcher.onUpdated.addListener(handleWatcherUpdate);
        collection.onChanged.addListener(_.debounce(updateWatchListByCollection, COLLECTION_ON_CHANGED_DELAY_MS));
        collection.onLoaded.addListener(updateWatchListByCollection);
    };
    exports.clearCache = cache.clear.bind(cache);
    exports.calcScreenshotColorsByUrl = function(screenshotUrl, callback) {
        loadImage({
            url: screenshotUrl
        }, function(error, img) {
            if (error) callback(error); else {
                var result = {
                    bgColor: colorUtils.getDominant(img, {
                        bottomQuarter: false,
                        preventSkipColors: false
                    })
                };
                result.fontColor = colorUtils.getFontOverlayColorForBackgroundColor(result.bgColor);
                callback(null, result);
            }
        });
    };
    function updateWatchListByCollection() {
        cache.updateFromThumbs(collection.items);
        addThumbsToWatchList(collection.items);
    }
    function addThumbsToWatchList(thumbs) {
        watcher.clearWatchList();
        thumbs.forEach(function(thumb) {
            watcher.addToWatchList(thumb.url);
        });
    }
    function handleWatcherUpdate(tabId, matchedUrls) {
        var thumbsForUpdate = getThumbsForUpdate(matchedUrls);
        if (0 === thumbsForUpdate.length) return;
        var cachedScreenshotData = cache.getFirstMatch(matchedUrls);
        if (cachedScreenshotData && !isThumbScreenshotOld(cachedScreenshotData)) {
            updateThumbs(thumbsForUpdate, cachedScreenshotData);
            return;
        }
        ifTabAllowedForCapturing(tabId, function(tab) {
            startCaptureTabFlow(tab, thumbsForUpdate);
        });
    }
    function getThumbsForUpdate(matchedUrls) {
        return collection.items.filter(function(thumb) {
            return isThumbScreenshotOld(thumb) && urlUtils.isUrlInList(thumb.url, matchedUrls);
        });
    }
    function isThumbScreenshotOld(thumb) {
        return !thumb.screenshotUpdateTime || Date.now() - thumb.screenshotUpdateTime > dateUtils.DAY_MS;
    }
    function ifTabAllowedForCapturing(tabId, callback) {
        chrome.tabs.get(tabId, function(tab) {
            if (tab.active && !tab.incognito) callback(tab);
        });
    }
    function startCaptureTabFlow(tab, thumbsForUpdate) {
        logger.info("Capture tab %s", tab.url);
        asyncLib.waterfall([ function(callback) {
            chrome.tabs.captureVisibleTab(tab.windowId, {
                format: SCREENSHOT_FORMAT
            }, function(dataUrl) {
                callback(chrome.runtime.lastError, dataUrl);
            });
        }, function(dataURL, callback) {
            adjustScreenshot(dataURL, callback);
        }, function(dataURI, callback) {
            var data = {
                screenshotName: createScreenshotName(thumbsForUpdate)
            };
            storage.saveDataURI(dataURI, data.screenshotName, function(error, storageData) {
                data.screenshotImage = storageData.url;
                data.screenshotFsPath = storageData.path;
                callback(error, data);
            });
        }, function(data, callback) {
            exports.calcScreenshotColorsByUrl(data.screenshotImage, function(error, colorData) {
                if (error) callback(error); else {
                    data.screenshotFontColor = colorData.fontColor;
                    data.screenshotBgColor = colorData.bgColor;
                    data.screenshotUpdateTime = Date.now();
                    updateThumbs(thumbsForUpdate, data);
                    callback();
                }
            });
        } ], function(error) {
            if (error) logger.warn("Error in capture tab flow: %j", error);
        });
    }
    function createScreenshotName(thumbs) {
        var existingName = getExistingScreenshotName(thumbs);
        if (existingName) return existingName; else return getScreenshotNamePrefix(thumbs) + Date.now() + Math.random();
    }
    function getExistingScreenshotName(thumbs) {
        for (var i = 0; i < thumbs.length; i++) {
            var thumb = thumbs[i];
            if (thumb.screenshotFsPath) return fileUtils.extractName(thumb.screenshotFsPath);
        }
        return null;
    }
    function getScreenshotNamePrefix(thumbs) {
        return thumbs[0] ? urlUtils.getNormalDomain(thumbs[0].url) : "";
    }
    function updateThumbs(thumbsForUpdate, screenshotData) {
        thumbsForUpdate.forEach(function(thumb) {
            logger.info("Add screenshot data to thumb %s: %j", thumb.url, screenshotData);
            _.merge(thumb, screenshotData);
            thumb.onChanged.dispatch(thumb);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var Channel = __webpack_require__(27);
    var urlUtils = __webpack_require__(83);
    var _require = __webpack_require__(309), tabsWatcher = _require.watcher;
    var urlsToWatchMap = new Map();
    var tabsTimeouts = new Map();
    var collection = null;
    var DELAY_MS = 2e3;
    exports.init = function() {
        collection = tabsWatcher.storage.query(query);
        collection.forEach(createTabUpdateTask);
        collection.onUpdated.add(function(collection, changes) {
            return onCollectionUpdated(changes);
        });
    };
    exports.addToWatchList = function(url) {
        urlsToWatchMap.set(url, normalizeUrl(url));
        collection.reload();
    };
    exports.clearWatchList = function() {
        urlsToWatchMap.clear();
        collection.reload();
    };
    exports.onUpdated = new Channel();
    function query(tab) {
        if (!tab.data.active || !tab.isComplete || tab.data.incognito) return false;
        return tab.navigation.getNavigationStack().some(matchSingleUrl);
    }
    function onCollectionUpdated(_ref) {
        var _ref$inserted = _ref.inserted, inserted = void 0 === _ref$inserted ? [] : _ref$inserted, _ref$excluded = _ref.excluded, excluded = void 0 === _ref$excluded ? [] : _ref$excluded, _ref$removed = _ref.removed, removed = void 0 === _ref$removed ? [] : _ref$removed, _ref$updated = _ref.updated, updated = void 0 === _ref$updated ? [] : _ref$updated;
        excluded.concat(removed).forEach(releaseTabUpdateTask);
        inserted.concat(updated).forEach(createTabUpdateTask);
    }
    function releaseTabUpdateTask(_ref2) {
        var tabId = _ref2.id;
        if (!tabsTimeouts.has(tabId)) return;
        clearTimeout(tabsTimeouts.get(tabId));
        tabsTimeouts.delete(tabId);
    }
    function createTabUpdateTask(tab) {
        var tabId = tab.id;
        clearTimeout(tabsTimeouts.get(tabId));
        var timeoutId = setTimeout(function() {
            return sendEvent(tab);
        }, DELAY_MS);
        tabsTimeouts.set(tabId, timeoutId);
    }
    function sendEvent(tab) {
        var urls = tab.navigation.getNavigationStack();
        exports.onUpdated.dispatch(tab.id, getMatchedUrls(urls));
    }
    function matchSingleUrl(testUrl) {
        testUrl = normalizeUrl(testUrl);
        return Array.from(urlsToWatchMap.values()).some(function(url) {
            return urlUtils.isEqualUrls(url, testUrl);
        });
    }
    function getMatchedUrls(testUrls) {
        testUrls = testUrls.map(normalizeUrl);
        return Array.from(urlsToWatchMap).filter(function(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2), url = _ref4[1];
            return testUrls.some(function(testUrl) {
                return urlUtils.isEqualUrls(url, testUrl);
            });
        }).map(function(_ref5) {
            var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
            return key;
        });
    }
    function normalizeUrl(url) {
        return urlUtils.getNormalUrl(url, {
            www: true,
            protocol: true
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var loadImage = __webpack_require__(224);
    var WIDTH = 300;
    var HEIGHT = 150;
    var SCROLL_WIDTH = 10;
    var SCREENSHOT_FORMAT = "image/png";
    module.exports = function(imageUrl, callback) {
        loadImage({
            url: imageUrl
        }, function(error, imgElement) {
            if (error) callback(error); else adjustImage(imgElement, callback);
        });
    };
    function adjustImage(img, callback) {
        var ctx1 = create2DContext(.5 * img.width, .5 * img.height);
        ctx1.drawImage(img, 0, 0, ctx1.canvas.width, ctx1.canvas.height);
        var ctx2 = create2DContext(WIDTH, HEIGHT);
        var srcWidth = ctx1.canvas.width - SCROLL_WIDTH;
        var destHeight = Math.ceil(ctx1.canvas.height * WIDTH / ctx1.canvas.width);
        ctx2.drawImage(ctx1.canvas, 0, 0, srcWidth, ctx1.canvas.height, 0, 0, WIDTH, destHeight);
        callback(null, ctx2.canvas.toDataURL(SCREENSHOT_FORMAT));
    }
    function create2DContext(width, height) {
        var canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas.getContext("2d");
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var storage = __webpack_require__(354);
    var logger = __webpack_require__(5).create("UserBackground");
    var urlUtils = __webpack_require__(83);
    var asyncLib = __webpack_require__(209);
    var loadImage = __webpack_require__(224);
    var fontColors = __webpack_require__(355);
    var TEMP_USER_IMAGE_ID = "usertmp";
    var USER_IMAGE_ID = "user";
    exports.download = function(url, sendResponse) {
        storeUserImage(storage.download.bind(storage), url, sendResponse);
    };
    exports.copy = function(path, sendResponse) {
        storeUserImage(storage.copy.bind(storage), path, sendResponse);
    };
    exports.getFromMap = function(localFilesMap) {
        if (USER_IMAGE_ID in localFilesMap) {
            var localUrl = urlUtils.addRandomParam(localFilesMap[USER_IMAGE_ID]);
            return constructBackgroundObject(localUrl);
        }
        return null;
    };
    exports.getFromStorage = function(callback) {
        storage.getLocalUrl(USER_IMAGE_ID, function(error, fileData) {
            callback(error, error ? null : urlUtils.addRandomParam(fileData.url));
        });
    };
    exports.getUserFilePath = function() {
        return storage.getFilePath(USER_IMAGE_ID);
    };
    function storeUserImage(storeMethod, path, sendResponse) {
        asyncLib.waterfall([ function(callback) {
            logger.info("Dropping color cache for user background");
            fontColors.clearCached(USER_IMAGE_ID);
            logger.info("Saving user background to temporary file");
            storeMethod(path, TEMP_USER_IMAGE_ID, callback);
        }, function(storageData, callback) {
            logger.info("Checking that file is an image");
            if (storageData.url.startsWith("filesystem")) callback(null, storageData); else loadImage({
                url: storageData.url,
                noCache: true
            }, function(error, img) {
                if (!error && (!img || 0 === img.width)) error = new Error("Incorrect user image");
                callback(error, storageData);
            });
        }, function(storageData, callback) {
            logger.info("Copying temporary file");
            storage.copy(storageData.path, USER_IMAGE_ID, callback);
        }, function(storageData, callback) {
            logger.info("Removing temporary file");
            storage.remove(TEMP_USER_IMAGE_ID, function(error) {
                callback(error, storageData);
            });
        } ], function(error, storageData) {
            if (error) {
                logger.error("Error while saving user background: %j", error);
                sendResponse(null);
            } else {
                logger.info("User background has been successfully stored");
                sendResponse(urlUtils.addRandomParam(storageData.url));
            }
        });
    }
    function constructBackgroundObject(localUrl) {
        return {
            id: USER_IMAGE_ID,
            preview: localUrl,
            image: localUrl,
            isUser: true
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var FileStorage = __webpack_require__(263);
    module.exports = new FileStorage("backgrounds");
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var COLOR_CACHE_SETTINGS = "backgroundImagesFontColors";
    var utils = __webpack_require__(30);
    var colorUtils = __webpack_require__(259);
    var settings = __webpack_require__(216);
    var logger = __webpack_require__(5).create("Backgrounds/font-colors");
    exports.DEFAULT_COLOR = colorUtils.OVERLAY_COLOR_BLACK;
    exports.getAll = function() {
        return settings.get(COLOR_CACHE_SETTINGS) || {};
    };
    exports.setAll = function(cacheStorage) {
        if (cacheStorage && "object" === ("undefined" === typeof cacheStorage ? "undefined" : _typeof(cacheStorage)) && !Array.isArray(cacheStorage)) settings.set(COLOR_CACHE_SETTINGS, cacheStorage); else logger.error("Invalid data passed to setAll: %j", cacheStorage);
    };
    exports.getCached = function(backgroundId) {
        var cacheStorage = exports.getAll();
        return cacheStorage[backgroundId];
    };
    exports.setCached = function(backgroundId, fontColor) {
        var cacheStorage = exports.getAll();
        cacheStorage[backgroundId] = fontColor;
        logger.info("Saved font color %s for background id: %s", fontColor, backgroundId);
        exports.setAll(cacheStorage);
    };
    exports.clearCached = function(backgroundId) {
        var cacheStorage = exports.getAll();
        if (cacheStorage[backgroundId]) {
            delete cacheStorage[backgroundId];
            exports.setAll(cacheStorage);
        }
    };
    exports.get = function(backgroundId, backgroundUrl, callback) {
        callback = callback || utils.noop;
        var cachedColor = exports.getCached(backgroundId);
        if (!cachedColor) calculateColor(backgroundId, backgroundUrl, callback); else callback(cachedColor);
    };
    function calculateColor(backgroundId, backgroundUrl, callback) {
        colorUtils.calculateFontColorByUrl(backgroundUrl, function(color) {
            logger.info("Calculated font color %s for background id: %s", color, backgroundId);
            exports.setCached(backgroundId, color);
            callback(color);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var branding = __webpack_require__(277);
    var logger = __webpack_require__(5).create("Branding backgrounds");
    exports.getBackgrounds = function() {
        return branding.backgrounds.items.reduce(function(result, brandedBg, index) {
            if (brandedBg.image && brandedBg.id) result[brandedBg.id] = constructBackgroundObject(brandedBg, index);
            return result;
        }, {});
    };
    exports.getBackground = function(id) {
        return exports.getBackgrounds()[id];
    };
    exports.getDefaultBackground = function() {
        if (!branding.backgrounds.selected) {
            logger.error("Default background is empty");
            return null;
        }
        var bgList = exports.getBackgrounds();
        var keys = Object.keys(bgList);
        if (!keys.length) {
            logger.error("No backgrounds found");
            return null;
        }
        var result = bgList[branding.backgrounds.selected];
        if (!result) logger.error("No default background in branding");
        return result;
    };
    function constructBackgroundObject(brandedBg, index) {
        return {
            id: brandedBg.id,
            index: index,
            preview: brandedBg.preview || brandedBg.image,
            image: brandedBg.image,
            color: brandedBg.color || "",
            branded: true
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var browserInfo = __webpack_require__(22);
    var branding = __webpack_require__(277);
    var ExperimentConfig = __webpack_require__(358);
    var urlUtils = __webpack_require__(83);
    var logger = __webpack_require__(5).create("Experiments/configs");
    var configs = __webpack_require__(359);
    var actualConfigs;
    exports.get = function() {
        return actualConfigs || (actualConfigs = getActualConfigs());
    };
    exports.tryForceTestId = function(callback) {
        chrome.tabs.query({}, function(tabs) {
            var testId = tabs.map(function(tab) {
                var uri = urlUtils.createURI(tab.url);
                var isValidHost = false;
                try {
                    isValidHost = uri && ("extensions" === uri.hostname() || "localhost" === uri.hostname());
                } catch (e) {}
                return isValidHost ? uri.search(true).testid : "";
            }).filter(Boolean)[0];
            trySetConfigWithTestId(testId);
            callback();
        });
    };
    function getActualConfigs() {
        return configs.reduce(function(result, config) {
            if (!isDisabled(config)) result.push(new ExperimentConfig(config));
            return result;
        }, []);
    }
    function isDisabled(config) {
        return isDisabledForPlatform(config) || isDisabledForBranding(config);
    }
    function isDisabledForPlatform(config) {
        return config.platforms && config.platforms.indexOf(browserInfo.platformId) === -1;
    }
    function isDisabledForBranding(config) {
        return config.brandings && config.brandings.indexOf(branding.vars.regionId) === -1;
    }
    function trySetConfigWithTestId(testId) {
        if (!testId) return;
        var suitableConfigs = configs.filter(function(config) {
            return Boolean(config.types[testId]);
        });
        if (0 === suitableConfigs.length) logger.error("No configs with testid: %s", testId); else if (1 === suitableConfigs.length) {
            var config = suitableConfigs[0];
            config.percent = 100;
            var newTypes = {};
            newTypes[testId] = config.types[testId];
            config.types = newTypes;
            actualConfigs = [ new ExperimentConfig(config) ];
            logger.info("Force experiment %s with testid: %s", config.name, testId);
        } else logger.error("Several configs with testid: %s", testId);
    }
}, function(module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var ExperimentConfig = function ExperimentConfig(config) {
        _classCallCheck(this, ExperimentConfig);
        assertConfig(config);
        this.name = config.name;
        this.types = config.types;
        this.percent = config.percent || 100;
        this.startTime = config.startTime || 0;
        this.endTime = config.endTime;
        this.installOnly = config.installOnly;
    };
    exports["default"] = ExperimentConfig;
    var REQUIRED_PROPS = [ "name", "types", "endTime" ];
    function assertConfig(config) {
        if (!config || !isPropsExist(config, REQUIRED_PROPS)) throw new Error("Config must be correct!");
    }
    function isPropsExist(config, props) {
        return props.every(function(propName) {
            return void 0 !== config[propName];
        });
    }
    module.exports = exports["default"];
}, function(module, exports) {
    "use strict";
    module.exports = [];
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var messaging = __webpack_require__(213);
    var debug = __webpack_require__(361);
    var utils = __webpack_require__(30);
    var logger = __webpack_require__(5).create("Frontend/debug-panel");
    var tabUtils = __webpack_require__(282);
    var alarms = __webpack_require__(3);
    var platformAbout = __webpack_require__(23);
    var events = __webpack_require__(268);
    var thenChrome = __webpack_require__(283);
    var commandsMap = {
        toggleDebugMode: function(tabId) {
            settings.set("debugMode", !settings.get("debugMode"));
            chrome.tabs.reload(tabId);
        },
        reinstall: function(tabId) {
            debug.reset().then(function() {
                return thenChrome.tabs.reload(tabId);
            }).then(function() {
                return debug.reload();
            });
        },
        reload: function() {
            debug.reload();
        },
        show: function(tabId, param) {
            debug.show[param]();
        },
        "run|pickup": function() {
            alarms.trigger("pickup");
        },
        open: function(tabId, count, url) {
            openTabs(count, url);
        },
        clear: function(tabId, param) {
            debug.clear[param]();
        },
        "clear|history": function() {
            chrome.history.deleteAll(utils.noop);
        },
        "clear|tabs": function() {
            removeTabs();
        }
    };
    exports.init = function() {
        messaging.on(events.frontend.DEBUG_COMMAND, function(req, sender) {
            runCommand(req.command, sender.tab.id);
        });
        messaging.on(events.frontend.DEBUG_SHOW, function(req, sender) {
            exports.send(sender.tab.id);
        });
    };
    exports.send = function(tabId) {
        messaging.send(events.backend.DEBUG_PANEL, getItems(), tabId);
    };
    function getItems() {
        return [ {
            text: "переустановить ВЗ",
            command: "reinstall"
        }, {
            text: "перезагрузить фоновую страницу",
            command: "reload"
        }, {
            text: "закрыть лишние табы (кроме вз и extensions)",
            command: "clear|tabs"
        }, {
            text: (settings.get("debugMode") ? "отключить" : "включить") + " режим отладки",
            command: "toggleDebugMode"
        }, {
            text: "показать",
            children: [ {
                text: "лог",
                command: "show|log"
            }, {
                text: "настройки",
                command: "show|settings"
            }, {
                text: "видимые тумбы",
                command: "show|thumbs"
            }, {
                text: "кеш автоподбора",
                command: "show|pickupcache"
            }, {
                text: "блэклист пользователя",
                command: "show|blacklistUser"
            }, {
                text: "блэклист сервера",
                command: "show|blacklistServer"
            }, {
                text: "состояние рекламы",
                command: "show|adv"
            }, {
                text: "фоны",
                command: "show|bg"
            }, {
                text: "брендинг",
                command: "show|branding"
            }, {
                text: "кастомный брендинг",
                command: "show|custombranding"
            }, {
                text: "локальные файлы",
                command: "show|files"
            }, {
                text: "эксперименты",
                command: "show|experiments"
            } ]
        }, {
            text: "запустить",
            children: [ {
                text: "автоподбор",
                command: "run|pickup"
            } ]
        }, {
            text: "открыть",
            children: [ {
                text: "3 mail.ru",
                command: "open|3|http://mail.ru"
            }, {
                text: "3 lenta.ru",
                command: "open|3|http://lenta.ru"
            }, {
                text: "6 поискслов.рф/term/природа",
                command: "open|6|http://поискслов.рф/term/природа"
            }, {
                text: "7 habrahabr.ru",
                command: "open|7|http://habrahabr.ru"
            }, {
                text: "8 www.java.com/ru/download/faq/remove_olderversions.xml",
                command: "open|8|http://www.java.com/ru/download/faq/remove_olderversions.xml"
            }, {
                text: "8 http://www.java.com/ru/download/help/disable_browser.xml",
                command: "open|8|http://www.java.com/ru/download/help/disable_browser.xml"
            }, {
                text: "9 ya.ru",
                command: "open|9|https://ya.ru"
            }, {
                text: "10 ton-2006.happy-masters.ru/slovar.html",
                command: "open|10|http://ton-2006.happy-masters.ru/slovar.html"
            }, {
                text: "6 about:config",
                command: "open|6|about:config"
            }, {
                text: "6 chrome://extensions",
                command: "open|6|chrome://extensions"
            }, {
                text: "7 www.dojki.com",
                command: "open|7|http://www.dojki.com"
            }, {
                text: "7 signin.ebay.com",
                command: "open|7|https://signin.ebay.com"
            } ]
        }, {
            text: "очистить",
            children: [ {
                text: "бэкап",
                command: "clear|backup"
            }, {
                text: "настройки",
                command: "clear|settings"
            }, {
                text: "базу",
                command: "clear|db"
            }, {
                text: "историю",
                command: "clear|history"
            }, {
                text: "лишние табы (кроме вз и extensions)",
                command: "clear|tabs"
            } ]
        } ];
    }
    function runCommand(command, tabId) {
        var parts = command.split("|");
        var baseCommand = parts.shift();
        if (commandsMap[command]) commandsMap[command](); else if (commandsMap[baseCommand]) commandsMap[baseCommand].apply(null, [ tabId ].concat(parts)); else logger.error("Command not found: %s", command);
    }
    function openTabs(count, url) {
        for (var i = 0; i < count; i++) chrome.tabs.create({
            url: url,
            active: false
        });
    }
    function removeTabs() {
        tabUtils.getOpen(function(err, tabs) {
            var extensionsTabFound = false;
            tabs.forEach(function(tab) {
                if (tab.url === platformAbout.visbookmarksUrl) return;
                if ("chrome://extensions/" === tab.url && !extensionsTabFound) {
                    extensionsTabFound = true;
                    return;
                }
                chrome.tabs.remove(tab.id, utils.noop);
            });
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var files = __webpack_require__(362);
    var log = __webpack_require__(363);
    var advertisement = __webpack_require__(368);
    var _ = __webpack_require__(91);
    var dateUtils = __webpack_require__(4);
    var buildData = __webpack_require__(218);
    var backup = __webpack_require__(411);
    var platformAbout = __webpack_require__(23);
    var tabOpener = __webpack_require__(365);
    var state = __webpack_require__(420);
    var database = __webpack_require__(295);
    var platformBranding = __webpack_require__(278);
    var branding = __webpack_require__(277);
    var remoteBrandingStorage = __webpack_require__(291);
    var experiments = __webpack_require__(328);
    var backgroundSelector = __webpack_require__(384);
    var help = [ [ "npm.*", "доступ к npm-овским модулям, например debug.npm.URI" ], [ "modules.*", "доступ к модулям, например debug.modules.settings.settings.get(...)" ], [ "utils.*", "доступ к утилитам" ], [ "platform.*", "доступ к платформе" ] ];
    var debug = module.exports = {};
    var getters = debug.getters = _.extend({}, __webpack_require__(421));
    addCommand("help", "помощь", function() {
        console.log("----- DEBUG COMMANDS -----");
        help.sort(function(a, b) {
            return a[0] > b[0] ? 1 : -1;
        });
        var maxLength = 0;
        help.forEach(function(h) {
            maxLength = h[0].length > maxLength ? h[0].length : maxLength;
        });
        maxLength += 4;
        help.forEach(function(h) {
            console.log("debug." + h[0], _.repeat(" ", maxLength - h[0].length), "- " + h[1]);
        });
    });
    addCommand("setInstallDate", "выставить дату установки, пример setInstallDate(день, месяц, [год])", function(d, m, y) {
        if (!d || d > 31) return "Invalid day, example debug.setInstallDate(15, 5, 1984)";
        if (!m || m > 12) return "Invalid month, example debug.setInstallDate(15, 5, 1984)"; else m -= 1;
        y = y || new Date().getFullYear();
        var date = new Date(y, m, d);
        settings.set("appInstallTime", Math.round(date.getTime() / 1e3));
        return "New install date: " + dateUtils.format(date, "%D.%M.%Y");
    });
    addCommand("reset", "очистка базы, удаление бэкапа и сброс настроек", function() {
        return Promise.all([ backup.clear(), database.deleteDatabase(), files.removeAll() ]).then(resetSettings);
    });
    addCommand("reload", "перезагрузить фоновую страницу", function() {
        window.location.href = window.location.href + "?" + Math.random();
    });
    addCommand("enableLog", "включить лог в консоли", function() {});
    addCommand("log", "вывести лог в отдельный таб", function() {
        debug.show.log();
    });
    addCommand("adv.showBlock", 'показать рекламный блок (например, adv.showBlock("newbackground"))', function(blockId) {
        advertisement.show(blockId);
    });
    addCommand("show.log", "вывести лог в отдельный таб", function() {
        log.openInTab();
    });
    addCommand("show.thumbs", "вывести видимые тумбы в отдельный таб", function() {
        tabOpener.openAsFile("Thumbs", state.getThumbs());
    });
    addCommand("show.settings", "вывести настройки в отдельный таб", function() {
        tabOpener.openAsFile("Settings", state.getSettings());
    });
    addCommand("show.pickupcache", "вывести кеш АП в отдельный таб", function() {
        state.getPickupcache(function(err, items) {
            tabOpener.openAsFile("Pickup cache", items);
        });
    });
    addCommand("show.blacklistUser", "вывести блэклист пользователя в отдельный таб", function() {
        state.getBlacklistUser(function(err, items) {
            tabOpener.openAsFile("Blacklist (user)", items);
        });
    });
    addCommand("show.blacklistServer", "вывести блэклист сервера в отдельный таб", function() {
        tabOpener.openAsFile("Blacklist (server)", state.getBlacklistServer());
    });
    addCommand("show.bg", "вывести список фонов в отдельный таб", function() {
        tabOpener.openAsFile("Backgrounds", state.getBg());
    });
    addCommand("show.adv", "вывести состояние рекламы в отдельный таб", function() {
        tabOpener.openAsFile("Advertisement", advertisement.getState());
    });
    addCommand("show.branding", "вывести данные брендинга в отдельный таб", function() {
        var regionalData = platformBranding.getData();
        var data = Object.keys(regionalData).reduce(function(res, key) {
            res[key] = branding.getBlock(key);
            return res;
        }, {});
        tabOpener.openAsFile("Branding", data);
    });
    addCommand("show.custombranding", "вывести данные кастомного брендинга в отдельный таб", function() {
        tabOpener.openAsFile("Custom branding", remoteBrandingStorage.getData());
    });
    addCommand("show.files", "вывести список локальных файлов в отдельный таб", function() {
        if (platformAbout.isChr) {
            files.openChromeFS();
            return;
        }
        if (platformAbout.isFx) {
            files.openFirefoxFS();
            return;
        }
        files.getFileList(function(err, items) {
            tabOpener.openAsFile("Files", items);
        });
    });
    addCommand("show.buildInfo", "вывести информацию о сборке в отдельный таб", function() {
        tabOpener.openAsFile("Build info", buildData);
    });
    addCommand("show.experiments", "вывести информацию об экспериментах", function() {
        tabOpener.openAsFile("Experiments", {
            selected: experiments.getExperimentsList(),
            possible: __webpack_require__(359)
        });
    });
    addCommand("clear.db", "очистить базу данных", function() {
        database.deleteDatabase();
    });
    addCommand("clear.backup", "очистить бэкап", function() {
        backup.clear();
    });
    addCommand("clear.settings", "очистить настройки", function() {
        return resetSettings();
    });
    function addCommand(cmd, desc, fn) {
        var parts = cmd.split(".");
        var obj;
        var objGetters;
        var cmdName;
        if (parts.length > 1) {
            obj = debug[parts[0]] = debug[parts[0]] || {};
            objGetters = getters[parts[0]] = getters[parts[0]] || {};
            cmdName = parts[1];
        } else {
            obj = debug;
            objGetters = getters;
            cmdName = parts[0];
        }
        obj[cmdName] = fn;
        Object.defineProperty(objGetters, cmdName, {
            get: fn
        });
        help.push([ cmd, desc ]);
    }
    function resetSettings() {
        settings.resetDefaults();
        return new Promise(function(resolve) {
            backgroundSelector.selectDefaultBackground(resolve);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asyncLib = __webpack_require__(209);
    var platformFs = __webpack_require__(264);
    var FILE_DIRS = {
        root: "/",
        "cloud-logo": __webpack_require__(275).CLOUD_LOGO_DIR,
        "cloud-logo-sub": __webpack_require__(275).CLOUD_LOGO_SUB_DIR,
        favicons: __webpack_require__(222).FAVICON_DIR,
        backgrounds: __webpack_require__(354).directory,
        screenshots: __webpack_require__(350).SCREENSHOT_DIR,
        tableau: __webpack_require__(273).TABLEAU_DIR
    };
    exports.openChromeFS = function() {
        chrome.tabs.create({
            url: "filesystem:chrome-extension://" + chrome.runtime.id + "/persistent/"
        });
    };
    exports.openFirefoxFS = function() {
        platformFs.getFileUrl(FILE_DIRS.root, function(err, url) {
            chrome.tabs.create({
                url: url
            });
        });
    };
    exports.getFileList = function(callback) {
        var tasks = Object.keys(FILE_DIRS).reduce(function(res, dirName) {
            res[dirName] = function(callback) {
                readDir(FILE_DIRS[dirName], callback);
            };
            return res;
        }, {});
        asyncLib.parallel(tasks, callback);
    };
    exports.removeAll = function() {
        var dirs = Object.keys(FILE_DIRS).filter(function(name) {
            return "root" !== name;
        });
        return removeFiles(dirs);
    };
    function readDir(dir, callback) {
        asyncLib.waterfall([ function(callback) {
            platformFs.list(dir, callback);
        }, function(files, callback) {
            asyncLib.series(files.map(function(fileName) {
                return platformFs.getFileUrl.bind(platformFs, fileName);
            }), callback);
        } ], callback);
    }
    function removeFiles(namesOrUrls) {
        return new Promise(function(resolve) {
            asyncLib.parallel(namesOrUrls.map(function(nameOrUrl) {
                return platformFs.remove.bind(platformFs, nameOrUrl);
            }), resolve);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var platformLog = __webpack_require__(364);
    var tabOpener = __webpack_require__(365);
    var SYSTEM_DEBUG_URL = "http://visualbookmarks.log/";
    var timeout;
    exports.init = function() {
        chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
            if (tab.url === SYSTEM_DEBUG_URL) {
                clearTimeout(timeout);
                timeout = setTimeout(function() {
                    exports.openInTab(tabId);
                }, 100);
            }
        });
    };
    exports.openInTab = function(tabId) {
        platformLog.getAsText(function(str) {
            tabOpener.openAsFile("Log", str, tabId);
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var fs = __webpack_require__(264);
    var DEBUG_FILENAME = "debug.log";
    var DEBUG_FILENAME_OLD = "debug-old.log";
    var DEBUG_MAX_SIZE = 5 * 1024 * 1024;
    var MAX_NESSAGES_QUEUE_LENGTH = 500;
    var isRunning = false;
    var messagesQueue = [];
    var messagesQueueWriting = [];
    module.exports = {
        info: write,
        warn: write,
        error: write,
        getAsText: function(callback) {
            fs.readAsText(DEBUG_FILENAME, function(err, debug) {
                debug = debug || "";
                fs.readAsText(DEBUG_FILENAME_OLD, function(err, debugOld) {
                    debugOld = debugOld || "";
                    if (debugOld) debugOld += "\n======= DEBUG-OLD END =======\n";
                    callback(debugOld + debug);
                });
            });
        }
    };
    function write(str) {
        if (arguments.length) {
            messagesQueue.push(str);
            truncateQueue(messagesQueue);
        }
        if (!messagesQueue.length || !fs.isInitialized || isRunning) return;
        isRunning = true;
        messagesQueueWriting = messagesQueueWriting.concat(messagesQueue);
        truncateQueue(messagesQueueWriting);
        messagesQueue.length = 0;
        fs.write(DEBUG_FILENAME, {
            data: "\n" + messagesQueueWriting.join("\n"),
            type: "text/plain",
            append: true
        }, onWrite);
    }
    function onWrite(err, fileEntry, fileWriter) {
        if (!err) {
            messagesQueueWriting.length = 0;
            if (fileWriter.length > DEBUG_MAX_SIZE) fs.move(DEBUG_FILENAME, ".", DEBUG_FILENAME_OLD, function() {
                isRunning = false;
                write();
            }); else {
                isRunning = false;
                write();
            }
        } else isRunning = false;
    }
    function truncateQueue(queue) {
        if (queue.length > MAX_NESSAGES_QUEUE_LENGTH) queue.splice(0, MAX_NESSAGES_QUEUE_LENGTH / 2);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var escape = __webpack_require__(366);
    var platformFs = __webpack_require__(264);
    exports.openAsFile = function(title, text, tabId) {
        if ("string" !== typeof text) try {
            text = JSON.stringify(text, false, 2);
        } catch (e) {}
        var fileName = "temp.html";
        var html = decorate(title, text);
        var data = {
            data: html,
            type: "text/html",
            append: false
        };
        platformFs.write(fileName, data, function() {
            platformFs.getFileUrl(fileName, function(err, url) {
                if (tabId) chrome.tabs.update(tabId, {
                    url: url
                }); else chrome.tabs.create({
                    url: url
                });
            });
        });
    };
    function decorate(title, text) {
        return "<head><title>" + title + '</title><meta charset="utf-8"></head></head><body>' + "<h2>" + title + "</h2>" + '<pre style="word-wrap: break-word; white-space: pre-wrap;">' + escape(text) + "</pre>" + "</body>";
    }
}, function(module, exports, __webpack_require__) {
    var baseToString = __webpack_require__(122), escapeHtmlChar = __webpack_require__(367);
    var reUnescapedHtml = /[&<>"'`]/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    function escape(string) {
        string = baseToString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    module.exports = escape;
}, function(module, exports) {
    var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "`": "&#96;"
    };
    function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
    }
    module.exports = escapeHtmlChar;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var advertisement = __webpack_require__(369);
    var settings = __webpack_require__(216);
    var dateUtils = __webpack_require__(4);
    exports.getState = function() {
        var result = {
            NOW: formatDate(new Date())
        };
        result.blocks = advertisement.getAllBlocks().map(function(block) {
            return {
                block: block.getId().toUpperCase(),
                status: getTextStatus(block),
                state: getState(block)
            };
        });
        return result;
    };
    exports.show = function(blockId) {
        var block = advertisement.getBlockById(blockId);
        var blocks = advertisement.getAllBlocks();
        if (!block) {
            var blocksStr = blocks.map(function(block) {
                return block.getId();
            }).join(", ");
            return "Block not found! Available blocks: " + blocksStr;
        }
        block.startShowing();
        blocks.forEach(function(block) {
            if (block.getId() !== blockId) {
                block._state.lastShown = 0;
                block._state.lastRefuse = 0;
            }
        });
    };
    function getTextStatus(block) {
        if (block.isShowing()) return block._config.duration ? "showing " + block._config.duration + " day(s) until: " + formatDate(block._state.lastShown + block._config.duration * dateUtils.DAY_MS) : "showing infinitly";
        if (block.isSilent()) return "silent " + block._config.silent + " day(s) until: " + formatDate(block._state.lastRefuse + block._config.silent * dateUtils.DAY_MS);
        if (!block.isSilent() && block.isInterval()) return "interval " + block._config.interval + " day(s) until: " + formatDate(block._state.lastRefuse + block._config.interval * dateUtils.DAY_MS);
        if (block._isAfterInstallReached() && !block.isShowing() && !block.isSilent() && !block.isInterval()) return "normal";
        if (!block._isAfterInstallReached() && 0 === block._state.shownCount) return "waiting " + block._config.afterInstall + " day(s) after install, until: " + formatDate(1e3 * settings.get("appInstallTime") + block._config.afterInstall * dateUtils.DAY_MS);
        return "unknown";
    }
    function getState(block) {
        var dateFields = [ "lastRefuse", "lastShown" ];
        return Object.keys(block._state).reduce(function(res, key) {
            if ("data" === key) return res;
            var value = block._state[key];
            if (dateFields.indexOf(key) >= 0 && value > 0) res[key] = formatDate(value); else res[key] = value;
            return res;
        }, {});
    }
    function formatDate(date) {
        return dateUtils.format(date, "%D.%M.%Y %H:%N");
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Advertisement");
    var _ = __webpack_require__(91);
    var ticker = __webpack_require__(370);
    var RemoteConfigListener = __webpack_require__(371);
    var channel = __webpack_require__(27);
    var Group = __webpack_require__(373);
    var Block = __webpack_require__(374);
    var SHOWING_CHANGED_DELAY_MS = 100;
    var groupsConfig = {
        startsearch: [ {
            priority: 1,
            factory: __webpack_require__(375)
        }, {
            priority: 2,
            factory: __webpack_require__(378)
        } ],
        statoffer: [ {
            priority: 0,
            factory: __webpack_require__(379)
        } ],
        tutorials: [ {
            priority: 1,
            factory: __webpack_require__(380)
        }, {
            priority: 2,
            factory: __webpack_require__(385)
        }, {
            priority: 3,
            factory: __webpack_require__(386)
        }, {
            priority: 4,
            factory: __webpack_require__(408)
        }, {
            priority: 5,
            factory: __webpack_require__(409)
        } ]
    };
    var groups = [];
    exports.init = function() {
        ticker.init();
        ticker.onTick.addListener(exports.checkGroups);
        initGroups();
        new RemoteConfigListener(exports.getAllBlocks());
    };
    exports.getAllBlocks = function() {
        return groups.reduce(function(res, group) {
            return res.concat(group.getBlocks());
        }, []);
    };
    exports.checkGroups = function() {
        groups.forEach(function(group) {
            group.check();
        });
    };
    exports.getGroups = function() {
        return groups;
    };
    exports.getShowingBlocks = function() {
        return exports.getShowingBlocksForGroup(null);
    };
    exports.getShowingBlocksForGroup = function(groupId) {
        return groups.map(function(group) {
            if (groupId && group.getId() !== groupId) return null;
            return group.getShowingBlock();
        }).filter(Boolean);
    };
    exports.getBlockById = function(id) {
        return exports.getAllBlocks().filter(function(block) {
            return block.getId() === id;
        })[0];
    };
    exports.refuseByUser = function(blockId, data) {
        var block = exports.getBlockById(blockId);
        if (block) block.refuse(Block.REFUSE_REASON.USERCLOSE, data); else logger.warn("Unknown block to refuse: %s", blockId);
    };
    exports.accept = function(blockId, data) {
        var block = exports.getBlockById(blockId);
        if (block) block.refuse(Block.REFUSE_REASON.ACCEPT, data); else logger.warn("Unknown block to accept: %s", blockId);
    };
    exports.onShowingChanged = channel.create();
    function initGroups() {
        groups = Object.keys(groupsConfig).map(function(groupId) {
            var group = new Group(groupId);
            groupsConfig[groupId].forEach(function(blockInfo) {
                group.addBlock(blockInfo.factory(), blockInfo.priority);
            });
            group.onShowingChanged.addListener(onShowingChanged);
            return group;
        });
    }
    var onShowingChanged = _.debounce(function() {
        exports.onShowingChanged.dispatch();
    }, SHOWING_CHANGED_DELAY_MS);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var alarms = __webpack_require__(3);
    var channel = __webpack_require__(27);
    var ALARM = {
        name: "advertisementCheck",
        periodInMinutes: 30
    };
    var TICK_DELAY_MS = 5e3;
    exports.init = function() {
        alarms.register(ALARM, function() {
            setTimeout(function() {
                return exports.onTick.dispatch();
            }, TICK_DELAY_MS);
        });
    };
    exports.onTick = channel.create("Advertisement/ticker.onTick");
}, function(module, exports, __webpack_require__) {
    "use strict";
    var remoteConfig = __webpack_require__(372);
    var _ = __webpack_require__(91);
    var Listener = module.exports = function(blocks) {
        this._blocks = blocks;
        remoteConfig.onUpdated.addListener(this._processConfigAds.bind(this));
    };
    Listener.prototype._processConfigAds = function(config) {
        this._blocks.forEach(function(block) {
            var blockId = block.getId();
            var enabled = _.get(config, "ads." + blockId + ".enabled");
            if ("boolean" === typeof enabled && enabled !== block.isEnabled()) block.updateEnabled(enabled);
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var alarms = __webpack_require__(3);
    var channel = __webpack_require__(27);
    var settings = __webpack_require__(216);
    var deepEqual = __webpack_require__(299);
    var formatMessage = __webpack_require__(58);
    var logger = __webpack_require__(5).create("Remote-config");
    var ALARM = {
        name: "remote-config",
        periodInMinutes: 24 * 60
    };
    var CONFIG_URL = "https://download.cdn.yandex.net/bar/vb/config.json";
    var SETTING_NAME = "remoteConfig";
    exports.init = function() {
        alarms.register(ALARM, exports.check);
    };
    exports.check = function(callback) {
        callback = callback || utils.noop;
        var url = CONFIG_URL;
        logger.info("Checking %s", url);
        utils.xhr({
            url: url,
            logError: true,
            parse: "json"
        }, function(err, config) {
            logCheckErrors(err);
            if (err) callback(err); else processNewConfig(config, callback);
        });
    };
    exports.onUpdated = channel.create("remote-config-checker.onUpdated");
    function processNewConfig(newConfig, callback) {
        if (!isValidConfig(newConfig)) {
            var message = formatMessage("Invalid remote config %j", newConfig);
            callback(new Error(message));
            return;
        }
        var currentConfig = settings.get(SETTING_NAME) || {};
        var hasChanges = !deepEqual(currentConfig, newConfig);
        if (hasChanges) {
            settings.set(SETTING_NAME, newConfig);
            logger.info("Config updated to %j", newConfig);
            exports.onUpdated.dispatch(newConfig);
        }
        callback(null, newConfig);
    }
    function isValidConfig(config) {
        return config && Object.keys(config).length > 0;
    }
    function logCheckErrors(error) {
        if (error) logger.error(error.message);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var channel = __webpack_require__(27);
    var logger = __webpack_require__(5).create("Advertisement/group");
    var Group = module.exports = function(groupId) {
        this._id = groupId;
        this._blocks = [];
        this.onShowingChanged = channel.create();
        this.onShowingChangedDispatcher = this.onShowingChanged.dispatch.bind(this.onShowingChanged);
    };
    Group.prototype.getId = function() {
        return this._id;
    };
    Group.prototype.addBlock = function(block, priority) {
        block.priority = priority;
        this._blocks.push(block);
        block.onStartShowing.addListener(this.onShowingChangedDispatcher);
        block.onRefuse.addListener(this.onShowingChangedDispatcher);
        block.onEnabledChanged.addListener(function(block) {
            if (block.isShowing()) this.onShowingChangedDispatcher();
        }.bind(this));
        logger.info("Group %s: registered block %s with priority %i", this._id, block.getId(), block.priority);
    };
    Group.prototype.check = function() {
        this._getEnabledBlocks().forEach(function(block) {
            block.check();
        });
    };
    Group.prototype.getShowingBlock = function() {
        var silentBlocks = this._getSilentBlocks();
        if (silentBlocks.length) {
            logger.info("Group %s is silent because of %i blocks", this._id, silentBlocks.length);
            return;
        }
        var showingBlock = this._getShowingBlock();
        if (showingBlock) {
            logger.info("Group %s is showing block %s", this._id, showingBlock.getId());
            return showingBlock;
        }
        var startShowingBlock = this._getStartShowingBlock();
        if (startShowingBlock) {
            logger.info("Group %s start showing block %s", this._id, startShowingBlock.getId());
            return startShowingBlock;
        }
    };
    Group.prototype.getBlocks = function() {
        return this._blocks.slice();
    };
    Group.prototype._getEnabledBlocks = function() {
        return this._blocks.filter(function(block) {
            return block.isEnabled();
        });
    };
    Group.prototype._getSilentBlocks = function() {
        return this._getEnabledBlocks().filter(function(block) {
            return block.isSilent();
        });
    };
    Group.prototype._getShowingBlock = function() {
        var showingBlocks = this._getEnabledBlocks().filter(function(block) {
            return block.isShowing();
        });
        if (showingBlocks.length > 1) {
            logger.warn("Many showing blocks in group: %s %i", this._id, showingBlocks.length);
            showingBlocks.sort(sorterByPriority);
        }
        return showingBlocks[0];
    };
    Group.prototype._getStartShowingBlock = function() {
        var canStartShowing = this._getEnabledBlocks().filter(function(block) {
            return block.canStartShowing();
        });
        if (canStartShowing.length) {
            canStartShowing.sort(sorterByPriority);
            logger.info("Group %s can start showing %i block(s): %s", this._id, canStartShowing.length, canStartShowing.map(function(block) {
                return block.getId() + " (priority:" + block.priority + ")";
            }).join(", "));
            canStartShowing[0].startShowing();
            return canStartShowing[0];
        }
    };
    function sorterByPriority(blockA, blockB) {
        return blockA.priority - blockB.priority;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var _ = __webpack_require__(91);
    var dateUtils = __webpack_require__(4);
    var channel = __webpack_require__(27);
    var logger = __webpack_require__(5).create("Advertisement/block");
    var SETTING_STATE_NAME = "advertisementState";
    var SETTING_INSTALL_NAME = "appInstallTime";
    var stateFields = {
        lastShown: 0,
        lastRefuse: 0,
        needShowing: false,
        refuseCount: 0,
        shownCount: 0,
        enabled: true,
        data: {}
    };
    var configFields = [ "maxShownCount", "maxRefuseCount", "duration", "interval", "silent", "afterInstall" ];
    var Block = module.exports = function(id, config) {
        assertId(id);
        assertConfig(config);
        this._id = id;
        this._config = config;
        this.priority = 0;
        this._checker = _.noop;
        this._acceptor = _.noop;
        this.onStartShowing = channel.create();
        this.onRefuse = channel.create();
        this.onEnabledChanged = channel.create();
        this._loadState();
    };
    Block.REFUSE_REASON = {
        USERCLOSE: "userclose",
        ACCEPT: "accept",
        DURATION: "duration",
        EXTERNAL: "external"
    };
    Block.prototype.check = function() {
        logger.info("Checking %s", this._id);
        this.checkDuration();
        this.checkNeedShowing();
    };
    Block.prototype.startShowing = function() {
        this._state.lastShown = Date.now();
        this._state.shownCount++;
        this._saveState();
        logger.info("Start showing %s for %s day(s)", this._id, this._config.duration || "infinity");
        this.onStartShowing.dispatch(this);
    };
    Block.prototype.refuse = function(reason, data) {
        if (!this.isShowing()) return;
        this._state.lastRefuse = Date.now();
        if (this.isShowing()) {
            logger.warn("Incorrect dates, make lastShown = lastRefuse");
            this._state.lastShown = this._state.lastRefuse;
        }
        if (reason === Block.REFUSE_REASON.USERCLOSE) this._state.refuseCount++;
        this._saveState();
        if (reason === Block.REFUSE_REASON.ACCEPT) {
            logger.info("Accept %s with data %j", this._id, data);
            this._acceptor(data);
        } else logger.info("Refuse %s (%s)", this._id, reason);
        this.onRefuse.dispatch(this, reason);
    };
    Block.prototype.checkDuration = function() {
        if (this.isShowing() && this._isShowingDurationReached()) this.refuse(Block.REFUSE_REASON.DURATION);
    };
    Block.prototype.checkNeedShowing = function() {
        this._checker();
    };
    Block.prototype.canStartShowing = function() {
        if (!this._state.needShowing) return false;
        var timeIntervalsOk = this._isAfterInstallReached() && !this.isShowing() && !this.isSilent() && !this.isInterval() && this._isShownCountOk() && this._isRefuseCountOk();
        if (timeIntervalsOk) {
            this.checkNeedShowing();
            return this._state.needShowing;
        } else return false;
    };
    Block.prototype.updateNeedShowing = function(value) {
        value = Boolean(value);
        if (this._state.needShowing === value) return;
        this._state.needShowing = value;
        this._saveState();
        logger.info("Set needShowing of %s to %s", this._id, value);
        if (this.isShowing() && false === value) this.refuse(Block.REFUSE_REASON.EXTERNAL);
    };
    Block.prototype.updateEnabled = function(value) {
        value = Boolean(value);
        if (this._state.enabled === value) return;
        this._state.enabled = value;
        this._saveState();
        logger.info("Set enabled of %s to %s", this._id, value);
        this.onEnabledChanged.dispatch(this);
    };
    Block.prototype.updateData = function(data) {
        if (this._state.data !== data) {
            this._state.data = data;
            this._saveState();
        }
    };
    Block.prototype.getId = function() {
        return this._id;
    };
    Block.prototype.getData = function() {
        return this._state.data;
    };
    Block.prototype.getNeedShowing = function() {
        return this._state.needShowing;
    };
    Block.prototype.isEnabled = function() {
        return this._state.enabled;
    };
    Block.prototype.setChecker = function(checker) {
        this._checker = checker;
    };
    Block.prototype.setAcceptor = function(acceptor) {
        this._acceptor = acceptor;
    };
    Block.prototype.isShowing = function() {
        return this._state.shownCount > 0 && this._state.lastShown > this._state.lastRefuse;
    };
    Block.prototype.isSilent = function() {
        return this._state.shownCount > 0 && !this.isShowing() && this._config.silent && Date.now() >= this._state.lastRefuse && Date.now() <= this._state.lastRefuse + dateUtils.minutesToMs(this._config.silent);
    };
    Block.prototype.isInterval = function() {
        return this._state.shownCount > 0 && !this.isShowing() && this._config.interval && Date.now() >= this._state.lastRefuse && Date.now() <= this._state.lastRefuse + dateUtils.daysToMs(this._config.interval);
    };
    Block.prototype._isShowingDurationReached = function() {
        return this._state.shownCount > 0 && this._config.duration > 0 && Date.now() > this._state.lastShown + dateUtils.daysToMs(this._config.duration);
    };
    Block.prototype._isAfterInstallReached = function() {
        var appInstallTime = settings.get(SETTING_INSTALL_NAME) || 0;
        return !this._config.afterInstall || Date.now() > 1e3 * appInstallTime + dateUtils.daysToMs(this._config.afterInstall);
    };
    Block.prototype._isShownCountOk = function() {
        return !this._config.maxShownCount || this._state.shownCount < this._config.maxShownCount;
    };
    Block.prototype._isRefuseCountOk = function() {
        return !this._config.maxRefuseCount || this._state.refuseCount < this._config.maxRefuseCount;
    };
    Block.prototype._loadState = function() {
        var state = settings.get(SETTING_STATE_NAME);
        this._state = _.defaults({}, _.get(state, "blocks." + this._id), stateFields);
        logger.info("Loaded state of %s %j", this._id, this._state);
    };
    Block.prototype._saveState = function() {
        var state = settings.get(SETTING_STATE_NAME) || {};
        state.blocks = state.blocks || {};
        state.blocks[this._id] = _.extend({}, this._state);
        settings.set(SETTING_STATE_NAME, state);
    };
    function assertId(id) {
        if (!id) throw new Error("Block must have id");
    }
    function assertConfig(config) {
        if (!config) throw new Error("Block must have config");
        configFields.forEach(function(field) {
            if (void 0 === config[field] || isNaN(config[field])) throw new Error("Block config must have number field: " + field);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Block = __webpack_require__(374);
    var platformAbout = __webpack_require__(23);
    var branding = __webpack_require__(277);
    var startpages = __webpack_require__(376);
    var urlUtils = __webpack_require__(83);
    var ID = "vbsethome";
    var CONFIG = {
        maxShownCount: 3,
        maxRefuseCount: 3,
        duration: 0,
        interval: 30,
        silent: 1,
        afterInstall: "fx" === platformAbout.id ? 0 : 3
    };
    var logger = __webpack_require__(5).create("Advertisement/" + ID);
    var YANDEX_STARTPAGE_REG = /^(https?:\/\/)?([a-z0-9]+\.)*(ya|yandex)(\.com)?\.[a-z]{2,3}([\/\?#&]|$)/i;
    module.exports = function() {
        var block = new Block(ID, CONFIG);
        block.setChecker(checker.bind(null, block));
        block.setAcceptor(acceptor);
        return block;
    };
    function checker(block) {
        if (branding.startpage) startpages.get(function(err, urls) {
            var hasYandex = containsYandexOrVb(urls);
            block.updateNeedShowing(!hasYandex);
        }); else {
            logger.warn("Branding package does not contain startpage");
            block.updateNeedShowing(false);
        }
    }
    function acceptor() {
        startpages.get(function(err, urls) {
            var hasYandex = containsYandexOrVb(urls);
            if (!hasYandex) startpages.set(branding.startpage.url, urls);
        });
    }
    function containsYandexOrVb(urls) {
        return containsYandex(urls) || containsVb(urls);
    }
    function containsVb(urls) {
        return urls.some(function(url) {
            return urlUtils.isUrlInList(url, startpages.VB_URLS);
        });
    }
    function containsYandex(urls) {
        return urls.some(function(url) {
            return YANDEX_STARTPAGE_REG.test(url);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var platformBrowser = __webpack_require__(377);
    var platformAbout = __webpack_require__(23);
    var logger = __webpack_require__(5).create("Startpages");
    var utils = __webpack_require__(30);
    var urlUtils = __webpack_require__(83);
    var VB_URL = exports.VB_URL = platformAbout.visbookmarksFakeTabUrl || platformAbout.visbookmarksUrl;
    var VB_URLS = exports.VB_URLS = [ platformAbout.visbookmarksFakeTabUrl, platformAbout.visbookmarksUrl ].filter(Boolean);
    exports.get = function(callback) {
        platformBrowser.getStartpages(function(err, urls) {
            if (err || !Array.isArray(urls)) {
                logger.error("Error while getting startpages %j %j", err, urls);
                callback(err, []);
            } else callback(null, urls);
        });
    };
    exports.set = function(url, exisitingStartpages, callback) {
        callback = callback || utils.noop;
        if (!exisitingStartpages) {
            logger.info("Existing startpages not passed!");
            callback(new Error());
            return;
        }
        var newStartpages;
        if (exisitingStartpages.length > 1) {
            newStartpages = [ url ].concat(exisitingStartpages);
            logger.info("Adding %s to startpages: %s", url, exisitingStartpages);
        } else {
            newStartpages = [ url ];
            logger.info("Set new startpage: %s", url);
        }
        platformBrowser.setStartpages(newStartpages, callback);
    };
    exports.hasVb = function(callback) {
        exports.get(function(err, urls) {
            if (err) callback(err, false); else {
                var hasVb = urls.some(function(url) {
                    return urlUtils.isUrlInList(url, VB_URLS);
                });
                callback(null, hasVb);
            }
        });
    };
    exports.setVb = function(callback) {
        exports.get(function(err, urls) {
            exports.set(VB_URL, urls, callback);
        });
    };
}, function(module, exports) {
    "use strict";
    var yandexSearchIDs = [ "cpimfcfpokkicebcgjimeeemfjkhfplk", "laddjijkcfpakbbnnedbhnnciecidncp", "ijbepmfgphlcbokeedcnmbedhckonlin", "nehapofakghljopfegjogpgpeljkhjjn", "ebbpgceilfeopdjlpkcdpefgkjhapoie", "cbagalopghhleggojlledjihpdbogmcn", "fdgobpeoflmgannbplllbnhkoniogeka", "pmloecjpjlgmhmfjpimadenoekkoknnh", "jihlbmjiphbhpbggdjmcigebceidammg", "peagnjphcbmgmpoacoganhkchgljlban", "bfmefpmchiiiklaoabpmaobmjapabigk", "dgpbaklblfccdobmjkjjfcibnbaafofh", "ppfbfddocfkbegapcgkipgjnggpaecfe" ];
    var yandexStartpageIDs = [ "cdlgdffkkjdoglbioephbahjkkmmpdhi", "lalfiodohdgaejjccfgfmmngggpplmhp", "lpedlkoodagolnaladgccadeahpjgblg", "dkipfjephaclinnhbbpmjigimebkpmbk", "ecalfoflieekeegboemfckkhlgfmgldo", "keoelcjgdedmhlojlhlhiogfomadpfkh", "bfacnjhhlonddplapoikenaalhekaabg", "nehapofakghljopfegjogpgpeljkhjjn", "ebbpgceilfeopdjlpkcdpefgkjhapoie", "cbagalopghhleggojlledjihpdbogmcn", "aecdfooahhnabdgjifldpdjoehldcpoj", "jihlbmjiphbhpbggdjmcigebceidammg", "peagnjphcbmgmpoacoganhkchgljlban", "njomkkghlicmkndlldaeeboemmimpboe", "ljdehichgphpibomgiolefjhjcmgkdga", "gokakabmbonignaoohkcipkfakkahnmn" ];
    var yandexStartpageConfigs = [ {
        startpageReg: /^https?\:\/\/(www\.)?yandex\.ru/i,
        landing: "https://home.yandex.ru",
        extensionIds: []
    }, {
        startpageReg: /^https?\:\/\/(www\.)?yandex\.ua/i,
        landing: "https://home.yandex.ua",
        extensionIds: []
    }, {
        startpageReg: /^https?\:\/\/(www\.)?yandex\.com\.tr/i,
        landing: "https://home.yandex.com.tr",
        extensionIds: []
    } ];
    var yandexSearchConfigs = [ {
        searchUrlReg: /^https?\:\/\/(www\.)?yandex\.ru/i,
        landing: "https://set.yandex.ru",
        extensionIds: []
    }, {
        searchUrlReg: /^https?\:\/\/(www\.)?yandex\.ua/i,
        landing: "https://set.yandex.ua",
        extensionIds: []
    }, {
        searchUrlReg: /^https?\:\/\/(www\.)?yandex\.com\.tr/i,
        landing: "https://set.yandex.com.tr",
        extensionIds: []
    } ];
    module.exports = {
        getStartpages: function(callback) {
            getEnabledExtensions(function(items) {
                var hasYandex = items.some(function(item) {
                    return yandexStartpageIDs.indexOf(item.id) >= 0;
                });
                callback(null, hasYandex ? [ "https://yandex.ru" ] : []);
            });
        },
        setStartpages: function(startpages) {
            var startpage = Array.isArray(startpages) ? startpages[0] : null;
            if ("string" !== typeof startpage) return;
            var matchedConfig = yandexStartpageConfigs.filter(function(config) {
                return config.startpageReg.test(startpage);
            })[0];
            if (matchedConfig) chrome.tabs.create({
                url: matchedConfig.landing
            });
        },
        getSearchProviders: function(callback) {
            getEnabledExtensions(function(items) {
                var hasYandex = items.some(function(item) {
                    return yandexSearchIDs.indexOf(item.id) >= 0;
                });
                var providersInfo;
                if (hasYandex) providersInfo = {
                    defaultId: "yandex",
                    providers: [ {
                        id: "yandex",
                        url: "https://yandex.ru"
                    } ]
                }; else providersInfo = {
                    defaultId: "",
                    providers: []
                };
                callback(null, providersInfo);
            });
        },
        addDefaultSearchProvider: function(provider) {
            if (!provider || !provider.url) return;
            var matchedConfig = yandexSearchConfigs.filter(function(config) {
                return config.searchUrlReg.test(provider.url);
            })[0];
            if (matchedConfig) chrome.tabs.create({
                url: matchedConfig.landing
            });
        },
        removeSearchProvider: function() {},
        openBookmarksWindow: function() {
            chrome.tabs.create({
                url: "chrome://bookmarks"
            });
        },
        openHistoryWindow: function() {
            chrome.tabs.create({
                url: "chrome://history"
            });
        },
        openDownloadsWindow: function() {
            chrome.tabs.create({
                url: "chrome://downloads"
            });
        }
    };
    function getEnabledExtensions(callback) {
        callback([]);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Block = __webpack_require__(374);
    var platformBrowser = __webpack_require__(377);
    var platformAbout = __webpack_require__(23);
    var branding = __webpack_require__(277);
    var ID = "vbsetsearch";
    var CONFIG = {
        maxShownCount: 3,
        maxRefuseCount: 3,
        duration: 0,
        interval: 30,
        silent: 1,
        afterInstall: "fx" === platformAbout.id ? 0 : 3
    };
    var logger = __webpack_require__(5).create("Advertisement/" + ID);
    var YANDEX_SEARCH_REG = /^(https?:\/\/)?([a-z0-9]+\.)*(ya|yandex)(\.com)?\.[a-z]{2,3}([\/\?#&]|$)/i;
    module.exports = function() {
        var block = new Block(ID, CONFIG);
        block.setChecker(checker.bind(null, block));
        block.setAcceptor(acceptor);
        return block;
    };
    function checker(block) {
        if (branding.quicksearch) getDefaultSearchProvider(function(defaultSearchProvider) {
            var isYandex = isYandexProvider(defaultSearchProvider);
            block.updateNeedShowing(!isYandex);
        }); else {
            logger.warn("Branding package does not contain quicksearch");
            block.updateNeedShowing(false);
        }
    }
    function acceptor() {
        if (branding.quicksearch) getDefaultSearchProvider(function(defaultSearchProvider, allSearchProviders) {
            if (!isYandexProvider(defaultSearchProvider)) {
                removeYandexProviders(allSearchProviders);
                setDefaultYandexProvider();
            }
        }); else logger.warn("Branding package does not contain quicksearch");
    }
    function getDefaultSearchProvider(callback) {
        platformBrowser.getSearchProviders(function(err, info) {
            if (err) logger.error("Can not get SearchProvidersInfo, err %j", err); else logger.info("Got SearchProvidersInfo %j", info);
            info = info || {};
            var defaultSearchProvider = findDefaultSearchProvider(info);
            if (defaultSearchProvider) logger.info("Default search provider %s %j", defaultSearchProvider.displayName, defaultSearchProvider); else logger.info("Default search provider is empty");
            callback(defaultSearchProvider, info.providers || []);
        });
    }
    function findDefaultSearchProvider(info) {
        if (info && info.defaultId && Array.isArray(info.providers)) return info.providers.filter(function(provider) {
            return provider.id === info.defaultId;
        })[0]; else return null;
    }
    function isYandexProvider(provider) {
        return provider && YANDEX_SEARCH_REG.test(provider.url);
    }
    function removeYandexProviders(providers) {
        providers.forEach(function(provider) {
            if (isYandexProvider(provider)) platformBrowser.removeSearchProvider(provider.id);
        });
    }
    function setDefaultYandexProvider() {
        var qs = branding.quicksearch;
        var config = {
            url: qs.searchUrl,
            displayName: qs.shortName,
            showSearchSuggestions: true,
            suggestionsUrl: qs.suggestUrl,
            faviconUrl: qs.iconUrl
        };
        logger.info("Setting Yandex as default search provider %j", config);
        platformBrowser.addDefaultSearchProvider(config);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Block = __webpack_require__(374);
    var settings = __webpack_require__(216);
    var ID = "statoffer";
    var CONFIG = {
        maxShownCount: 2,
        maxRefuseCount: 0,
        duration: 1,
        interval: 7,
        silent: 1,
        afterInstall: 7
    };
    module.exports = function() {
        var block = new Block(ID, CONFIG);
        block.setChecker(checker.bind(null, block));
        block.setAcceptor(acceptor);
        return block;
    };
    function checker(block) {
        block.updateNeedShowing(!settings.get("sendUsageStat"));
    }
    function acceptor() {
        settings.set("sendUsageStat", true);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Block = __webpack_require__(374);
    var rotation = __webpack_require__(381);
    var settings = __webpack_require__(216);
    var ID = "dailyback";
    var CONFIG = {
        maxShownCount: 1,
        maxRefuseCount: 0,
        duration: 1,
        interval: 0,
        silent: 10,
        afterInstall: 1
    };
    module.exports = function() {
        var block = new Block(ID, CONFIG);
        block.setAcceptor(acceptor);
        block.setChecker(checker.bind(null, block));
        return block;
    };
    function checker(block) {
        block.updateNeedShowing(!settings.hasUserValue("backgroundRotation"));
    }
    function acceptor() {
        rotation.setSelected(true);
        rotation.rotate();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var alarms = __webpack_require__(3);
    var settings = __webpack_require__(216);
    var cloudBackgrounds = __webpack_require__(382);
    var selector = __webpack_require__(384);
    var logger = __webpack_require__(5).create("Backgrounds/rotation");
    var ALARM = {
        name: "backgroundsRotation",
        periodInMinutes: 24 * 60
    };
    var SETTING_NAME = "backgroundRotation";
    var INDEX_SETTING_NAME = "backgroundRotationIndex";
    exports.init = function() {
        alarms.register(ALARM, onAlarm);
    };
    exports.rotate = function() {
        var index = settings.get(INDEX_SETTING_NAME);
        var ids = getCloudIds();
        if (ids.length) {
            index = index < ids.length - 1 ? index + 1 : 0;
            settings.set(INDEX_SETTING_NAME, index);
            logger.info("Rotate to next bg #%i of %i: %s", index, ids.length, ids[index]);
            selector.selectBackground(ids[index]);
        }
    };
    exports.isSelected = function() {
        return settings.get(SETTING_NAME);
    };
    exports.setSelected = function(value) {
        logger.info("Set selected: %s", value);
        settings.set(SETTING_NAME, Boolean(value));
    };
    exports.getCurrentBackgroundId = function() {
        var index = settings.get(INDEX_SETTING_NAME);
        var ids = getCloudIds();
        if (ids.length && index < ids.length) return ids[index]; else return "";
    };
    function getCloudIds() {
        var items = cloudBackgrounds.getBackgrounds();
        var ids = Object.keys(items);
        ids.sort(function(a, b) {
            return items[a].index - items[b].index;
        });
        return ids;
    }
    function onAlarm() {
        if (exports.isSelected()) exports.rotate();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var bgSettings = __webpack_require__(383);
    var colorUtils = __webpack_require__(259);
    var OVERLAY_NEEDS_BLACK_INDICATOR = "vb-sync_status-bg";
    exports.getBackgrounds = function() {
        var cloudBackgrounds = bgSettings.getBackgroundsList();
        return cloudBackgrounds.reduce(function(result, backgroundData, index) {
            if (backgroundData.id && backgroundData.preview && backgroundData.image) result[backgroundData.id] = constructCloudBackgroundData(backgroundData, index);
            return result;
        }, {});
    };
    exports.getBackground = function(id) {
        return exports.getBackgrounds()[id];
    };
    function constructCloudBackgroundData(backgroundData, index) {
        return {
            index: index,
            id: backgroundData.id,
            preview: backgroundData.preview,
            image: backgroundData.image,
            downloadDate: backgroundData.downloadDate,
            color: isModificatorsColorBlack(backgroundData.modificators) ? colorUtils.OVERLAY_COLOR_BLACK : colorUtils.OVERLAY_COLOR_WHITE
        };
    }
    function isModificatorsColorBlack(modificators) {
        return Array.isArray(modificators) && modificators[0] === OVERLAY_NEEDS_BLACK_INDICATOR;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var BACKGROUND_VERSION_SETTING = "backgroundImagesVersion";
    var BACKGROUND_LIST_SETTING = "backgroundImagesList";
    var BACKGROUND_IMAGE_SETTING = "backgroundImage";
    var BACKGROUND_IMAGE_PATH_SETTING = "backgroundImagePath";
    var BACKGROUND_FONT_COLORS_SETTIGS = "backgroundImagesFontColors";
    var BACKGROUND_MISSING_DATA_SETTIGS = "backgroundMissingCloudData";
    var storage = {
        getBackgroundsVersion: function() {
            return settings.get(BACKGROUND_VERSION_SETTING);
        },
        setBackgroundsVersion: function(value) {
            return settings.set(BACKGROUND_VERSION_SETTING, value);
        },
        getBackgroundsList: function() {
            return settings.get(BACKGROUND_LIST_SETTING);
        },
        setBackgroundsList: function(value) {
            return settings.set(BACKGROUND_LIST_SETTING, value);
        },
        getBackgroundImage: function() {
            return settings.get(BACKGROUND_IMAGE_SETTING);
        },
        setBackgroundImage: function(value) {
            return settings.set(BACKGROUND_IMAGE_SETTING, value);
        },
        getFontColors: function() {
            return settings.get(BACKGROUND_FONT_COLORS_SETTIGS);
        },
        setFontColors: function(value) {
            return settings.set(BACKGROUND_FONT_COLORS_SETTIGS, value);
        },
        setMissingCloudBackground: function(value) {
            return settings.set(BACKGROUND_MISSING_DATA_SETTIGS, value);
        },
        getMissingCloudBackground: function() {
            return settings.get(BACKGROUND_MISSING_DATA_SETTIGS);
        },
        setBackgroundImagePath: function(value) {
            return settings.set(BACKGROUND_IMAGE_PATH_SETTING, value);
        },
        getBackgroundImagePath: function() {
            return settings.get(BACKGROUND_IMAGE_PATH_SETTING);
        }
    };
    module.exports = storage;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var logger = __webpack_require__(5).create("Backgrounds/selector");
    var bgSettings = __webpack_require__(383);
    var storage = __webpack_require__(354);
    var fontColors = __webpack_require__(355);
    var brandingBackgrounds = __webpack_require__(356);
    var cloudBackgrounds = __webpack_require__(382);
    var channel = __webpack_require__(27);
    var urlUtils = __webpack_require__(83);
    var selectQueue = {};
    exports.selectBackground = function(backgroundId, callback) {
        callback = callback || utils.noop;
        if (selectQueue[backgroundId]) {
            logger.info("Selecting background %s is in progress", backgroundId);
            selectQueue[backgroundId].push(callback);
        } else {
            selectQueue[backgroundId] = [ callback ];
            logger.info("Selecting background: %s", backgroundId);
            select(backgroundId, function(err) {
                selectQueue[backgroundId].forEach(function(callback) {
                    callback(err);
                });
                delete selectQueue[backgroundId];
            });
        }
    };
    exports.selectDefaultBackground = function(callback) {
        callback = callback || utils.noop;
        var data = brandingBackgrounds.getDefaultBackground();
        if (data && data.id) exports.selectBackground(data.id, callback); else {
            logger.error("Can not set default background %j", data);
            callback(new Error());
        }
    };
    exports.onSelectSuccess = channel.create();
    function select(backgroundId, callback) {
        var backgroundObject = brandingBackgrounds.getBackground(backgroundId) || cloudBackgrounds.getBackground(backgroundId);
        if (backgroundObject) selectBrandedOrCloud(backgroundObject, callback); else selectFromFS(backgroundId, callback);
    }
    function selectBrandedOrCloud(backgroundObject, callback) {
        var params = {
            id: backgroundObject.id,
            url: backgroundObject.image,
            color: backgroundObject.color
        };
        storage.getLocalUrl(backgroundObject.id, function(err, data) {
            var localUrl = data && data.url;
            if (localUrl) {
                params.url = localUrl;
                logger.info("Background %s found in local fs: %s", backgroundObject.id, localUrl);
                save(params, callback);
            } else download(backgroundObject, function(error, localUrl) {
                if (localUrl) {
                    params.url = localUrl;
                    save(params, callback);
                } else callback(error || new Error("Empty localUrl"));
            });
        });
    }
    function download(backgroundObject, callback) {
        storage.download(backgroundObject.image, backgroundObject.id, function(error, data) {
            if (error) {
                logger.error(error.message);
                callback(error);
                return;
            }
            var localUrl = data && data.url;
            if (localUrl) logger.info("Downloaded background %s to %s", backgroundObject.id, localUrl); else logger.error("Can not download background %s from %s", backgroundObject.id, backgroundObject.image);
            callback(null, localUrl);
        });
    }
    function selectFromFS(backgroundId, callback) {
        storage.getAll(function(err, urls) {
            var localUrl = urls && urls.hasOwnProperty(backgroundId) && urls[backgroundId];
            if (localUrl) {
                localUrl = urlUtils.addRandomParam(localUrl);
                save({
                    id: backgroundId,
                    url: localUrl,
                    color: ""
                }, callback);
            } else {
                logger.error("Background %s not found in local fs", backgroundId);
                callback(new Error());
            }
        });
    }
    function save(params, callback) {
        bgSettings.setBackgroundImage(params.id);
        bgSettings.setBackgroundImagePath(params.url);
        logger.info("Background %s saved in settings", params.id);
        saveFontColor(params, function() {
            exports.onSelectSuccess.dispatch(params);
            callback();
        });
    }
    function saveFontColor(params, callback) {
        if (!params.color) fontColors.get(params.id, params.url, function(color) {
            params.color = color;
            callback();
        }); else {
            if (!fontColors.getCached(params.id)) fontColors.setCached(params.id, params.color);
            callback();
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Block = __webpack_require__(374);
    var settings = __webpack_require__(216);
    var collection = __webpack_require__(270);
    var ID = "vbaddthumb";
    var CONFIG = {
        maxShownCount: 1,
        maxRefuseCount: 0,
        duration: 1,
        interval: 0,
        silent: 10,
        afterInstall: 0
    };
    module.exports = function() {
        var block = new Block(ID, CONFIG);
        block.setChecker(checker.bind(null, block));
        settings.onChanged.addListener(onSettingChanged.bind(null, block));
        return block;
    };
    function checker(block) {
        var hasAdded = settings.get("hasUserAddedThumb");
        var maxCountReached = collection.length === collection.maxLength;
        block.updateNeedShowing(!hasAdded && !maxCountReached);
    }
    function onSettingChanged(block, info) {
        if ("hasUserAddedThumb" === info.key) block.checkNeedShowing();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var alarms = __webpack_require__(3);
    var Block = __webpack_require__(374);
    var backgroundsCloudLoader = __webpack_require__(387);
    var backgroundRotation = __webpack_require__(381);
    var backgroundsSelector = __webpack_require__(384);
    var frontendSettings = __webpack_require__(388);
    var ID = "newbackground";
    var CONFIG = {
        maxShownCount: 0,
        maxRefuseCount: 0,
        duration: 1,
        interval: 1,
        silent: 10,
        afterInstall: 0
    };
    var logger = __webpack_require__(5).create("Advertisement/" + ID);
    var MIN_NEWBG_COUNT = 3;
    var MAX_NEWBG_COUNT = 6;
    var ALARM_NAME = "advertisement.newbackground";
    var ALARM_DELAY_MINUTES = 5;
    module.exports = function() {
        var block = new Block(ID, CONFIG);
        backgroundsCloudLoader.onUpdated.addListener(onBackgroundsUpdated.bind(null, block));
        frontendSettings.onRequested.addListener(onSettingsRequested.bind(null, block));
        block.onRefuse.addListener(onRefuse.bind(null, block));
        overwriteRefuse(block);
        listenAlarm(block);
        return block;
    };
    function onBackgroundsUpdated(block, info) {
        info = info || {};
        if (Array.isArray(info.newBackgrounds) && info.newBackgrounds.length >= MIN_NEWBG_COUNT) {
            var backgroundsToShow = info.newBackgrounds.slice(0, MAX_NEWBG_COUNT);
            block.updateData({
                tryNew: Boolean(info.versions && info.versions.old > 0),
                backgrounds: backgroundsToShow
            });
            block.updateNeedShowing(true);
        }
    }
    function onSettingsRequested(block) {
        if (block.isShowing()) block.refuse(Block.REFUSE_REASON.EXTERNAL);
    }
    function overwriteRefuse(block) {
        block.parentRefuse = block.refuse;
        block.refuse = refuse;
    }
    function onRefuse(block) {
        block.updateNeedShowing(false);
    }
    function refuse(reason, data) {
        switch (reason) {
          case Block.REFUSE_REASON.USERCLOSE:
            onUserClose(this, data);
            break;

          case Block.REFUSE_REASON.ACCEPT:
            onAccept(data);
            break;

          case Block.REFUSE_REASON.EXTERNAL:
            clearAlarm();
            this.parentRefuse(reason);
            break;

          case Block.REFUSE_REASON.DURATION:
            this.parentRefuse(reason);
            break;

          default:
            logger.error("Unknown reason: %s", reason);
        }
    }
    function onUserClose(block, data) {
        hasAlarm(function(exists) {
            if (exists) {
                clearAlarm();
                block.parentRefuse(Block.REFUSE_REASON.ACCEPT);
            } else block.parentRefuse(Block.REFUSE_REASON.USERCLOSE);
        });
        if (data && data.done && backgroundRotation.isSelected()) backgroundRotation.setSelected(false);
    }
    function onAccept(data) {
        data = data || {};
        if (data.id) backgroundsSelector.selectBackground(data.id); else {
            logger.error("Empty background id, %j", data);
            return;
        }
        if (data.cancel) clearAlarm(); else setAlarm();
    }
    function setAlarm() {
        clearAlarm(function() {
            logger.info("Set timeout for %i minute(s)", ALARM_DELAY_MINUTES);
            alarms.register({
                name: ALARM_NAME,
                delayInMinutes: ALARM_DELAY_MINUTES
            });
        });
    }
    function hasAlarm(callback) {
        alarms.exists(ALARM_NAME, callback);
    }
    function clearAlarm(callback) {
        alarms.clear(ALARM_NAME, callback);
    }
    function listenAlarm(block) {
        alarms.on(ALARM_NAME, function() {
            logger.info("Timeout finished");
            block.parentRefuse(Block.REFUSE_REASON.ACCEPT);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var bgSettings = __webpack_require__(383);
    var find = __webpack_require__(197);
    var channel = __webpack_require__(27);
    var alarms = __webpack_require__(3);
    var logger = __webpack_require__(5).create("backgounds-sync");
    var SYNC_JSON_URL = "https://download.cdn.yandex.net/bar/vb/bgs.json";
    var LOAD_TIMEOUT = 1e4;
    var ALARM = {
        name: "cloudBackgrounds",
        periodInMinutes: 24 * 60
    };
    exports.init = function() {
        alarms.register(ALARM, exports.sync);
    };
    exports.sync = function(callback) {
        callback = callback || utils.noop;
        loadBackgounds(function(err, response) {
            if (err) {
                logger.error("Problem in backgrounds.sync method: %o", err);
                callback(err);
            } else if (isValid(response)) {
                syncBackgrounds(response);
                callback();
            } else {
                err = new Error("Invalid response, `version` or `skins` not found");
                logger.error("Problem in backgrounds.sync method: %o", err);
                callback(err);
            }
        });
    };
    exports.onUpdated = channel.create();
    function loadBackgounds(callback) {
        utils.xhr({
            url: SYNC_JSON_URL,
            timeout: LOAD_TIMEOUT,
            parse: "json"
        }, callback);
    }
    function isValid(response) {
        return response && response.version && Array.isArray(response.skins) && response.skins.length > 0;
    }
    function syncBackgrounds(response) {
        var versions = getVersions(response);
        if (versions.new > versions.old) {
            logger.info("Going to update backgrounds, versions: %s -> %s", versions.old, versions.new);
            keepCurrent(response.skins);
            update(response.skins, versions);
        } else logger.info("New version %s <= %s (current)", versions.new, versions.old);
    }
    function getVersions(response) {
        return {
            old: bgSettings.getBackgroundsVersion(),
            new: response.version || 1
        };
    }
    function update(cloudBackgrounds, versions) {
        var currentBackgrounds = bgSettings.getBackgroundsList();
        var newBackgrounds = getNew(currentBackgrounds, cloudBackgrounds);
        bgSettings.setBackgroundsList(cloudBackgrounds);
        bgSettings.setBackgroundsVersion(versions.new);
        exports.onUpdated.dispatch({
            versions: versions,
            newBackgrounds: newBackgrounds
        });
    }
    function getNew(currentBackgrounds, cloudBackgrounds) {
        return cloudBackgrounds.filter(function(cloudBg) {
            return !currentBackgrounds.some(function(curBg) {
                return curBg.id === cloudBg.id;
            });
        });
    }
    function keepCurrent(cloudBackgrounds) {
        var currentBackgroundId = bgSettings.getBackgroundImage();
        var missingCloud = bgSettings.getMissingCloudBackground() || {};
        if (missingCloud.id !== currentBackgroundId) bgSettings.setMissingCloudBackground(null); else return;
        var inCloud = find(cloudBackgrounds, "id", currentBackgroundId);
        var inCurrentCloud = find(bgSettings.getBackgroundsList(), "id", currentBackgroundId);
        if (inCurrentCloud && !inCloud) bgSettings.setMissingCloudBackground(inCurrentCloud);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var parallel = __webpack_require__(209).parallel;
    var frontendBackgrounds = __webpack_require__(389);
    var startpages = __webpack_require__(376);
    var checkboxes = __webpack_require__(215);
    var slider = __webpack_require__(392);
    var _ = __webpack_require__(91);
    var channel = __webpack_require__(27);
    var logger = __webpack_require__(5).create("Frontend/settings");
    var branding = __webpack_require__(277);
    var buildInfo = __webpack_require__(20);
    var backup = __webpack_require__(405);
    var thumbsCollection = __webpack_require__(270);
    var events = __webpack_require__(268);
    exports.init = function() {
        checkboxes.init();
        messaging.on(events.frontend.REQUEST_SETTINGS, function(req, sender, sendResponse) {
            logger.info("Requested by tab: %i", sender && sender.tab && sender.tab.id);
            requestSettings(sendResponse);
            exports.onRequested.dispatch();
            return true;
        });
        messaging.on(events.frontend.APPLY_SETTING, applySetting);
        messaging.on(events.frontend.MAKE_BACKUP, function(req, sender, sendResponse) {
            sendResponse(backup.make());
            return true;
        });
        messaging.on(events.frontend.LOAD_BACKUP, function(req, sender, sendResponse) {
            backup.load(req.url).then(function() {
                return sendResponse(true);
            }).catch(function() {
                return sendResponse(false);
            });
            return true;
        });
    };
    exports.onRequested = channel.create();
    function applySetting(req, sender) {
        switch (req.id) {
          case "thumbsCount":
            slider.setCount(req.value);
            break;

          case "selectedBgImage":
            frontendBackgrounds.setBackgroundImage(req, sender);
            break;

          case "isStartPage":
            startpages.setVb(function(err) {
                if (!err) messaging.send(events.backend.START_PAGE_CHANGED);
            });
            break;

          default:
            checkboxes.apply(req.id, req.value);
        }
    }
    function requestSettings(callback) {
        parallel({
            bgImages: frontendBackgrounds.getAll.bind(frontendBackgrounds),
            isStartPage: startpages.hasVb.bind(startpages)
        }, function(error, data) {
            if (error) logger.error(error.message);
            var result = _.merge({
                thumbsCount: thumbsCollection.items.length
            }, data, getSelectedBgImage(), checkboxes.getValues(), getTemplateValues());
            logger.info("Send settings: %j", result);
            callback(result);
        });
    }
    function getSelectedBgImage() {
        return {
            selectedBgImage: frontendBackgrounds.getCurrent().id
        };
    }
    function getTemplateValues() {
        return {
            licenseURL: branding.settings.licenseUrl,
            softURL: branding.settings.softUrl,
            productURL: branding.settings.productUrl,
            vendorURL: branding.settings.vendorUrl,
            rev: buildInfo.getVersion(),
            build: buildInfo.getRevision(),
            buildDate: buildInfo.getTimestamp()
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var backgrounds = __webpack_require__(390);
    var bgSelector = __webpack_require__(384);
    var userBackground = __webpack_require__(353);
    var bgRotation = __webpack_require__(381);
    var events = __webpack_require__(268);
    exports.init = function() {
        messaging.on(events.frontend.UPLOAD_USER_BACKGROUND, uploadUserBackground);
        bgSelector.onSelectSuccess.addListener(backgroundChanged);
    };
    exports.getCurrent = function() {
        var data = backgrounds.requestCurrent() || {};
        return {
            id: data.id || "",
            image: data.image || "",
            color: data.color || ""
        };
    };
    exports.getAll = function(callback) {
        backgrounds.requestAll(function(err, items) {
            if (err || !Array.isArray(items)) callback(null, []); else callback(null, items);
        });
    };
    exports.setBackgroundImage = function(req, sender) {
        var backgroundId = req.value;
        if (!backgroundId) return;
        bgSelector.selectBackground(backgroundId, function(err) {
            var tabId = sender && sender.tab.id;
            if (err && tabId) messaging.send(events.backend.BACKGROUND_CHANGED, {
                error: true
            }, tabId); else if (bgRotation.isSelected()) bgRotation.setSelected(false);
        });
    };
    function uploadUserBackground(req, sender, sendResponse) {
        if (req.url) userBackground.download(req.url, sendResponse); else userBackground.copy(req.path, sendResponse);
        return true;
    }
    function backgroundChanged(data) {
        if (data) messaging.send(events.backend.BACKGROUND_CHANGED, {
            id: data.id,
            image: data.url,
            color: data.color
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var cloudLoader = __webpack_require__(387);
    var fontColors = __webpack_require__(355);
    var requestAll = __webpack_require__(391);
    var bgSettings = __webpack_require__(383);
    var bgRotation = __webpack_require__(381);
    module.exports = {
        name: "backgrounds",
        init: function() {
            cloudLoader.init();
            bgRotation.init();
        },
        requestCurrent: function() {
            var backgroundId = bgSettings.getBackgroundImage();
            var backgroundPath = bgSettings.getBackgroundImagePath();
            var color = fontColors.getCached(backgroundId);
            return {
                id: backgroundId,
                image: backgroundPath,
                color: color || fontColors.DEFAULT_COLOR
            };
        },
        sync: cloudLoader.sync,
        requestAll: requestAll
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asyncLib = __webpack_require__(209);
    var storage = __webpack_require__(354);
    var brandingBackgrounds = __webpack_require__(356);
    var cloudBackgrounds = __webpack_require__(382);
    var userBackground = __webpack_require__(353);
    var bgSettings = __webpack_require__(383);
    var logger = __webpack_require__(5).create("BackgroundsRequestAll");
    var _ = __webpack_require__(91);
    module.exports = function(callback) {
        asyncLib.waterfall([ createDataObject, getLocalFiles, searchForUserBackground, addBrandingBackgrounds, addCloudBackgrounds, addMissingCloudBackground, addMissingLocalBackgrounds, createFinalList ], callback);
    };
    function createDataObject(callback) {
        callback(null, {
            backgroundsMap: {},
            localFilesMap: {}
        });
    }
    function getLocalFiles(data, callback) {
        storage.getAll(function(error) {
            var localFilesMap = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            data.localFilesMap = localFilesMap;
            callback(null, data);
        });
    }
    function searchForUserBackground(data, callback) {
        var background = userBackground.getFromMap(data.localFilesMap);
        if (background) data.backgroundsMap[background.id] = background;
        callback(null, data);
    }
    function addBrandingBackgrounds(data, callback) {
        var backgrounds = brandingBackgrounds.getBackgrounds();
        _.defaults(data.backgroundsMap, backgrounds);
        callback(null, data);
    }
    function addCloudBackgrounds(data, callback) {
        var backgrounds = cloudBackgrounds.getBackgrounds();
        _.defaults(data.backgroundsMap, backgrounds);
        callback(null, data);
    }
    function addMissingCloudBackground(data, callback) {
        var background = constructMissingCloudBackground(data.backgroundsMap, data.localFilesMap);
        if (background) data.backgroundsMap[background.id] = background;
        callback(null, data);
    }
    function constructMissingCloudBackground(backgroundsMap, localFilesMap) {
        var backgroundData = bgSettings.getMissingCloudBackground();
        if (backgroundData && isBackgroundMissing(backgroundData.id, backgroundsMap, localFilesMap)) {
            logger.info("Missing cloud background has been found:", backgroundData.id);
            return constructBackgroundFromLocalData(backgroundData.id, localFilesMap, backgroundData.index);
        }
        return null;
    }
    function addMissingLocalBackgrounds(data, callback) {
        Object.keys(data.localFilesMap).forEach(function(id) {
            if (!(id in data.backgroundsMap)) {
                logger.info("Missing local background has been found:", id);
                data.backgroundsMap[id] = constructBackgroundFromLocalData(id, data.localFilesMap);
            }
        });
        callback(null, data);
    }
    function isBackgroundMissing(missingId, backgroundsMap, localFilesMap) {
        var isConstructed = missingId in backgroundsMap;
        var isInLocalData = missingId in localFilesMap;
        return !isConstructed && isInLocalData;
    }
    function constructBackgroundFromLocalData(id, localFilesMap, index) {
        return {
            id: id,
            image: localFilesMap[id],
            preview: localFilesMap[id],
            index: index || 0
        };
    }
    function updateUrlsFromLocalData(localMap, currentMap) {
        Object.keys(localMap).forEach(function(fileName) {
            if (currentMap[fileName]) currentMap[fileName].image = localMap[fileName];
        });
    }
    function createFinalList(data, callback) {
        updateUrlsFromLocalData(data.localFilesMap, data.backgroundsMap);
        var list = Object.keys(data.backgroundsMap).map(function(backgroundId) {
            return data.backgroundsMap[backgroundId];
        }).map(function(data) {
            data.branded = Boolean(data.branded);
            data.isUser = Boolean(data.isUser);
            return data;
        }).sort(sortFinalList);
        callback(null, list);
    }
    function sortFinalList(a, b) {
        return Number(b.branded) - Number(a.branded) || Number(b.isUser) - Number(a.isUser) || a.index - b.index;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var collection = __webpack_require__(270);
    var Thumb = __webpack_require__(271);
    var candidates = __webpack_require__(393);
    var urlUtils = __webpack_require__(83);
    var blacklist = __webpack_require__(398);
    var backupRestore = __webpack_require__(404);
    var branding = __webpack_require__(277);
    var logger = __webpack_require__(5).create("Slider");
    var removedThumbsCache = [];
    var pickupCache;
    exports.init = function() {
        backupRestore.onRestored.addListener(clearCache);
    };
    exports.setCount = function(newCount) {
        var currentCount = collection.length;
        if (newCount > currentCount) if (newCount > currentCount + removedThumbsCache.length && !pickupCache) populatePickupCache(function() {
            increase(newCount);
        }); else increase(newCount); else if (newCount < currentCount) decrease(newCount);
    };
    function increase(newCount, isSecondRun) {
        logger.info("Increase count from %i to %i", collection.length, newCount);
        blacklist.createChecker(function(blacklistChecker) {
            var positions = [];
            var indexToAdd = collection.length;
            var thumbsFromRemovedCacheLogData = [];
            var thumbsFromPickupCacheLogData = [];
            var blacklistedTumbsLogData = [];
            var currentThumbsLogData;
            while (indexToAdd < newCount) {
                var thumb;
                if (removedThumbsCache.length) {
                    thumb = removedThumbsCache.shift();
                    currentThumbsLogData = thumbsFromRemovedCacheLogData;
                } else {
                    thumb = createThumbFromPickupCache();
                    currentThumbsLogData = thumbsFromPickupCacheLogData;
                }
                if (!thumb) {
                    logger.warn("Not enough thumbs!");
                    break;
                }
                if (!blacklistChecker.contains(thumb.url)) {
                    collection.setItem(indexToAdd, thumb);
                    positions.push(indexToAdd);
                    indexToAdd++;
                    currentThumbsLogData.push(thumb.url);
                } else blacklistedTumbsLogData.push(thumb.url);
            }
            collection.loadMissingData({
                positions: positions
            });
            logIncreaseResults(thumbsFromPickupCacheLogData, thumbsFromRemovedCacheLogData, blacklistedTumbsLogData);
            var isSecondRunNeeded = !isSecondRun && indexToAdd !== newCount;
            if (isSecondRunNeeded) {
                logger.info("Not enough tumbs, trying to remove default thumbs from blacklist");
                blacklist.remove(branding.thumbs.items).then(function() {
                    populatePickupCache(function() {
                        increase(newCount, true);
                    });
                });
            }
        });
    }
    function logIncreaseResults(thumbsFromPickupCache, thumbsFromRemovedCache, blacklistedTumbs) {
        [ [ thumbsFromPickupCache, "Thumbs being taken from pickup cache: %s" ], [ thumbsFromRemovedCache, "Thumbs being taken from removed cache: %s" ], [ blacklistedTumbs, "Thumbs being filtered by blacklist: %s" ] ].forEach(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), thumbs = _ref2[0], log = _ref2[1];
            if (thumbs.length) logger.info(log, thumbs.join(", "));
        });
    }
    function createThumbFromPickupCache() {
        var cacheItem = shiftFromPickupCache();
        if (cacheItem) {
            var thumb = new Thumb(cacheItem.url);
            thumb.visits = cacheItem.visits || 0;
            return thumb;
        }
        return null;
    }
    function decrease(newCount) {
        logger.info("Decrease count from %i to %i", collection.length, newCount);
        var positions = [];
        var urls = [];
        for (var i = collection.length - 1; i >= newCount; i--) {
            var thumb = collection.getItem(i);
            if (thumb) {
                removedThumbsCache.unshift(thumb);
                collection.removeItem(i);
                positions.push(i);
                urls.push(thumb.url);
            }
        }
        logger.info("Thumbs %s were removed", urls.join(" "));
    }
    function populatePickupCache(callback) {
        candidates.get({
            fast: true,
            useTopSites: true
        }, function(items) {
            logger.info("Pickup cache loaded: %i", items ? items.length : null);
            pickupCache = items || null;
            callback();
        });
    }
    function shiftFromPickupCache() {
        if (!pickupCache) return;
        while (pickupCache.length) {
            var item = pickupCache.shift();
            var domain = urlUtils.getNormalDomain(item.url);
            if (!collection.hasDomain(domain)) return item;
        }
    }
    function clearCache() {
        pickupCache = null;
        removedThumbsCache.length = 0;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var platformAbout = __webpack_require__(23);
    var brandedSites = __webpack_require__(394);
    var collection = __webpack_require__(270);
    var getTopHistory = __webpack_require__(395);
    var topSites = __webpack_require__(397);
    var _ = __webpack_require__(91);
    var blacklist = __webpack_require__(398);
    var candidatesStorage = __webpack_require__(401);
    var safebrowsing = __webpack_require__(403);
    var sorter = __webpack_require__(402);
    var logger = __webpack_require__(5).create("Pickup/candidates");
    var TOP_HISTORY_PARAMS = {
        minVisits: 3,
        maxResults: 100,
        days: 20
    };
    var INTERNAL_PROTOCOLS = [ "moz-extension", "about" ];
    var INTERNAL_URLS = [ platformAbout.visbookmarksUrl ];
    exports.get = function(options, callback) {
        getAllCandidates({
            useTopSites: options.useTopSites
        }, function(items) {
            filterCandidates({
                fast: options.fast
            }, items, function(filteredItems) {
                filteredItems.sort(sorter);
                if (options.useTopSites) filteredItems = topSites.setVisits(filteredItems);
                candidatesStorage.save(filteredItems);
                callback(filteredItems);
            });
        });
    };
    exports.getFromStorage = function(callback) {
        candidatesStorage.get(callback);
    };
    function getAllCandidates(options, callback) {
        options = options || {};
        var branded = brandedSites.get();
        logger.info("Branded sites: %i", branded.length);
        var unpinned = getCurrent({
            pinned: false
        });
        logger.info("Current unpinned thumbs: %i", unpinned.length);
        getTopHistory(TOP_HISTORY_PARAMS, function(historyItems) {
            logger.info("Top history count: %i", historyItems.length);
            var items = [].concat(historyItems, branded, unpinned);
            if (options.useTopSites) topSites.get(function(err, topSiteItems) {
                if (Array.isArray(topSiteItems)) {
                    logger.info("Top sites count: %i", topSiteItems.length);
                    items = items.concat(topSiteItems);
                }
                callback(items);
            }); else callback(items);
        });
    }
    function filterCandidates(options, items, callback) {
        var filtered = applyFilters(items, [ setDomain, filterEmptyURI, filterInternalURI, removeSameDomains, removePinnedDomains ]);
        removeBlacklistDomains(filtered, function(filtered) {
            removeUnsafeDomains(options, filtered, callback);
        });
    }
    function getCurrent(options) {
        options = _.defaults({}, options, {
            pinned: false
        });
        return collection.toArray().filter(function(item) {
            return Boolean(item.thumb.pinned) === options.pinned;
        }).map(function(item) {
            return {
                url: item.thumb.url,
                visits: item.thumb.visits,
                position: item.position
            };
        });
    }
    function applyFilters(items, filterFns) {
        return filterFns.reduce(function(res, fn) {
            return fn(res);
        }, items);
    }
    function setDomain(items) {
        return items.map(function(item) {
            item.uri = utils.url.createURI(item.url);
            item.domain = utils.url.getNormalDomain(item.url);
            return item;
        });
    }
    function filterEmptyURI(items) {
        return items.filter(function(item) {
            return Boolean(item.uri) && Boolean(item.domain);
        });
    }
    function filterInternalURI(items) {
        return items.filter(function(item) {
            return INTERNAL_PROTOCOLS.indexOf(item.uri.protocol()) === -1 && INTERNAL_URLS.indexOf(item.url) === -1;
        });
    }
    function removeSameDomains(items) {
        var domainGroups = _.groupBy(items, "domain");
        return _.map(domainGroups, function(group, domain) {
            var mainItemForDomain = _.filter(group, {
                topSite: true
            })[0];
            if (!mainItemForDomain) mainItemForDomain = _.max(group, "visits");
            if (group.length > 1) {
                var reason = mainItemForDomain.topSite ? "topsite" : "maxVisits=" + mainItemForDomain.visits;
                logger.info("Found %i sites for domain %s. Use as main site (%s): %s", group.length, domain, reason, mainItemForDomain.url);
            }
            group.filter(function(item) {
                return utils.url.isEqualUrls(item.uri, mainItemForDomain.uri);
            }).forEach(function(item) {
                if (!_.isNumber(mainItemForDomain.position) && _.isNumber(item.position)) mainItemForDomain.position = item.position;
                if (!_.isNumber(mainItemForDomain.index) && _.isNumber(item.index)) mainItemForDomain.index = item.index;
            });
            return mainItemForDomain;
        });
    }
    function removeBlacklistDomains(items, callback) {
        blacklist.createChecker(function(blacklistChecker) {
            items = items.filter(function(item) {
                var inBlacklist = blacklistChecker.contains(item.url);
                if (inBlacklist) logger.info("Blacklisted: %s", item.url);
                return !inBlacklist;
            });
            callback(items);
        });
    }
    function removePinnedDomains(items) {
        var pinned = getCurrent({
            pinned: true
        });
        pinned = setDomain(pinned);
        var pinnedDomains = _.groupBy(pinned, "domain");
        return items.filter(function(item) {
            return !(item.domain in pinnedDomains);
        });
    }
    function removeUnsafeDomains(options, items, callback) {
        var domains = items.filter(function(item) {
            return !(item.branded && _.isNumber(item.position));
        }).map(function(item) {
            return item.domain;
        });
        safebrowsing.checkDomains(options, domains, function(err, unsafeDomains) {
            if (err) {
                logger.error(err.message);
                callback(items);
                return;
            }
            if (unsafeDomains && Object.keys(unsafeDomains).length) items = items.filter(function(item) {
                var isUnsafe = item.domain in unsafeDomains;
                if (isUnsafe) logger.info("Removed as unsafe: %s", item.url);
                return !isUnsafe;
            });
            callback(items);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var branding = __webpack_require__(277);
    var curly = __webpack_require__(207);
    var platformAbout = __webpack_require__(23);
    exports.get = function() {
        return branding.thumbs.items.map(function(item, index) {
            return {
                url: curly.insertUrlVars(item.url, {
                    vbID: platformAbout.type
                }),
                index: index,
                pinned: Boolean(item.pinned),
                visits: item.boost || branding.thumbs.boost,
                branded: true
            };
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _ = __webpack_require__(91);
    var error = __webpack_require__(396);
    var dateUtils = __webpack_require__(4);
    var DEFAULT_OPTIONS = {
        minVisits: 3,
        maxResults: 100,
        days: 20
    };
    function isValidItem(historyItem, options) {
        if (historyItem.visitCount < options.minVisits) return false;
        if (!historyItem.title) return false;
        if (!/^(http|ftp)s?/.test(historyItem.url)) return false;
        return true;
    }
    module.exports = function(options, callback) {
        options = _.defaults({}, options, DEFAULT_OPTIONS);
        chrome.history.search({
            text: "",
            maxResults: options.maxResults,
            startTime: Date.now() - options.days * dateUtils.DAY_MS
        }, error.wrap(function(records) {
            var output = records.filter(function(historyItem) {
                return isValidItem(historyItem, options);
            }).map(function(historyItem) {
                return {
                    url: historyItem.url,
                    title: historyItem.title,
                    lastVisitTime: historyItem.lastVisitTime,
                    visits: historyItem.visitCount,
                    history: true
                };
            });
            callback(output);
        }));
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var platformAbout = __webpack_require__(23);
    var platformBuildInfo = __webpack_require__(20);
    var buildData = __webpack_require__(218);
    var isChromeDebug = "chr" === platformAbout.id && (platformBuildInfo.isDebug() || !buildData.git.release);
    var logger = __webpack_require__(5).create("Core");
    module.exports = {
        attach: function(win) {
            win.onerror = function(msg, url, line, symbol, exception) {
                var msgError = msg + " in " + url + " (line: " + line + ", symbol: " + symbol + ")";
                if (exception && exception.stack) msgError += " \nSTACK: " + exception.stack;
                logger.error(msgError);
                if (isChromeDebug) window.alert(msgError);
            };
        },
        wrap: function(fn) {
            if ("chr" !== platformAbout.id || isChromeDebug) return fn; else return function() {
                var args = arguments;
                if (chrome.runtime.lastError) ;
                setTimeout(function() {
                    fn.apply(null, args);
                }, 0);
            };
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Pickup/top-sites");
    var COUNT = 8;
    var BOOST_DELTA = 10;
    exports.get = function(callback) {
        chrome.topSites.get(function(items) {
            if (chrome.runtime.lastError) callback(chrome.runtime.lastError); else if (!Array.isArray(items)) callback(new Error("top sites is not array")); else {
                items = items.slice(0, COUNT).map(formatItem);
                callback(null, items);
            }
        });
    };
    exports.setVisits = function(items) {
        var firstNonTopSite = items.find(function(item) {
            return !item.topSite;
        });
        var maxVisits = firstNonTopSite && firstNonTopSite.visits || 0;
        var topSiteVisits = maxVisits + BOOST_DELTA;
        logger.info("Setting visits: %i + %i(boost) = %i", maxVisits, BOOST_DELTA, topSiteVisits);
        return items.map(function(item) {
            if (item.topSite) item.visits = topSiteVisits;
            return item;
        });
    };
    function formatItem(item, index) {
        item.index = index;
        item.topSite = true;
        return item;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var local = __webpack_require__(349);
    var remote = __webpack_require__(399);
    var branding = __webpack_require__(277);
    var BlacklistChecker = __webpack_require__(400);
    var logger = __webpack_require__(5).create("Blacklist");
    var asyncLib = __webpack_require__(209);
    module.exports = {
        init: function() {
            remote.init();
        },
        remove: function(items) {
            return new Promise(function(resolve) {
                asyncLib.map(items, function(item, callback) {
                    var domain = utils.url.getNormalDomain(item.url);
                    local.deleteOne(domain, callback);
                }, resolve);
            });
        },
        createChecker: function(callback) {
            var brandedData = branding.blacklist;
            var remoteData = remote.get();
            local.get(function(err, localDomains) {
                if (err) {
                    logger.warn("Can not get local blacklist");
                    localDomains = [];
                }
                var domains = [].concat(brandedData.domains).concat(remoteData.domains).concat(localDomains).map(utils.url.getNormalDomain).filter(Boolean);
                var regexps = [].concat(brandedData.regexps).concat(remoteData.regexps).map(function(regexp) {
                    return new RegExp(regexp, "i");
                });
                callback(new BlacklistChecker(domains, regexps));
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var utils = __webpack_require__(30);
    var alarms = __webpack_require__(3);
    var settings = __webpack_require__(216);
    var xml = __webpack_require__(61);
    var xhr = __webpack_require__(32);
    var logger = __webpack_require__(5).create("Blacklist/remote");
    var SERVER_URL = "https://download.cdn.yandex.net/bar/vb/bl.xml";
    var ALARM = {
        name: "blacklistSync",
        periodInMinutes: 24 * 60
    };
    module.exports = {
        init: function() {
            alarms.register(ALARM, this.updateFromServer.bind(this));
        },
        get: function() {
            var storageData = settings.get("blacklist");
            return storageData || {
                domains: [],
                regexps: []
            };
        },
        updateFromServer: function(callback) {
            callback = callback || utils.noop;
            xhr({
                url: SERVER_URL,
                logError: true,
                parse: "xml"
            }, function(err, xml, evt) {
                if (err) {
                    callback(err);
                    return;
                }
                var hasListNode = xml && xml.documentElement && "list" === xml.documentElement.nodeName;
                if (!hasListNode) {
                    logger.warn("Invalid XML: %l" + evt.target.responseText);
                    callback(new Error());
                    return;
                }
                parseXML(xml).then(function(data) {
                    if (data) {
                        settings.set("blacklist", data);
                        logger.info("Updated, %i domain(s) %i regexp(s)", data.domains.length, data.regexps.length);
                        callback(null, data);
                    } else {
                        logger.warn("Can not parse XML: %l", evt.target.responseText);
                        callback(new Error());
                    }
                });
            });
        }
    };
    function parseXML(responseXML) {
        var output = {
            domains: [],
            regexps: []
        };
        return xml.selectAll("list > item", responseXML).then(function(items) {
            Promise.all([ items.map(function(item) {
                return Promise.all([ xml.getAttr(item, "domain"), xml.getAttr(item, "url_regex") ]).then(function(results) {
                    var _results = _slicedToArray(results, 2), domain = _results[0], regexp = _results[1];
                    if (domain) output.domains.push(domain);
                    if (regexp) output.regexps.push(regexp);
                });
            }) ]);
        }).finally(function() {
            return output;
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var urlUtils = __webpack_require__(83);
    function BlacklistChecker(domains, regexps) {
        this.domains = domains;
        this.regexps = regexps;
    }
    BlacklistChecker.prototype.contains = function(url, domain) {
        domain = domain || urlUtils.getNormalDomain(url);
        return checkByDomains(domain, this.domains) || checkByRegexps(url, this.regexps);
    };
    function checkByDomains(domain, domainList) {
        return domainList.indexOf(domain) !== -1;
    }
    function checkByRegexps(url, regexpList) {
        return regexpList.some(function(regexp) {
            return regexp.test(url);
        });
    }
    module.exports = BlacklistChecker;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var database = __webpack_require__(295);
    var sorter = __webpack_require__(402);
    var logger = __webpack_require__(5).create("Pickup/candidates-storage");
    var TABLE = "pickup";
    module.exports = {
        save: function(items, callback) {
            callback = callback || utils.noop;
            if (!Array.isArray(items)) {
                var message = "Can not save non-array";
                logger.error(message);
                callback(new Error(message));
            }
            var dbItems = items.filter(function(item) {
                return Boolean(item.url);
            }).map(function(item) {
                return {
                    url: item.url,
                    visits: item.visits,
                    index: item.index
                };
            });
            logger.info("Saving candidates cache, %i item(s)", dbItems.length);
            database.clearAndInsert(TABLE, dbItems, callback);
        },
        get: function(callback) {
            database.get(TABLE, {}, function(err, records) {
                if (err) callback(err); else {
                    logger.info("Loaded from db: %i", records.length);
                    records.sort(sorter);
                    callback(null, records);
                }
            });
        }
    };
}, function(module, exports) {
    "use strict";
    module.exports = function(a, b) {
        if (a.topSite || b.topSite) {
            var topIndexA = a.topSite ? a.index : 1 / 0;
            var topIndexB = b.topSite ? b.index : 1 / 0;
            return topIndexA - topIndexB || 0;
        } else if (void 0 !== a.visits && void 0 !== b.visits && b.visits !== a.visits) return b.visits - a.visits; else if (void 0 !== a.position || void 0 !== b.position) {
            var posA = void 0 !== a.position ? a.position : -(1 / 0);
            var posB = void 0 !== b.position ? b.position : -(1 / 0);
            return posB - posA || 0;
        } else if (void 0 !== a.index || void 0 !== b.index) {
            var indexA = void 0 !== a.index ? a.index : 1 / 0;
            var indexB = void 0 !== b.index ? b.index : 1 / 0;
            return indexA - indexB || 0;
        } else return 0;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var logger = __webpack_require__(5).create("Safe browsing");
    var SBA_API_URL = "https://sba.yandex.net/cp?pver=4.0&client=yachbookmarks&json=1";
    var FAST_TIMEOUT_MS = 500;
    module.exports = {
        checkDomains: function(options, domains, callback) {
            callback = callback || utils.noop;
            utils._.defaults(options, {
                fast: false
            });
            if (!Array.isArray(domains) || !domains.length) {
                callback();
                return;
            }
            logger.info("Checking %i domains with options %j", domains.length, options);
            var postData = domains.map(function(domain) {
                return encodeURIComponent(domain);
            }).join(",");
            utils.xhr({
                url: SBA_API_URL,
                body: postData,
                logError: true,
                parse: "json",
                timeout: options.fast ? FAST_TIMEOUT_MS : null
            }, function(err, json) {
                if (err || !json) {
                    callback(err || new Error("invalid json"));
                    return;
                }
                var unsafeDomains = Object.keys(json).reduce(function(memo, key) {
                    if ("adult" === json[key]) memo[key] = true;
                    return memo;
                }, {});
                logger.info("Unsafe domains found: %i", Object.keys(unsafeDomains).length);
                callback(err, unsafeDomains);
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Backup/restore");
    var settings = __webpack_require__(216);
    var Thumb = __webpack_require__(271);
    var collection = __webpack_require__(270);
    var channel = __webpack_require__(27);
    exports.restore = function(data) {
        try {
            restoreSettings(data.settings);
            var isOk = restoreThumbs(data.thumbs);
            if (isOk) exports.onRestored.dispatch();
            return isOk;
        } catch (e) {
            throw new Error("Can not restore state, " + e);
        }
    };
    exports.onRestored = channel.create();
    function restoreSettings(settingsData) {
        Object.keys(settingsData).forEach(function(key) {
            settings.set(key, settingsData[key]);
        });
    }
    function restoreThumbs(thumbsData) {
        var restored = false;
        if (!thumbsData.length) {
            logger.info("Empty thumbs data, nothing to restore.");
            return restored;
        }
        collection.clear();
        thumbsData.forEach(function(item, position) {
            var thumb;
            try {
                thumb = Thumb.fromJSON(item);
                restored = true;
            } catch (e) {
                return;
            }
            logger.info("Restore thumb %i %s", position, thumb.url);
            collection.setItem(position, thumb);
        });
        collection.loadMissingData({
            force: true
        });
        return restored;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var getCurrentData = __webpack_require__(406);
    var backupRestore = __webpack_require__(404);
    var readAsJson = __webpack_require__(267).readAsJson;
    var fetch = __webpack_require__(72);
    var Channel = __webpack_require__(27);
    module.exports = {
        make: function() {
            try {
                var data = JSON.stringify(getCurrentData(), null, 2);
                this.onMade.dispatch();
                return "data:application/x-backup," + encodeURIComponent(data);
            } catch (e) {
                return null;
            }
        },
        load: function(url) {
            var _this = this;
            return this._loadData(url).then(readAsJson).then(backupRestore.restore).then(function() {
                return _this.onLoaded.dispatch();
            });
        },
        _loadData: function(url) {
            return fetch(url, {
                logError: true,
                responseType: "blob"
            });
        },
        onLoaded: new Channel("onLoad"),
        onMade: new Channel("onMade")
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var collection = __webpack_require__(270);
    var settings = __webpack_require__(216);
    var SETTING_NAMES = __webpack_require__(407).SETTING_NAMES;
    module.exports = function() {
        return {
            thumbs: getThumbs(),
            settings: getSettings()
        };
    };
    function getSettings() {
        return SETTING_NAMES.reduce(function(memo, name) {
            memo[name] = settings.get(name);
            return memo;
        }, {});
    }
    function getThumbs() {
        return collection.items.map(makeThumbObject);
    }
    function makeThumbObject(item) {
        return {
            url: item.url,
            title: item.title,
            pinned: item.pinned,
            visits: item.visits
        };
    }
}, function(module, exports) {
    "use strict";
    exports.SETTING_NAMES = [ "showBookmarks", "showSearchForm", "showAdvertisement", "showInformers", "uiThumbsType", "geolocation", "sendUsageStat", "backgroundRotation" ];
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Block = __webpack_require__(374);
    var frontendSettings = __webpack_require__(388);
    var ID = "vbfilebackup";
    var CONFIG = {
        maxShownCount: 1,
        maxRefuseCount: 0,
        duration: 1,
        interval: 0,
        silent: 10,
        afterInstall: 0
    };
    module.exports = function() {
        var block = new Block(ID, CONFIG);
        block.setChecker(checker.bind(null, block));
        frontendSettings.onRequested.addListener(onSettingsRequested.bind(null, block));
        return block;
    };
    function checker(block) {
        block.updateNeedShowing(true);
    }
    function onSettingsRequested(block) {
        if (block.isShowing()) block.refuse(Block.REFUSE_REASON.ACCEPT);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Block = __webpack_require__(374);
    var settings = __webpack_require__(216);
    var _require = __webpack_require__(410), IS_VOICE_USED = _require.IS_VOICE_USED;
    var i18n = __webpack_require__(280);
    var ID = "vbvoice";
    var CONFIG = {
        maxShownCount: 1,
        maxRefuseCount: 0,
        duration: 1,
        interval: 0,
        silent: 10,
        afterInstall: 0
    };
    module.exports = function() {
        var block = new Block(ID, CONFIG);
        block.setChecker(function() {
            return checker(block);
        });
        updateEnabled(block);
        listenSearchFormVisibility(block);
        return block;
    };
    function checker(block) {
        var isVoiceUsed = true === settings.get(IS_VOICE_USED);
        var isRuLocale = "ru" === i18n.browserLocale;
        block.updateNeedShowing(!isVoiceUsed && isRuLocale);
    }
    function listenSearchFormVisibility(block) {
        settings.onChanged.addListener(function(info) {
            if ("showSearchForm" === info.key) updateEnabled(block);
        });
    }
    function updateEnabled(block) {
        block.updateEnabled(settings.get("showSearchForm"));
    }
}, function(module, exports) {
    "use strict";
    exports.STATUS = {
        READY: 0,
        CONNECTING: 1,
        RECORD: 2,
        PROCESSING: 3,
        FINISHED: 4,
        INTERRUPTED: 5,
        ERROR: 6
    };
    exports.API_KEY = "ea0ff746-a756-4bd9-882d-0ab983fae8a8";
    exports.ERROR_REASON = {
        SILENCE: "silence"
    };
    exports.ANIMATION_TIMEOUT_MS = 1200;
    exports.UTTERANCE_SILENCE = 60;
    exports.SILENCE_TIMEOUT_MS = 1e3 * 8;
    exports.IS_VOICE_USED = "isVoiceUsed";
}, function(module, exports, __webpack_require__) {
    "use strict";
    var watcher = __webpack_require__(412);
    var clients = __webpack_require__(413);
    exports.init = function() {
        watcher.init();
        clients.init();
    };
    exports.tryRestoreFromCookies = function() {
        return clients.cookies.tryRestore();
    };
    exports.clear = function() {
        return Promise.all([ clients.cookies.clear(), clients.files.clear() ]);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var collection = __webpack_require__(270);
    var settings = __webpack_require__(216);
    var channel = __webpack_require__(27);
    var alarms = __webpack_require__(3);
    var _ = __webpack_require__(91);
    var getCurrentData = __webpack_require__(406);
    var SETTING_NAMES = __webpack_require__(407).SETTING_NAMES;
    var STORE_DELAY_MS = 5e3;
    var ALARM = {
        name: "backup",
        periodInMinutes: 60 * 24
    };
    exports.init = function() {
        resetChangesInfo();
        collection.onChanged.addListener(function() {
            changesInfo.thumbsChanged = true;
            store();
        });
        settings.onChanged.addListener(function(info) {
            if (SETTING_NAMES.indexOf(info.key) !== -1) {
                changesInfo.settings[info.key] = info.newValue;
                store();
            }
        });
        alarms.register(ALARM, function() {
            changesInfo.forced = true;
            store();
        });
    };
    exports.onChanged = channel.create();
    var changesInfo;
    function resetChangesInfo() {
        changesInfo = Object.create(null);
        changesInfo.settings = Object.create(null);
        changesInfo.thumbsChanged = false;
        changesInfo.forced = false;
    }
    var previousState;
    var store = _.debounce(function() {
        var data = getCurrentData();
        var state = JSON.stringify(data);
        if (!changesInfo.forced && state === previousState) return;
        previousState = state;
        data.changesInfo = changesInfo;
        resetChangesInfo();
        onChanged(data);
    }, STORE_DELAY_MS);
    function onChanged(data) {
        exports.onChanged.dispatch(data);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.files = __webpack_require__(414);
    exports.cookies = __webpack_require__(415);
    exports.yabrowser = __webpack_require__(419);
    exports.init = function() {
        exports.files.init();
        exports.cookies.init();
        exports.yabrowser.init();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _ = __webpack_require__(91);
    var logger = __webpack_require__(5).create("Backup/files");
    var watcher = __webpack_require__(412);
    var backupRestore = __webpack_require__(404);
    var fileStorage = __webpack_require__(264);
    var dateUtils = __webpack_require__(4);
    var DIR_NAME = "backups";
    var MAX_FILES_NUMBER = 10;
    var FILE_PATH_RE = /\/(\d{4}\-\d{2}\-\d{2})\.json$/;
    exports.init = function() {
        fileStorage.createDirectory("/backups/");
        watcher.onChanged.addListener(onChanged);
    };
    exports.tryRestore = function(stateName) {
        if (0 === arguments.length) return getNewsetState().then(function(state) {
            return state ? exports.tryRestore(state) : Promise.resolve(false);
        });
        return readState(stateName).then(function(dataFromStorage) {
            logger.info("Restoring backup from file %s with content %j", stateName, dataFromStorage);
            return backupRestore.restore(dataFromStorage);
        });
    };
    exports.list = function() {
        return new Promise(function(resolve, reject) {
            fileStorage.list(DIR_NAME, function(error, files) {
                if (error) {
                    reject(error);
                    return;
                }
                var states = files.map(function(file) {
                    var dateMatch = file.match(FILE_PATH_RE);
                    return dateMatch && dateMatch[1];
                }).filter(Boolean).sort().reverse().slice(0, MAX_FILES_NUMBER);
                resolve(states);
            });
        });
    };
    exports.clear = function() {
        return new Promise(function(resolve, reject) {
            fileStorage.remove(DIR_NAME, function(error) {
                if (error && error.code !== error.NOT_FOUND_ERR) reject(error); else resolve();
            });
        });
    };
    function onChanged(data) {
        var stateName = dateUtils.format(new Date(), "%Y-%M-%D");
        var state = {
            data: JSON.stringify({
                thumbs: data.thumbs,
                settings: data.settings
            })
        };
        fileStorage.write(makeFilePath(stateName), state, _.noop);
        cleanupOldFiles();
    }
    function getNewsetState() {
        return exports.list().then(function(states) {
            return Promise.resolve(states[0]);
        });
    }
    function readState(stateName) {
        return new Promise(function(resolve, reject) {
            fileStorage.readAsText(makeFilePath(stateName), function(error, fileContent) {
                var data;
                if (!error) try {
                    data = JSON.parse(fileContent);
                } catch (e) {
                    error = e;
                }
                if (error) reject(error); else resolve(data);
            });
        });
    }
    function makeFilePath(stateName) {
        return DIR_NAME + "/" + stateName + ".json";
    }
    var cleanupOldFiles = _.throttle(function() {
        fileStorage.list(DIR_NAME, function(error, files) {
            if (error) return;
            var filesToRemove = files.filter(function(file) {
                return !FILE_PATH_RE.test(file);
            });
            files = _.difference(files, filesToRemove);
            filesToRemove = filesToRemove.concat(files.sort().reverse().slice(MAX_FILES_NUMBER));
            filesToRemove.forEach(function(file) {
                fileStorage.remove(file, _.noop);
            });
        });
    }, dateUtils.DAY_MS);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _ = __webpack_require__(91);
    var logger = __webpack_require__(5).create("Backup/cookies");
    var watcher = __webpack_require__(412);
    var backupRestore = __webpack_require__(404);
    var backupThumbs = __webpack_require__(416);
    var backupSettings = __webpack_require__(418);
    var backupStorage = __webpack_require__(417);
    exports.init = function() {
        backupThumbs.init();
        backupSettings.init();
        watcher.onChanged.addListener(store);
    };
    exports.tryRestore = function() {
        return backupStorage.read().then(function(data) {
            var dataFromStorage = {
                thumbs: backupThumbs.convertDataFromStorage(data),
                settings: backupSettings.convertDataFromStorage(data)
            };
            logger.info("Restoring backup from cookie(s) %j", dataFromStorage);
            return backupRestore.restore(dataFromStorage);
        });
    };
    exports.clear = function() {
        return backupStorage.clear();
    };
    function store(data) {
        var thumbs = backupThumbs.convertDataForStorage(data.thumbs);
        var settings = backupSettings.convertDataForStorage(data.settings);
        var dataForStorage = _.merge({}, settings, thumbs);
        logger.info("Storing backup to cookie(s)");
        backupStorage.write(dataForStorage);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var YsSerializer = __webpack_require__(340);
    var backupStorage = __webpack_require__(417);
    var COOKIE_NAME_PREFIX = "thumb";
    var serializer;
    exports.init = function() {
        serializer = new YsSerializer({
            partsDelimiter: "#",
            keyValueDelimiter: "."
        });
    };
    exports.convertDataFromStorage = function(data) {
        return restoreThumbsData(data);
    };
    exports.convertDataForStorage = function(data) {
        return data.reduce(function(res, thumb, position) {
            var name = getCookieName(position);
            res[name] = getCookieValue(thumb);
            return res;
        }, {});
    };
    function restoreThumbsData(data) {
        return Object.keys(data).reduce(function(res, cookieName) {
            var position = getPositionByCookieName(cookieName);
            if (!isNaN(position)) {
                var cookieValue = data[cookieName];
                var parts = parseCookieValue(cookieValue);
                var thumb = convertPartsToThumbJson(parts);
                res[position] = thumb;
            }
            return res;
        }, []).filter(Boolean);
    }
    function convertPartsToThumbJson(parts) {
        return {
            url: parts.url,
            title: parts.title,
            pinned: parseInt(parts.pin, 10) || 0,
            visits: parseInt(parts.visits, 10) || 0
        };
    }
    function getCookieValue(thumb) {
        var res = "";
        res = serializer.addPart(res, "pin", thumb.pinned ? 1 : 0);
        res = serializer.addPart(res, "visits", thumb.visits || 0);
        res = serializer.addPart(res, "url", thumb.url || "");
        res = tryAddTitle(res, thumb);
        return res;
    }
    function tryAddTitle(res, thumb) {
        if (thumb.title) {
            res = serializer.addPart(res, "title", thumb.title);
            if (res.length > backupStorage.MAX_COOKIE_SIZE) res = serializer.deletePart(res, "title");
        }
        return res;
    }
    function parseCookieValue(value) {
        var parts = serializer.getValues(value);
        return parts.reduce(function(res, part) {
            res[part.key] = part.value;
            return res;
        }, {});
    }
    function getPositionByCookieName(cookieName) {
        if (0 === cookieName.indexOf(COOKIE_NAME_PREFIX)) return parseInt(cookieName.replace(COOKIE_NAME_PREFIX, ""), 10); else return NaN;
    }
    function getCookieName(position) {
        return COOKIE_NAME_PREFIX + position;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Backup/cookies/storage");
    var thenChrome = __webpack_require__(283);
    var SCHEMA = "http://";
    var DOMAIN_TPL = "backup{index}.vb.yandex.addons";
    var STARTING_DOMAIN_INDEX = 1;
    var MAX_COOKIE_SIZE = 5e3;
    var MAX_TOTAL_COOKIE_SIZE_PER_DOMAIN = 1e4;
    var EXPIRE_PERIOD = 3 * 24 * 60 * 60;
    exports.MAX_COOKIE_SIZE = MAX_COOKIE_SIZE;
    exports.read = function() {
        return readRawCookies().then(rawCookies2Obj);
    };
    exports.write = function(data) {
        return exports.clear().then(function() {
            return write(data);
        });
    };
    exports.clear = function() {
        return readRawCookies().then(function(cookies) {
            var tasks = cookies.map(removeCookie);
            return Promise.all(tasks);
        });
    };
    function write(data) {
        var savedBytesForDomain = 0;
        var domainIndex = STARTING_DOMAIN_INDEX;
        var expirationDate = Math.round(Date.now() / 1e3) + EXPIRE_PERIOD;
        data = removeInvalidCookies(data);
        var promises = [];
        Object.keys(data).forEach(function(cookieName) {
            var cookieValue = data[cookieName];
            savedBytesForDomain += cookieValue.length;
            if (savedBytesForDomain > MAX_TOTAL_COOKIE_SIZE_PER_DOMAIN) {
                domainIndex++;
                savedBytesForDomain = cookieValue.length;
            }
            var url = getUrl(domainIndex);
            promises.push(writeCookie(url, cookieName, cookieValue, expirationDate));
        });
        return Promise.all(promises);
    }
    function readRawCookies() {
        var logData = [];
        return function read(domainIndex, rawCookies) {
            var domain = getDomain(domainIndex);
            return thenChrome.cookies.getAll({
                domain: domain
            }).then(function(newItems) {
                newItems = newItems || [];
                var result = rawCookies.concat(newItems);
                var count = newItems.length;
                if (count) logData.push(domain + " (" + count + ")");
                return count ? read(domainIndex + 1, result) : result;
            });
        }(STARTING_DOMAIN_INDEX, []).then(function(result) {
            logger.info("Cookie(s) were read for domains: %s", logData.join(", "));
            return result;
        });
    }
    function rawCookies2Obj(cookies) {
        return cookies.reduce(function(res, item) {
            res[item.name] = item.value;
            return res;
        }, {});
    }
    function getUrl(domainIndex) {
        return SCHEMA + getDomain(domainIndex);
    }
    function getDomain(domainIndex) {
        return DOMAIN_TPL.replace("{index}", domainIndex);
    }
    function removeInvalidCookies(data) {
        return Object.keys(data).reduce(function(res, cookieName) {
            if (!cookieName) return res;
            var cookieValue = data[cookieName];
            if (cookieValue.length > MAX_COOKIE_SIZE) logger.warn("Cookie %s size %i is over limit %i", cookieName, cookieValue.length, MAX_COOKIE_SIZE); else if (cookieValue) res[cookieName] = cookieValue;
            return res;
        }, {});
    }
    function writeCookie(url, name, value, expirationDate) {
        return thenChrome.cookies.set({
            url: url,
            name: name,
            value: value,
            expirationDate: expirationDate
        });
    }
    function removeCookie(cookie) {
        return thenChrome.cookies.remove({
            url: SCHEMA + cookie.domain,
            name: cookie.name
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _ = __webpack_require__(91);
    var logger = __webpack_require__(5).create("Backup/cookies/settings");
    var YsSerializer = __webpack_require__(340);
    var SETTINGS_COOKIE_NAME = "settings";
    var DISPLAY_MODE_SETTING_NAME = "uiThumbsType";
    var DISPLAY_MODE_MAP = {
        titles: 1,
        logos: 2,
        screenshots: 3
    };
    var serializer;
    exports.init = function() {
        serializer = new YsSerializer({
            partsDelimiter: "#",
            keyValueDelimiter: "."
        });
    };
    exports.convertDataFromStorage = function(data) {
        var settings = {};
        if (data[SETTINGS_COOKIE_NAME]) {
            logger.info("Settings backup found");
            var parts = parseCookieValue(data[SETTINGS_COOKIE_NAME]);
            var value = parseInt(DISPLAY_MODE_MAP[parts.displayMode], 10);
            if (!isNaN(value)) settings[DISPLAY_MODE_SETTING_NAME] = value;
        } else logger.info("Settings backup not found");
        return settings;
    };
    exports.convertDataForStorage = function(data) {
        var cookieValue = "";
        var uiThumbsType = data[DISPLAY_MODE_SETTING_NAME];
        var displayMode = _.findKey(DISPLAY_MODE_MAP, function(value) {
            return value === uiThumbsType;
        });
        if (displayMode) cookieValue = serializer.addPart(cookieValue, "displayMode", displayMode);
        var res = {};
        res[SETTINGS_COOKIE_NAME] = cookieValue;
        return res;
    };
    function parseCookieValue(value) {
        var parts = serializer.getValues(value);
        return parts.reduce(function(res, part) {
            res[part.key] = part.value;
            return res;
        }, {});
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var watcher = __webpack_require__(412);
    var platform = __webpack_require__(334);
    var CURRENT_BG_SETTING = "backgroundImagePath";
    exports.init = function() {
        watcher.onChanged.addListener(onChanged);
    };
    function onChanged(data) {
        var changesInfo = data.changesInfo;
        if (changesInfo.forced || changesInfo.thumbsChanged || changesInfo.settings[CURRENT_BG_SETTING]) save(data);
    }
    function save(data) {
        var exportedData = {
            visibleCount: data.thumbs.length,
            pinned: data.thumbs.map(getExportedThumb).filter(Boolean),
            bg: data.settings[CURRENT_BG_SETTING]
        };
        platform.export(exportedData);
    }
    function getExportedThumb(item, position) {
        if (item.pinned && item.url) return {
            position: position,
            url: item.url,
            title: item.title
        };
        return false;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var collection = __webpack_require__(270);
    var settings = __webpack_require__(216);
    var candidatesStorage = __webpack_require__(401);
    var blacklistLocal = __webpack_require__(349);
    var excludeSettings = [ "settings.advertisementConfig", "settings.advertisementState", "settings.backgroundImagesList", "settings.blacklist", "settings.closedTabs", "settings.experimentConfigs", "settings.experiments", "settings.remoteConfig", "settings.searchExamples" ];
    exports.getThumbs = function() {
        return collection.items.map(function(thumb, position) {
            var res = thumb.toJSON();
            res.position = position;
            return res;
        });
    };
    exports.getSettings = function(all) {
        return Object.keys(settings.__items).filter(function(key) {
            return !all && excludeSettings.indexOf(key) === -1;
        }).map(function(key) {
            return {
                key: key,
                item: settings.__items[key]
            };
        }).sort(function(a, b) {
            return a.key > b.key ? 1 : -1;
        }).reduce(function(res, obj) {
            var key = obj.key.replace("settings.", "");
            var defaultStr = obj.item.isDefault ? " (default)" : "";
            res[key + defaultStr] = obj.item.value;
            return res;
        }, {});
    };
    exports.getPickupcache = function(callback) {
        candidatesStorage.get(callback);
    };
    exports.getBlacklistUser = function(callback) {
        blacklistLocal.get(callback);
    };
    exports.getBlacklistServer = function() {
        return settings.get("blacklist");
    };
    exports.getBg = function() {
        return settings.get("backgroundImagesList");
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var setNested = __webpack_require__(422);
    module.exports = {};
    try {
        module.exports.modules = getAllStuff(__webpack_require__(423));
        module.exports.utils = getAllStuff(__webpack_require__(558));
        module.exports.platform = getPlatform();
    } catch (e) {}
    function getAllStuff(context) {
        return context.keys().reduce(function(memo, name) {
            var filteredName = name.replace(/\.js$/, "").replace(/\.\//, "").replace(/\//g, ".").replace(/[^.\w]/g, "_");
            setNested(memo, filteredName, context(name));
            return memo;
        }, Object.create(null));
    }
    function getPlatform() {
        return {
            about: __webpack_require__(23),
            branding: __webpack_require__(278),
            build_info: __webpack_require__(20),
            clid: __webpack_require__(288),
            file_storage: __webpack_require__(264),
            locale: __webpack_require__(281),
            log: __webpack_require__(364)
        };
    }
}, function(module, exports, __webpack_require__) {
    var isIndex = __webpack_require__(56), isKey = __webpack_require__(119), isObject = __webpack_require__(44), toPath = __webpack_require__(121);
    function set(object, path, value) {
        if (null == object) return object;
        var pathKey = path + "";
        path = null != object[pathKey] || isKey(path, object) ? [ pathKey ] : toPath(path);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (null != nested && ++index < length) {
            var key = path[index];
            if (isObject(nested)) if (index == lastIndex) nested[key] = value; else if (null == nested[key]) nested[key] = isIndex(path[index + 1]) ? [] : {};
            nested = nested[key];
        }
        return object;
    }
    module.exports = set;
}, function(module, exports, __webpack_require__) {
    var map = {
        "./advertisement/atom.js": 424,
        "./advertisement/block.js": 374,
        "./advertisement/blocks/dailyback.js": 380,
        "./advertisement/blocks/newbackground.js": 386,
        "./advertisement/blocks/statoffer.js": 379,
        "./advertisement/blocks/vbaddthumb.js": 385,
        "./advertisement/blocks/vbfilebackup.js": 408,
        "./advertisement/blocks/vbsethome.js": 375,
        "./advertisement/blocks/vbsetsearch.js": 378,
        "./advertisement/blocks/vbvoice.js": 409,
        "./advertisement/group.js": 373,
        "./advertisement/index.js": 369,
        "./advertisement/remote-config-listener.js": 371,
        "./advertisement/ticker.js": 370,
        "./auth/index.js": 429,
        "./auth/redirector.js": 433,
        "./auth/user.js": 432,
        "./auth/users-collection.js": 431,
        "./auth/yauth-cookies.js": 425,
        "./auth/yauth.js": 430,
        "./backgrounds/branding-backgrounds.js": 356,
        "./backgrounds/cloud-backgrounds.js": 382,
        "./backgrounds/cloud-loader.js": 387,
        "./backgrounds/font-colors.js": 355,
        "./backgrounds/index.js": 390,
        "./backgrounds/request-all.js": 391,
        "./backgrounds/rotation.js": 381,
        "./backgrounds/selector.js": 384,
        "./backgrounds/storage.js": 354,
        "./backgrounds/user-background.js": 353,
        "./backup/clients.js": 413,
        "./backup/consts.js": 407,
        "./backup/cookies/index.js": 415,
        "./backup/cookies/settings.js": 418,
        "./backup/cookies/storage.js": 417,
        "./backup/cookies/thumbs.js": 416,
        "./backup/data-serializer.js": 406,
        "./backup/files/index.js": 414,
        "./backup/index.js": 411,
        "./backup/manual/index.js": 405,
        "./backup/restore.js": 404,
        "./backup/watcher.js": 412,
        "./backup/yandex-browser/index.js": 419,
        "./blacklist/blacklist-checker.js": 400,
        "./blacklist/blacklist.js": 398,
        "./blacklist/local.js": 349,
        "./blacklist/remote.js": 399,
        "./bookmarks/bookmarks.js": 220,
        "./branding/applier.js": 434,
        "./branding/blocks.js": 289,
        "./branding/index.js": 277,
        "./branding/remote/loader.js": 439,
        "./branding/remote/storage.js": 291,
        "./closed-tabs/closed-item.js": 321,
        "./closed-tabs/index.js": 307,
        "./closed-tabs/listener.js": 308,
        "./closed-tabs/restorator.js": 325,
        "./closed-tabs/sorter.js": 323,
        "./closed-tabs/state-storage.js": 327,
        "./closed-tabs/state.js": 326,
        "./cloud-logo/index.js": 274,
        "./cloud-logo/loader.js": 276,
        "./cloud-logo/saver.js": 275,
        "./common/constants.js": 440,
        "./cookies/bannerid.js": 337,
        "./cookies/gpauto.js": 441,
        "./cookies/utils.js": 449,
        "./cookies/yasoft.js": 450,
        "./cookies/ys.js": 451,
        "./custom-logo/index.js": 452,
        "./custom-logo/logo-saver.js": 453,
        "./database/database.js": 295,
        "./database/structure.js": 297,
        "./debug/advertisement.js": 368,
        "./debug/build-data.js": 218,
        "./debug/debug.js": 361,
        "./debug/file-structure.js": 421,
        "./debug/files.js": 362,
        "./debug/log.js": 363,
        "./debug/opener.js": 365,
        "./debug/state.js": 420,
        "./error/error.js": 396,
        "./experiments/actual-configs.js": 357,
        "./experiments/index.js": 328,
        "./favicon/index.js": 222,
        "./favicon/loader.js": 223,
        "./favicon/site.js": 225,
        "./favicon/yandex.js": 258,
        "./frontend/advertisement.js": 454,
        "./frontend/auth-formatter.js": 455,
        "./frontend/auth.js": 456,
        "./frontend/backgrounds.js": 389,
        "./frontend/bookmarks.js": 219,
        "./frontend/broken-tabs-reloader.js": 457,
        "./frontend/clicker.js": 458,
        "./frontend/closed-tabs.js": 460,
        "./frontend/custom-logo.js": 461,
        "./frontend/debug-panel.js": 360,
        "./frontend/events.js": 268,
        "./frontend/index.js": 462,
        "./frontend/informers.js": 484,
        "./frontend/init-checker.js": 497,
        "./frontend/init-sender.js": 214,
        "./frontend/logger.js": 463,
        "./frontend/messaging.js": 213,
        "./frontend/navigate-url.js": 480,
        "./frontend/pages-events.js": 493,
        "./frontend/panels.js": 472,
        "./frontend/scroll-state.js": 481,
        "./frontend/search-suggest.js": 482,
        "./frontend/settings-checkboxes.js": 215,
        "./frontend/settings-slider.js": 392,
        "./frontend/settings.js": 388,
        "./frontend/thumb-sender.js": 269,
        "./frontend/thumb-suggest.js": 469,
        "./frontend/thumbs.js": 464,
        "./frontend/url-suggest.js": 473,
        "./frontend/voice.js": 485,
        "./frontend/zen.js": 494,
        "./guide/actions-watcher.js": 498,
        "./guide/index.js": 499,
        "./host-permissions/index.js": 500,
        "./host-permissions/notification.js": 501,
        "./i18n/index.js": 280,
        "./informers/index.js": 302,
        "./informers/informer.js": 305,
        "./informers/quotes.js": 306,
        "./informers/reginfo.js": 304,
        "./informers/ticker.js": 303,
        "./maintenance/index.js": 502,
        "./migration/2.23.0.js": 348,
        "./migration/2.26.0.js": 503,
        "./migration/2.27.0.js": 504,
        "./migration/2.28.0.js": 505,
        "./migration/index.js": 506,
        "./navigations/index.js": 343,
        "./offscreen/colors-handler.js": 507,
        "./offscreen/events.js": 69,
        "./offscreen/filer-handler.js": 508,
        "./offscreen/messaging.js": 510,
        "./offscreen/speechkit-handler.js": 511,
        "./offscreen/xml-handler.js": 513,
        "./overrides_v3/filer.js": 265,
        "./pickup/apply.js": 436,
        "./pickup/branded-sites.js": 394,
        "./pickup/candidates-storage.js": 401,
        "./pickup/candidates.js": 393,
        "./pickup/force-thumbs.js": 437,
        "./pickup/pickup.js": 435,
        "./pickup/sorter.js": 402,
        "./pickup/top-history.js": 395,
        "./pickup/top-sites.js": 397,
        "./remote-config/index.js": 372,
        "./safebrowsing/safebrowsing.js": 403,
        "./screenshots/adjust.js": 352,
        "./screenshots/cache.js": 292,
        "./screenshots/screenshots.js": 350,
        "./screenshots/watcher.js": 351,
        "./search-examples/alarms.js": 514,
        "./search-examples/index.js": 515,
        "./search-examples/loader.js": 516,
        "./search-examples/state-storage.js": 523,
        "./search-examples/state.js": 517,
        "./search-suggest/index.js": 483,
        "./settings/backgrounds.js": 383,
        "./settings/defaults.js": 217,
        "./settings/log-levels.js": 527,
        "./settings/platform-bridge.js": 528,
        "./settings/settings.js": 216,
        "./site-info/index.js": 530,
        "./site-info/site-loader.js": 226,
        "./site-info/tableau.js": 273,
        "./site-info/title.js": 272,
        "./startpages/index.js": 376,
        "./startup/always.js": 208,
        "./startup/bootstrap.js": 2,
        "./startup/index.js": 29,
        "./startup/install-date.js": 531,
        "./startup/install-upgrade.js": 532,
        "./startup/install.js": 533,
        "./startup/normal-start.js": 534,
        "./startup/offscreen.js": 535,
        "./startup/runstate.js": 344,
        "./startup/uninstall.js": 536,
        "./startup/upgrade.js": 537,
        "./startup/versions.js": 345,
        "./statistics/bar-navig-thumbs.js": 342,
        "./statistics/bar-navig.js": 341,
        "./statistics/clicker-advertisement.js": 538,
        "./statistics/clicker-auth.js": 539,
        "./statistics/clicker-branding.js": 540,
        "./statistics/clicker-hosts-permissions.js": 541,
        "./statistics/clicker-manual-backup.js": 542,
        "./statistics/clicker-new-tab.js": 543,
        "./statistics/clicker-sync.js": 544,
        "./statistics/clicker-thumbs.js": 551,
        "./statistics/clicker-voice.js": 552,
        "./statistics/clicker.js": 438,
        "./statistics/dayuse-exp.js": 553,
        "./statistics/dayuse-helper.js": 336,
        "./statistics/dayuse-poller.js": 335,
        "./statistics/dayuse-simple.js": 556,
        "./statistics/index.js": 557,
        "./statistics/soft-export.js": 333,
        "./sync/api.js": 546,
        "./sync/guid.js": 550,
        "./sync/index.js": 545,
        "./sync/state.js": 547,
        "./thumb-suggest/suggest-results.js": 471,
        "./thumb-suggest/suggest.js": 470,
        "./thumbs/collection.js": 270,
        "./thumbs/move-thumb.js": 467,
        "./thumbs/pin-thumb.js": 468,
        "./thumbs/remove-thumb.js": 466,
        "./thumbs/save-thumb.js": 465,
        "./thumbs/storage.js": 294,
        "./thumbs/thumb.js": 271,
        "./url-suggest/search-bookmarks.js": 477,
        "./url-suggest/search-history.js": 474,
        "./url-suggest/search-opentabs.js": 478,
        "./url-suggest/search-web.js": 479,
        "./url-suggest/weights.js": 476,
        "./voice/consts.js": 410,
        "./voice/consumers/consumer.js": 489,
        "./voice/consumers/serp-navigator.js": 488,
        "./voice/consumers/site-navigator.js": 491,
        "./voice/events.js": 487,
        "./voice/index.js": 486,
        "./zen/index.js": 495
    };
    function webpackContext(req) {
        return __webpack_require__(webpackContextResolve(req));
    }
    function webpackContextResolve(req) {
        return map[req] || function() {
            throw new Error("Cannot find module '" + req + "'.");
        }();
    }
    webpackContext.keys = function() {
        return Object.keys(map);
    };
    webpackContext.resolve = webpackContextResolve;
    module.exports = webpackContext;
    webpackContext.id = 423;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("advertisement/atom");
    var branding = __webpack_require__(277);
    var i18n = __webpack_require__(280);
    var authCookies = __webpack_require__(425);
    var Atom = __webpack_require__(426);
    var merge = __webpack_require__(157);
    var ATOM_URL = "http://mobile.yandex.net/search/atomsearch/vb_extension";
    var AD_TYPES = [ "banner", "stripe" ];
    var atom = new Atom(ATOM_URL);
    exports.getData = function() {
        return getParams().then(atom.getContent.bind(atom)).then(formatResponse).catch(logger.error.bind(logger));
    };
    function getParams() {
        return getYandexUID().then(function(uid) {
            return merge({
                yandexuid: uid
            }, getCommonParams());
        });
    }
    function getYandexUID() {
        return new Promise(function(resolve) {
            authCookies.getYandexuidCookie(resolve);
        });
    }
    function getCommonParams() {
        return {
            tld: branding.vars.regionTld,
            lang: i18n.locale,
            "user-agent": navigator.userAgent
        };
    }
    function formatResponse(atomResponse) {
        return AD_TYPES.reduce(function(result, type) {
            result[type] = atomResponse.getConfigSource(type);
            return result;
        }, {});
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var channel = __webpack_require__(27);
    var branding = __webpack_require__(277);
    var logger = __webpack_require__(5).create("auth/yauth-cookies");
    var platformConfigure = __webpack_require__(331);
    var SESSION_COOKIE_NAME = "Session_id";
    var YANDEX_UID_COOKIE_NAME = "yandexuid";
    var YANDEX_LOGIN_COOKIE_NAME = "yandex_login";
    var COOKIE_PATH = "/";
    var cookies = {
        session: {
            name: SESSION_COOKIE_NAME,
            path: COOKIE_PATH,
            domain: null
        },
        yandexUid: {
            name: YANDEX_UID_COOKIE_NAME,
            path: COOKIE_PATH,
            domain: null
        },
        yandexLogin: {
            name: YANDEX_LOGIN_COOKIE_NAME,
            path: COOKIE_PATH,
            domain: null
        }
    };
    var yandexUidValue = null;
    var yandexLoginValue = null;
    module.exports = {
        init: function() {
            var cookieDomain = branding.expandUrl(branding.auth.cookieDomain);
            cookies.session.domain = cookieDomain;
            cookies.yandexUid.domain = cookieDomain;
            cookies.yandexLogin.domain = cookieDomain;
            listenCookiesExistance([ cookies.session, cookies.yandexUid, cookies.yandexLogin ], dispatch);
        },
        isSessionExists: false,
        onChanged: channel.create("yauth.cookies.onChanged"),
        cookiesResolves: [],
        getYandexuidCookie: function(callback) {
            readCookieState(cookies.yandexUid, function(err, cookies) {
                callback(cookies && cookies[0] && cookies[0].value);
            });
        },
        get yandexUid() {
            return yandexUidValue;
        },
        get yandexLogin() {
            return yandexLoginValue;
        }
    };
    function dispatch(isCookieExists, cookieName, cookieValue) {
        var isSessionCookie = cookieName === cookies.session.name;
        logger.info("%s cookie state changed %s", cookieName, isCookieExists);
        if (cookieName === YANDEX_UID_COOKIE_NAME) yandexUidValue = isCookieExists ? cookieValue : null;
        if (cookieName === YANDEX_LOGIN_COOKIE_NAME) yandexLoginValue = isCookieExists ? cookieValue : null;
        if (isSessionCookie) module.exports.isSessionExists = isCookieExists;
        module.exports.onChanged.dispatch(isCookieExists, isSessionCookie);
    }
    function readCookieState(cookieDesc, callback) {
        chrome.cookies.getAll(cookieDesc, function(cookies) {
            callback(chrome.runtime.lastError, cookies);
        });
    }
    function isCookieMatches(expectedInfo, changeInfo) {
        return changeInfo.cookie.name === expectedInfo.name && changeInfo.cookie.path === expectedInfo.path && changeInfo.cookie.domain === expectedInfo.domain;
    }
    function listenCookiesExistance(cookiesDesc, callback) {
        platformConfigure({
            listenDomains: cookiesDesc.map(function(cookieDesc) {
                return cookieDesc.domain;
            })
        });
        chrome.cookies.onChanged.addListener(function(changeInfo) {
            var isValid = cookiesDesc.some(function(cookieDesc) {
                return isCookieMatches(cookieDesc, changeInfo);
            });
            if (isValid) callback(!changeInfo.removed, changeInfo.cookie.name, changeInfo.cookie.value);
        });
        cookiesDesc.forEach(function(cookieDesc) {
            module.exports.cookiesResolves.push(new Promise(function(resolve) {
                readCookieState(cookieDesc, function(err, foundCookies) {
                    var isCookieExists = foundCookies && foundCookies.length > 0;
                    var cookieValue = isCookieExists ? foundCookies[0].value : void 0;
                    callback(isCookieExists, cookieDesc.name, cookieValue);
                    resolve(cookieDesc);
                });
            }));
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _lodashObjectDefaults = __webpack_require__(92);
    var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
    var _response = __webpack_require__(427);
    var _response2 = _interopRequireDefault(_response);
    var _urijs = __webpack_require__(33);
    var _urijs2 = _interopRequireDefault(_urijs);
    var Atom = function() {
        function Atom(url) {
            var settings = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1];
            _classCallCheck(this, Atom);
            this.url = url;
            this.settings = (0, _lodashObjectDefaults2["default"])({}, settings, {
                lang: "ru",
                tld: ".ru"
            });
        }
        _createClass(Atom, [ {
            key: "getContent",
            value: function() {
                var _this = this;
                var params = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];
                var headers = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1];
                var url = this._getAtomUrl((0, _lodashObjectDefaults2["default"])(params, this.settings));
                var data = {
                    credentials: "include",
                    headers: headers
                };
                return fetch(url, data).then(function(response) {
                    return _this._processAtomResponse(response);
                }).then(function(json) {
                    return new _response2["default"](json);
                });
            }
        }, {
            key: "_getAtomUrl",
            value: function(params) {
                return new _urijs2["default"](this.url).search(params).href();
            }
        }, {
            key: "_processAtomResponse",
            value: function(response) {
                if (response.ok) return response.json();
                return Promise.reject(response.statusText);
            }
        } ]);
        return Atom;
    }();
    exports["default"] = Atom;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _lodashCollectionFindWhere = __webpack_require__(428);
    var _lodashCollectionFindWhere2 = _interopRequireDefault(_lodashCollectionFindWhere);
    var _lodashObjectGet = __webpack_require__(193);
    var _lodashObjectGet2 = _interopRequireDefault(_lodashObjectGet);
    var AtomResponse = function() {
        function AtomResponse(jsonResponse) {
            _classCallCheck(this, AtomResponse);
            this.response = jsonResponse;
        }
        _createClass(AtomResponse, [ {
            key: "getConfig",
            value: function(blockName) {
                var config = (0, _lodashCollectionFindWhere2["default"])(this.response["client-results"], {
                    name: blockName
                });
                if (config && config.docs) return config;
                return null;
            }
        }, {
            key: "getConfigDoc",
            value: function(blockName) {
                var config = this.getConfig(blockName);
                var doc = (0, _lodashObjectGet2["default"])(config, "docs[0]");
                return doc || null;
            }
        }, {
            key: "getConfigSource",
            value: function(blockName) {
                var doc = this.getConfigDoc(blockName);
                if (doc) return doc["source-aux"];
                return null;
            }
        } ]);
        return AtomResponse;
    }();
    exports["default"] = AtomResponse;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    var baseMatches = __webpack_require__(104), find = __webpack_require__(197);
    function findWhere(collection, source) {
        return find(collection, baseMatches(source));
    }
    module.exports = findWhere;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("auth/ui");
    var yauth = __webpack_require__(430);
    var branding = __webpack_require__(277);
    var platformAbout = __webpack_require__(23);
    var db = __webpack_require__(295);
    var UsersList = __webpack_require__(431);
    var channel = __webpack_require__(27);
    var urlUtils = __webpack_require__(83);
    var Redirector = __webpack_require__(433);
    var debounce = __webpack_require__(149);
    var redirector = null;
    var RESULT_STATUS = {
        OK: "ok",
        OTHER: "other",
        NO_ACTION: "action-not-required"
    };
    var COOKIE_CHANGE_DELAY = 1e3;
    var pageTypeUrls = null;
    exports._usersList = null;
    exports.onAction = channel.create();
    exports.onUsersChanged = channel.create();
    exports.onUsersSave = channel.create();
    exports.onPostRequestNeeded = channel.create();
    exports.init = function() {
        pageTypeUrls = {
            get tune() {
                return branding.auth.settings;
            },
            get passport() {
                return branding.auth.passport;
            }
        };
        redirector = createRedirector().enable();
        yauth.cookies.init();
        db.get("users", null, function(err, usersListJson) {
            if (err) logger.error("Error reading users from db %s", err); else {
                logger.info("Users from DB:");
                usersListJson.forEach(function(userJson, i) {
                    logger.info("%d user: %j", i, userJson);
                });
            }
            exports._usersList = createUsersList(usersListJson);
            listenCookieChange(exports._usersList);
        });
    };
    exports.getUsersList = function() {
        return exports._usersList;
    };
    exports.login = function(tabId, uid) {
        var usersList = exports.getUsersList();
        var user = uid ? usersList.getUserByUid(uid) : null;
        if (!user) {
            logger.info("No user, login...");
            login(tabId);
            exports.onAction.dispatch("login");
        } else if (usersList.isDefault(user)) {
            var url = getMainUrlForUser(user);
            logger.info("Open main page for user: %s, %s, goto: %s", user.login, user.uid, url);
            goto(tabId, url);
            exports.onAction.dispatch("use", user);
        } else if (user.hasAuth) {
            logger.info("Change user to: %s, %s", user.displayName, user.uid);
            setDefaultUser(tabId, user);
            exports.onAction.dispatch("switch", user);
        } else {
            logger.info("Login user: %s, %s", user.displayName, user.uid);
            login(tabId, user);
            exports.onAction.dispatch("login", user);
        }
    };
    exports.logoutDefaultUser = function(tabId) {
        var usersList = exports.getUsersList();
        var user = usersList.defaultUser;
        logger.info("Logout user %j", user.toJSON());
        logoutUser(tabId, user);
    };
    exports.navigate = function(tabId, type) {
        logger.info("Navigate to tab %s with type: %s", tabId, type);
        goto(tabId, pageTypeUrls[type] || pageTypeUrls.passport);
    };
    function goto(tabId, url) {
        chrome.tabs.update(tabId, {
            url: url
        });
    }
    function onCookieChange(usersList, isCookieExists) {
        logger.info("Cookie changed. isExists: %s", isCookieExists);
        if (isCookieExists) yauth.loadAccounts(function(err, result) {
            if (err) {
                logger.info("Accounts load error: %s", err);
                updateUsersByAccounts(usersList, [], null);
                return;
            }
            logger.info("Accounts response %j", result);
            updateUsersByAccounts(usersList, result.accounts || [], result.default_uid);
        }); else updateUsersByAccounts(usersList, [], null);
    }
    function login(tabId, user) {
        redirector.once(tabId, function(tab) {
            logger.info("Redirect to newtab after login %s", tab.url);
            exports.onAction.dispatch("retpath.login", user);
            goto(tab.id, platformAbout.visbookmarksUrl);
        });
        yauth.login(tabId, user);
    }
    function updateUsersByAccounts(usersList, accounts, defaultUid) {
        usersList.defaultUid = defaultUid;
        var usedUids = accounts.map(function(account) {
            usersList.appendAccount(account);
            return account.uid;
        });
        usersList.getUsersExcept(usedUids).forEach(function(user) {
            user.logout();
        });
        logger.info("Save all %j", usersList.toJSON());
        db.clearAndInsert("users", usersList.toJSON(), function(err) {
            if (err) logger.error("Error while inserting users %s %j", err.message, usersList);
        });
        exports.onUsersSave.dispatch(usersList);
    }
    function getFinalUrl(data, okUrl) {
        logger.info("Redirect done. Answer: %j", data);
        switch (data.status) {
          case RESULT_STATUS.OK:
            return okUrl;

          case RESULT_STATUS.OTHER:
            return data.url || platformAbout.visbookmarksUrl;

          case RESULT_STATUS.NO_ACTION:
            return platformAbout.visbookmarksUrl;

          default:
            return branding.auth.passport;
        }
    }
    function setDefaultUser(tabId, user) {
        yauth.getSwitchUserData(user.uid, function(url, postData) {
            redirector.once(tabId, function(tab) {
                var uri = urlUtils.createURI(tab.url);
                var data = uri ? uri.query(true) : {};
                var url = getMainUrlForUser(user);
                url = getFinalUrl(data, url);
                logger.info("Set default. User: %j, goto: %s", user.toJSON(), url);
                goto(tab.id, url);
                exports.onAction.dispatch("retpath.switch", data, user);
            });
            exports.onPostRequestNeeded.dispatch(url, postData, tabId, true);
        });
    }
    function getMainUrlForUser(user) {
        return user.isSocial ? branding.auth.main : branding.auth.mail;
    }
    function createRedirector() {
        var redirectorInstance = new Redirector(function(url) {
            return 0 === url.indexOf(branding.auth.redirect);
        });
        redirectorInstance.on(function(tab) {
            logger.info("Redirect to newtab, no action before: %s", tab.url);
            goto(tab.id, platformAbout.visbookmarksUrl);
            exports.onAction.dispatch("retpath", tab.url);
        });
        return redirectorInstance;
    }
    function createUsersList(usersListJson) {
        var usersList = UsersList.fromJSON(usersListJson);
        usersList.onChanged.addListener(exports.onUsersChanged.dispatch.bind(exports.onUsersChanged));
        return usersList;
    }
    function listenCookieChange(usersList) {
        onCookieChange(usersList, yauth.cookies.isSessionExists);
        var onCookieChangeDebounced = debounce(onCookieChange, COOKIE_CHANGE_DELAY);
        yauth.cookies.onChanged.addListener(function(isCookieExists, isSessionCookie) {
            if (isSessionCookie) onCookieChangeDebounced(usersList, isCookieExists);
        });
    }
    function logoutUser(tabId, user) {
        yauth.getLogoutData(user.uid, function(url, postData) {
            redirector.once(tabId, function(tab) {
                var uri = urlUtils.createURI(tab.url);
                var data = uri ? uri.query(true) : {};
                var url = getFinalUrl(data, platformAbout.visbookmarksUrl);
                logger.info("Logout. User: %j, goto: %s", user.toJSON(), url);
                goto(tab.id, url);
                exports.onAction.dispatch("retpath.logout", data, user);
            });
            exports.onPostRequestNeeded.dispatch(url, postData, tabId, true);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var yauthCookies = __webpack_require__(425);
    var branding = __webpack_require__(277);
    var xhr = __webpack_require__(32);
    var urlUtils = __webpack_require__(83);
    var CHANGE_DEFAULT = "change_default";
    var LOGOUT = "logout";
    module.exports = {
        _sendPostRequest: null,
        cookies: yauthCookies,
        login: function(tabId, user) {
            chrome.tabs.update(tabId, {
                url: URL_FACTORY.login(user)
            });
        },
        getLogoutData: function(uid, callback) {
            getRequestData(LOGOUT, uid, callback);
        },
        getSwitchUserData: function(uid, callback) {
            getRequestData(CHANGE_DEFAULT, uid, callback);
        },
        loadAccounts: function(callback) {
            authLoadAccounts(callback);
        }
    };
    var URL_FACTORY = {
        start: function() {
            return createUrl(branding.auth.passportApi, "/passport", {
                mode: "embeddedauth"
            });
        },
        login: function(user) {
            return createUrl(branding.auth.passportApi, "/auth", {
                retpath: branding.auth.redirect,
                login: user ? user.login : void 0
            });
        },
        accounts: function(yandexuid) {
            return createUrl(branding.auth.passApi, "/accounts", {
                yu: yandexuid
            });
        }
    };
    function createUrl(base, path, search) {
        var uri = urlUtils.createURI(base);
        return uri ? uri.resource(path).setSearch(search).toString() : "";
    }
    function getRequestData(action, uid, callback) {
        yauthCookies.getYandexuidCookie(function(yandexuid) {
            callback(URL_FACTORY.start(), {
                uid: uid,
                yu: yandexuid,
                action: action,
                retpath: branding.auth.redirect
            });
        });
    }
    function authLoadAccounts(callback) {
        yauthCookies.getYandexuidCookie(function(yandexuid) {
            if (!yandexuid) callback(new Error("No yandexuid cookie")); else xhr({
                withCredentials: true,
                url: URL_FACTORY.accounts(yandexuid),
                parse: "json"
            }, callback);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var User = __webpack_require__(432);
    var find = __webpack_require__(197);
    var channel = __webpack_require__(27);
    module.exports = UsersList;
    function UsersList(uid) {
        this.defaultUid = uid;
        this.users = [];
        this.onChanged = channel.create("UsersList.onChanged");
    }
    UsersList.fromJSON = function(json) {
        var defaultUid;
        var users = (json || []).map(function(userJson) {
            if (userJson.isDefault) defaultUid = userJson.uid;
            return User.fromJSON(userJson);
        }, ul);
        var ul = new UsersList(defaultUid);
        users.forEach(ul.appendUser, ul);
        return ul;
    };
    UsersList.prototype = {
        get hasAuth() {
            return this.users.some(function(user) {
                return user.hasAuth;
            });
        },
        get defaultUser() {
            return this.getUserByUid(this.defaultUid);
        }
    };
    UsersList.prototype.getUserByUid = function(uid) {
        return find(this.users, "uid", uid);
    };
    UsersList.prototype.logoutAll = function() {
        this.users.forEach(function(user) {
            user.logout();
        });
        return this;
    };
    UsersList.prototype.getUsersExcept = function(uids) {
        var uidMap = uids.reduce(function(memo, uid) {
            memo[uid] = true;
            return memo;
        }, {});
        return this.users.filter(function(user) {
            return !uidMap[user.uid];
        });
    };
    UsersList.prototype.appendUser = function(user) {
        this.users.push(user);
        this.onChanged.dispatch("add", user);
        user.onLogin.addListener(this.onChanged.dispatch.bind(this.onChanged, "login"));
        user.onLogout.addListener(this.onChanged.dispatch.bind(this.onChanged, "logout"));
        return this;
    };
    UsersList.prototype.appendAccount = function(account) {
        var user = this.getUserByUid(account.uid);
        if (user) user.authorize(account); else this.appendUser(new User(account));
        return this;
    };
    UsersList.prototype.isDefault = function(user) {
        return user.uid === this.defaultUid;
    };
    UsersList.prototype.toJSON = function() {
        return this.users.map(function(user) {
            var userJson = user.toJSON();
            if (this.isDefault(user)) userJson.isDefault = true;
            return userJson;
        }, this);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var channel = __webpack_require__(27);
    var curly = __webpack_require__(207);
    var AVATAR_URL = "https://yapic.yandex.ru/get/{uid}/islands-middle?rnd=" + Math.random().toString(36);
    function User(account) {
        this._hasAuth = false;
        this._lastAuthTime = 0;
        this._uid = "";
        this._name = "";
        this._login = "";
        this.onLogout = channel.create("User.onLogout");
        this.onLogin = channel.create("User.onLogin");
        if (account) this.authorize(account);
    }
    User.fromJSON = function(json) {
        var user = new User(json);
        user._lastAuthTime = json.lastAuthTime;
        user._hasAuth = json.hasAuth;
        return user;
    };
    User.prototype = {
        get uid() {
            return this._uid;
        },
        get lastAuthTime() {
            return this._lastAuthTime;
        },
        get name() {
            return this._name;
        },
        get displayName() {
            return this._name || this._login;
        },
        get login() {
            return this._login;
        },
        get hasAuth() {
            return this._hasAuth;
        },
        get isSocial() {
            return !this.login;
        },
        get avatarUrl() {
            return curly.insertUrlVars(AVATAR_URL, this);
        }
    };
    User.prototype.toJSON = function() {
        return {
            uid: this._uid,
            login: this._login,
            name: this._name,
            lastAuthTime: this._lastAuthTime,
            hasAuth: this._hasAuth
        };
    };
    User.prototype.logout = function() {
        var wasAuth = this._hasAuth;
        this._hasAuth = false;
        if (wasAuth) this.onLogout.dispatch(this);
        return this;
    };
    User.prototype.authorize = function(account) {
        this._uid = account.uid;
        this._name = account.displayName && account.displayName.name || "";
        this._login = account.login;
        var wasAuth = this._hasAuth;
        this._hasAuth = true;
        this._lastAuthTime = Date.now();
        if (!wasAuth) this.onLogin.dispatch();
        return this;
    };
    module.exports = User;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var browserInfo = __webpack_require__(22);
    var dateUtils = __webpack_require__(4);
    var ONCE_HANDLER_LIFETIME = 10 * dateUtils.SECOND_MS;
    module.exports = Redirector;
    function Redirector(checker) {
        this.check = checker;
        this.handlers = [];
        this._onCompleted = function(_ref) {
            var url = _ref.url, tabId = _ref.tabId;
            this._act({
                url: url,
                id: tabId
            });
        }.bind(this);
    }
    Redirector.prototype.enable = function() {
        chrome.webNavigation.onCompleted.addListener(this._onCompleted);
        return this;
    };
    Redirector.prototype.disable = function() {
        chrome.webNavigation.onCompleted.removeListener(this._onCompleted);
        return this;
    };
    Redirector.prototype._act = function(tab) {
        if (tab.url && this.check(tab.url)) this.handlers.some(function(handler) {
            var result = handler.method(tab);
            if (result && handler.once) this._off(handler);
            return result;
        }, this);
    };
    Redirector.prototype.once = function(tabId, handler) {
        var off = this.on(this._onceHandler.bind(this, tabId, handler), true);
        setTimeout(off, ONCE_HANDLER_LIFETIME);
    };
    Redirector.prototype._onceHandler = function(tabId, handler, tab) {
        if (tab.id === tabId || browserInfo.isIE()) {
            handler(tab);
            return true;
        }
        return false;
    };
    Redirector.prototype.on = function(handler, once) {
        var handlerObject = {
            method: handler,
            once: once
        };
        this.handlers.unshift(handlerObject);
        return this._off.bind(this, handlerObject);
    };
    Redirector.prototype._off = function(handler) {
        var handlerIndex = this.handlers.indexOf(handler);
        if (handlerIndex !== -1) this.handlers.splice(handlerIndex, 1);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var branding = __webpack_require__(277);
    var pickup = __webpack_require__(435);
    var initSender = __webpack_require__(214);
    var logger = __webpack_require__(5).create("Branding applier");
    var runstate = __webpack_require__(344);
    var bgSelector = __webpack_require__(384);
    var asyncLib = __webpack_require__(209);
    var noargs = __webpack_require__(30).noargs;
    exports.init = function() {
        branding.onRemoteLoaded.addListener(onRemoteLoaded);
    };
    function onRemoteLoaded() {
        if (runstate.isReady()) update();
    }
    function update() {
        logger.info("Applying new branding data...");
        asyncLib.parallel([ function(callback) {
            bgSelector.selectDefaultBackground(noargs(callback));
        }, function(callback) {
            pickup.run({
                clear: true
            }, noargs(callback));
        } ], function() {
            logger.info("Update all frontends");
            initSender.sendAll();
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var _ = __webpack_require__(91);
    var apply = __webpack_require__(436);
    var candidates = __webpack_require__(393);
    var forceThumbs = __webpack_require__(437);
    var logger = __webpack_require__(5).create("Pickup");
    var alarms = __webpack_require__(3);
    var collection = __webpack_require__(270);
    var clicker = __webpack_require__(438);
    var platformAbout = __webpack_require__(23);
    var ALARM = {
        name: "pickup",
        periodInMinutes: 24 * 60
    };
    module.exports = {
        init: function() {
            alarms.register(ALARM, this.run.bind(this));
        },
        run: function(options, callback) {
            callback = callback || utils.noop;
            options = getRunOptions(options);
            logger.info("Pickup started with options: %j", options);
            if (!options.dryRun) clicker.send({
                path: "system.autopick"
            });
            if (options.clear && collection.length) {
                logger.info("Collection cleared by pickup");
                collection.clear();
            }
            if (options.clear) setForceThumbs();
            candidates.get(options, function(items) {
                logger.info("Candidates ready, count: %i", items.length);
                if (options.dryRun) logger.info("Pickup ended (dryRun)."); else applyCandidates(items, options);
                callback();
            });
        }
    };
    function getRunOptions(options) {
        var result = _.defaults({}, options, {
            clear: !collection.length,
            dryRun: false,
            fast: false
        });
        result.useTopSites = result.clear && platformAbout.isChr;
        return result;
    }
    function applyCandidates(items, options, callback) {
        apply.run(items, options, function() {
            logger.info("Pickup ended.");
            callback();
        });
    }
    function setForceThumbs() {
        forceThumbs.apply();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var collection = __webpack_require__(270);
    var Thumb = __webpack_require__(271);
    var _ = __webpack_require__(91);
    var settings = __webpack_require__(216);
    var dateUtils = __webpack_require__(4);
    var logger = __webpack_require__(5).create("Pickup/apply");
    var FORCE_UPDATE_THUMBS_MS = dateUtils.WEEK_MS;
    var DEFAULT_PICKUP_COUNT = 10;
    var TOPSITES_PICKUP_COUNT = 8;
    module.exports = {
        run: function(candidates, options) {
            options = options || {};
            var positions = getUnpinnedPositions(options);
            logger.info("Unpinned positions: %i", positions.length);
            candidates = candidates.slice(0, positions.length);
            printItems(candidates);
            var usedPositions = putOnSamePositions(candidates);
            positions = _.difference(positions, usedPositions);
            putNewThumbs(candidates, positions);
            asyncLoadMissingData(options.clear);
        }
    };
    function getUnpinnedPositions(options) {
        var res = [];
        var count = options.clear ? options.useTopSites ? TOPSITES_PICKUP_COUNT : DEFAULT_PICKUP_COUNT : collection.length;
        for (var position = 0; position < count; position++) {
            var thumb = collection.getItem(position);
            if (!thumb || !thumb.pinned) res.push(position);
        }
        return res;
    }
    function putOnSamePositions(items) {
        var usedPositions = [];
        items.filter(function(item) {
            return _.isNumber(item.position);
        }).forEach(function(item) {
            var existingThumb = collection.getItem(item.position);
            if (existingThumb) {
                logger.info("Keep position %i %s", item.position, existingThumb.url);
                if (!_.isNumber(existingThumb.visits) || existingThumb.visits < item.visits) existingThumb.visits = item.visits;
                usedPositions.push(item.position);
            }
        });
        return usedPositions;
    }
    function putNewThumbs(items, positions) {
        items = items.filter(function(item) {
            return !_.isNumber(item.position);
        });
        positions.forEach(function(position) {
            if (items.length) {
                var item = items.shift();
                logger.info("Add new thumb on position: %i %s", position, item.url);
                var thumb = new Thumb(item.url);
                thumb.visits = item.visits;
                collection.setItem(position, thumb);
            }
        });
    }
    function printItems(items) {
        logger.info("Merged candidates: %i", items.length);
        logger.info("Visits | url");
        items.forEach(function(item) {
            logger.info("%i | %s", item.visits, item.url);
        });
    }
    function isForceUpdate() {
        var settingName = "refreshThumbsBackgroundsTime";
        var lastForceUpdate = settings.get(settingName) || 0;
        var isTimePassed = dateUtils.absDiff(lastForceUpdate) >= FORCE_UPDATE_THUMBS_MS;
        if (isTimePassed) settings.set(settingName, Date.now());
        return isTimePassed;
    }
    function asyncLoadMissingData(isClear) {
        setTimeout(function() {
            collection.loadMissingData({
                force: isClear || isForceUpdate()
            });
        }, 0);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var brandedSittes = __webpack_require__(394);
    var collection = __webpack_require__(270);
    var Thumb = __webpack_require__(271);
    var logger = __webpack_require__(5).create("Pickup/force-thumbs");
    module.exports = {
        apply: function(options) {
            options = options || {};
            collection.onChanged.mute();
            var pinned = getBrandedPinned();
            if (options.onlyFirst && pinned.length) addForceThumb(pinned[0]); else pinned.forEach(addForceThumb);
            collection.onChanged.unmute();
        }
    };
    function getBrandedPinned() {
        return brandedSittes.get().filter(function(item) {
            return item.pinned;
        });
    }
    function addForceThumb(item) {
        var thumb = Thumb.fromJSON({
            url: item.url,
            visits: item.visits,
            pinned: true
        });
        collection.setItem(item.index, thumb);
        logger.info("Add force-thumb %s on position %i", thumb.url, item.index);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var logger = __webpack_require__(5).create("Clicker");
    var branding = __webpack_require__(277);
    var settings = __webpack_require__(216);
    var platformAbout = __webpack_require__(23);
    var buildInfo = __webpack_require__(20);
    var merge = __webpack_require__(157);
    var xhr = __webpack_require__(32);
    var curly = __webpack_require__(207);
    var URL_TMPL = "https://yandex.{regionTld}/clck/click/dtype=stred/pid={pid}/cid={cid}/path={path}{vars}/*";
    var PID = 12;
    var PATH_DELIMITER = ".";
    var XHR_OPTIONS = {
        withCredentials: true,
        bypassCache: true
    };
    exports.send = function(options) {
        if (!(options && "object" === ("undefined" === typeof options ? "undefined" : _typeof(options)))) {
            logger.warn("Wrong options argument: %s", options);
            return;
        }
        if (options.force || isStatisticsAllowed()) forceSend(options);
    };
    exports.getPlatformVersion = function() {
        var rawVersion = buildInfo.getVersion();
        return rawVersion.replace(/\./g, "_");
    };
    function forceSend(options) {
        var params = createStatParams(options);
        if (params) {
            logger.info("Sending path: %s vars: %s pid: %s cid: %s", params.path, params.vars, params.pid, params.cid);
            var url = curly.insertVars(URL_TMPL, params);
            if ("img" === options.transport) new Image().src = url; else xhr(merge({
                url: url
            }, XHR_OPTIONS));
        }
    }
    function isStatisticsAllowed() {
        return "fx" !== platformAbout.id || settings.get("sendUsageStat");
    }
    function createStatParams(options) {
        var path = options.path;
        if (!path) {
            logger.warn("Empty path");
            return null;
        }
        var pid = options.pid || PID;
        var cid = options.cid || platformAbout.cid;
        var vars = options.vars;
        path = Array.isArray(path) ? path.join(PATH_DELIMITER) : path;
        if (cid === platformAbout.cid) path = [ exports.getPlatformVersion(), path ].join(PATH_DELIMITER);
        return {
            regionTld: branding.vars.regionTld,
            pid: pid,
            cid: cid,
            path: path,
            vars: vars ? "/vars=" + vars : ""
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var storage = __webpack_require__(291);
    var bannerid = __webpack_require__(337);
    var utils = __webpack_require__(30);
    var channel = __webpack_require__(27);
    var logger = utils.logger.create("Branding/remote/loader");
    var CONFIG_URL = "https://download.cdn.yandex.net/bar/vb/custombuilds/{bannerid}/config.json";
    var ATTEMPTS_MS = [ 1e3, 5 * 1e3, 30 * 1e3 ];
    exports.tryLoad = function(options) {
        return new Promise(function(resolve, reject) {
            options = options || {};
            options.attempt = options.attempt || 0;
            var url = getUrl();
            logger.info("Loading: %s", url);
            utils.xhr({
                url: url,
                logError: false,
                parse: "json",
                timeout: 0 === options.attempt ? 500 : null
            }, function(err, config, evt) {
                if (err) {
                    processError(err, options, evt ? evt.target.status : null);
                    reject(err);
                    return;
                }
                if (isValidConfig(config, url)) {
                    processSuccess(config);
                    resolve();
                } else reject();
            });
        });
    };
    exports.onLoadError = channel.create();
    function isValidConfig(config, url) {
        if (!config || !Object.keys(config).length) {
            logger.error("Empty config received from: %s", url);
            return false;
        }
        if (!config.vars || !config.vars.brandId) {
            logger.error("Config must contain vars.brandId");
            return false;
        }
        return true;
    }
    function processError(err, options, status) {
        logger.error(err.message);
        var retry = utils.xhr.isNetworkError(status) || utils.xhr.isServerError(status);
        if (retry && options.attempt < ATTEMPTS_MS.length) {
            var delay = ATTEMPTS_MS[options.attempt];
            var nextAttempt = options.attempt + 1;
            logger.info("Re-try #%i after %i ms", nextAttempt, delay);
            setTimeout(exports.tryLoad.bind(null, {
                attempt: nextAttempt
            }), delay);
        } else exports.onLoadError.dispatch(bannerid.getBannerId());
    }
    function processSuccess(config) {
        logger.info("Custom branding %s loaded for bannerid: %s %j", config.vars.brandId, bannerid.getBannerId(), config);
        storage.setData(config);
    }
    function getUrl() {
        return utils.curly.insertUrlVars(CONFIG_URL, {
            bannerid: bannerid.getBannerId()
        });
    }
}, function(module, exports) {
    "use strict";
    module.exports.REJECT_TIMESTAMP = 3e3;
    module.exports.BLACKLISTED_SOURCE_COMPLETION_TIMEOUT = 1e3;
    module.exports.OFFSCREEN_IDLE_TIMEOUT = 500;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("cookies gpauto");
    var settings = __webpack_require__(216);
    var geoApi = __webpack_require__(442);
    var dateUtils = __webpack_require__(4);
    var LocationWatcher = __webpack_require__(443);
    var LocationTimer = __webpack_require__(444);
    var LocationParser = __webpack_require__(445);
    var Gpauto = __webpack_require__(446);
    var YpCookie = __webpack_require__(447);
    var _require = __webpack_require__(449), logUpdateResult = _require.logUpdateResult;
    var _require2 = __webpack_require__(449), logUpdateResult = _require2.logUpdateResult;
    var GPAUTO_PREF = "geolocation";
    var UPDATE_TEMOUT = 10 * dateUtils.MINUTE_MS;
    var DOMAINS = [ "yandex.ru", "yandex.kz", "yandex.ua", "yandex.by", "yandex.net", "yandex.com", "yandex.com.tr", "ya.ru" ];
    var locationTimer;
    exports.init = function() {
        logger.info("Initializing");
        locationTimer = initLocationTimer();
        settings.onChanged.addListener(handleSettingsChange);
        if (settings.get(GPAUTO_PREF)) {
            logger.info("Start geolocation monitoring");
            locationTimer.start();
        }
    };
    function initLocationTimer() {
        var watcher = new LocationWatcher(geoApi, {});
        var timer = new LocationTimer(watcher, UPDATE_TEMOUT);
        timer.onError.add(handleTimerError);
        timer.onChange.add(handleLocationChange);
        return timer;
    }
    function handleSettingsChange(data) {
        if (data.key === GPAUTO_PREF) updateTimerState(data.newValue);
    }
    function updateTimerState(isMonitoringAllowed) {
        logger.info("Geolocation settings changed: %s", isMonitoringAllowed);
        if (isMonitoringAllowed) locationTimer.start(); else locationTimer.stop();
    }
    function handleLocationChange(position) {
        if (position) updateGpauto(position);
    }
    function updateGpauto(position) {
        var parser = new LocationParser();
        var gpauto = new Gpauto({
            locationParser: parser
        });
        var updatedDomains = [];
        var notUpdatedDomains = [];
        logger.info("Trying to update position: %j", position);
        Promise.all(DOMAINS.map(function(domain) {
            var cookie = new YpCookie(domain);
            return gpauto.updatePosition(position, cookie).then(function(result) {
                if (result) updatedDomains.push(domain);
            }).catch(function() {
                notUpdatedDomains.push(domain);
            });
        })).then(function() {
            return logUpdateResult(logger, updatedDomains, notUpdatedDomains);
        }).catch(function() {
            return logUpdateResult(logger, updatedDomains, notUpdatedDomains);
        });
    }
    function handleTimerError(error) {
        logger.warn("Timer error %j", error);
    }
}, function(module, exports) {
    "use strict";
    module.exports = navigator.geolocation;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _signals = __webpack_require__(311);
    var _signals2 = _interopRequireDefault(_signals);
    var LocationWatcher = function() {
        function LocationWatcher(geolocation, options) {
            _classCallCheck(this, LocationWatcher);
            this.onChange = new _signals2["default"]();
            this.onError = new _signals2["default"]();
            this._geo = geolocation;
            this._geoOptions = options || {};
            this._watchId = null;
        }
        _createClass(LocationWatcher, [ {
            key: "start",
            value: function() {
                if (!this._geo) this.onError.dispatch(new Error("Geolocation is not supported")); else {
                    this.stop();
                    this._watchId = this._watchPosition();
                }
            }
        }, {
            key: "stop",
            value: function() {
                if (this._watchId) {
                    this._geo.clearWatch(this._watchId);
                    this._watchId = null;
                }
            }
        }, {
            key: "_watchPosition",
            value: function() {
                return this._geo.watchPosition(this._handlePositionChangeSuccess.bind(this), this._handlePositionChangeError.bind(this), this._geoOptions);
            }
        }, {
            key: "_handlePositionChangeSuccess",
            value: function(position) {
                if (position && position.coords) this.onChange.dispatch(position);
            }
        }, {
            key: "_handlePositionChangeError",
            value: function(error) {
                if (error) this.onError.dispatch(error);
            }
        } ]);
        return LocationWatcher;
    }();
    exports["default"] = LocationWatcher;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _signals = __webpack_require__(311);
    var _signals2 = _interopRequireDefault(_signals);
    var DEFAULT_TIMEOUT = 1e3 * 60 * 10;
    var LocationTimer = function() {
        function LocationTimer(watcher, timeout) {
            _classCallCheck(this, LocationTimer);
            this.onChange = new _signals2["default"]();
            this.onError = new _signals2["default"]();
            this._watcher = watcher;
            this._timeout = timeout || DEFAULT_TIMEOUT;
            this._position = null;
            this._intervalId = null;
        }
        _createClass(LocationTimer, [ {
            key: "start",
            value: function() {
                this.stop();
                this._intervalId = setInterval(this._handleIntervalEvent.bind(this), this._timeout);
                this._startWatcher();
            }
        }, {
            key: "stop",
            value: function() {
                clearInterval(this._intervalId);
                this._intervalId = null;
                this._stopWatcher();
            }
        }, {
            key: "_startWatcher",
            value: function() {
                this._watcher.onChange.add(this._handleChangeEvent, this);
                this._watcher.onError.add(this._handleErrorEvent, this);
                this._watcher.start();
            }
        }, {
            key: "_stopWatcher",
            value: function() {
                this._watcher.onChange.remove(this._handleChangeEvent, this);
                this._watcher.onError.remove(this._handleErrorEvent, this);
                this._watcher.stop();
            }
        }, {
            key: "_handleChangeEvent",
            value: function(position) {
                if (!this._position) this._dispatchChange(position);
                this._position = position;
            }
        }, {
            key: "_handleErrorEvent",
            value: function(error) {
                this.onError.dispatch(error);
            }
        }, {
            key: "_handleIntervalEvent",
            value: function() {
                if (this._position) this._dispatchChange(this._position);
            }
        }, {
            key: "_dispatchChange",
            value: function(position) {
                this.onChange.dispatch(position);
            }
        } ]);
        return LocationTimer;
    }();
    exports["default"] = LocationTimer;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _lodashObjectDefaults = __webpack_require__(92);
    var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
    var GEO_DELIMITER = ":";
    var DEFAULT_OPTIONS = {
        deviceId: 3,
        timestampRoundValue: 1e3
    };
    var PositionParser = function() {
        function PositionParser(options) {
            _classCallCheck(this, PositionParser);
            options = (0, _lodashObjectDefaults2["default"])({}, options, DEFAULT_OPTIONS);
            this._deviceId = options.deviceId;
            this._timestampRoundValue = options.timestampRoundValue;
        }
        _createClass(PositionParser, [ {
            key: "parseToString",
            value: function(position) {
                return [ this._numberToString(position.coords.latitude), this._numberToString(position.coords.longitude), this._numberToString(position.coords.accuracy), this._deviceId, Math.round(Date.now() / this._timestampRoundValue) ].join(GEO_DELIMITER);
            }
        }, {
            key: "parseFromString",
            value: function(value) {
                var parts = value.split(GEO_DELIMITER);
                return {
                    coords: {
                        latitude: this._numberFromString(parts[0]),
                        longitude: this._numberFromString(parts[1]),
                        accuracy: this._numberFromString(parts[2])
                    },
                    deviceId: this._numberFromString(parts[3]),
                    timestamp: 1e3 * this._numberFromString(parts[4])
                };
            }
        }, {
            key: "_numberToString",
            value: function(number) {
                if ("undefined" === typeof number || null === number) number = 0;
                return number.toString().replace(".", "_");
            }
        }, {
            key: "_numberFromString",
            value: function(string) {
                var result = Number(string.replace("_", "."));
                if (isNaN(result)) return;
                return result;
            }
        } ]);
        return PositionParser;
    }();
    exports["default"] = PositionParser;
    module.exports = exports["default"];
}, function(module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var COOKIE_PART = "gpauto";
    var COOKIE_EXPIRES = 1e3 * 60 * 60 * 24 * 2;
    var POSITION_EXPIRES = 1e3 * 60 * 10;
    var LocationWriter = function() {
        function LocationWriter(options) {
            _classCallCheck(this, LocationWriter);
            this._locationParser = options.locationParser;
            this._cookiePart = options.cookiePart || COOKIE_PART;
            this._cookieExpires = options.cookieExpires || COOKIE_EXPIRES;
            this._positionExpires = options.positionExpires || POSITION_EXPIRES;
        }
        _createClass(LocationWriter, [ {
            key: "updatePosition",
            value: function(position, cookie) {
                var _this = this;
                return this._getPositionData(cookie).then(function(positionData) {
                    var isExpired = _this._isPositionExpired(positionData);
                    return isExpired ? _this._writePosition(position, cookie) : null;
                });
            }
        }, {
            key: "_getPositionData",
            value: function(cookie) {
                var _this2 = this;
                return cookie.getValue(this._cookiePart).then(function(position) {
                    return _this2._parsePosition(position);
                });
            }
        }, {
            key: "_parsePosition",
            value: function(positionData) {
                if (positionData && positionData.value) return {
                    value: this._locationParser.parseFromString(positionData.value),
                    expires: positionData.expires
                };
                return {
                    value: null,
                    expires: null
                };
            }
        }, {
            key: "_isPositionExpired",
            value: function(positionData) {
                var position = positionData.value;
                if (!position) return true;
                return isValueExpired(position.timestamp, this._positionExpires) || isValueExpired(1e3 * positionData.expires, this._cookieExpires);
            }
        }, {
            key: "_writePosition",
            value: function(position, cookie) {
                var expires = this._getCookieExpiresValue();
                var stringPosition = this._locationParser.parseToString(position);
                return cookie.upsertPart(this._cookiePart, stringPosition, expires);
            }
        }, {
            key: "_getCookieExpiresValue",
            value: function() {
                return Math.round((Date.now() + this._cookieExpires) / 1e3);
            }
        } ]);
        return LocationWriter;
    }();
    exports["default"] = LocationWriter;
    function isValueExpired(value, expirationTime) {
        return Math.abs(Date.now() - value) > expirationTime;
    }
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _thenChrome = __webpack_require__(283);
    var _thenChrome2 = _interopRequireDefault(_thenChrome);
    var _lodashCollectionFind = __webpack_require__(197);
    var _lodashCollectionFind2 = _interopRequireDefault(_lodashCollectionFind);
    var _ypSerializer = __webpack_require__(448);
    var _ypSerializer2 = _interopRequireDefault(_ypSerializer);
    var YP_COOKIE_NAME = "yp";
    var YP_COOKIE_PROTOCOL = "https";
    var EXPIRATION_DATE = Math.ceil(new Date(2038, 0).getTime() / 1e3);
    var YpCookie = function() {
        function YpCookie(domain) {
            _classCallCheck(this, YpCookie);
            this.domain = domain;
            this.name = YP_COOKIE_NAME;
            this.protocol = YP_COOKIE_PROTOCOL;
            this.expirationDate = EXPIRATION_DATE;
            this._ypSerializer = new _ypSerializer2["default"]();
        }
        _createClass(YpCookie, [ {
            key: "getCookie",
            value: function() {
                var params = {
                    domain: this.domain,
                    name: this.name
                };
                return _thenChrome2["default"].cookies.getAll(params).then(this._getFirstCookie.bind(this));
            }
        }, {
            key: "addPart",
            value: function(key, value, expires) {
                var _this = this;
                return this.getCookie().then(function(cookie) {
                    var existingValue = cookie ? cookie.value : "";
                    var newValue = _this._ypSerializer.addPart(existingValue, key, value, expires);
                    return _this._saveIfChanged(newValue, existingValue, key);
                });
            }
        }, {
            key: "deletePart",
            value: function(key) {
                var _this2 = this;
                return this.getCookie().then(function(cookie) {
                    if (cookie) {
                        var existingValue = cookie.value;
                        var newValue = _this2._ypSerializer.deletePart(existingValue, key);
                        return _this2._saveIfChanged(newValue, existingValue, key);
                    }
                    return null;
                });
            }
        }, {
            key: "updatePart",
            value: function(key, value, expires) {
                var _this3 = this;
                return this.getCookie().then(function(cookie) {
                    if (cookie) {
                        var existingValue = cookie.value;
                        var newValue = _this3._ypSerializer.updatePart(existingValue, key, value, expires);
                        return _this3._saveIfChanged(newValue, existingValue, key);
                    }
                    return null;
                });
            }
        }, {
            key: "upsertPart",
            value: function(key, value, expires) {
                var _this4 = this;
                return this.getCookie().then(function(cookie) {
                    var existingValue = cookie ? cookie.value : "";
                    var newValue = _this4._ypSerializer.upsertPart(existingValue, key, value, expires);
                    return _this4._saveIfChanged(newValue, existingValue, key);
                });
            }
        }, {
            key: "getValue",
            value: function(key) {
                var _this5 = this;
                return this.getCookie().then(function(cookie) {
                    if (cookie) return _this5._ypSerializer.getValue(cookie.value, key);
                    return null;
                });
            }
        }, {
            key: "_saveIfChanged",
            value: function(newCookieValue, oldCookieValue, changedPart) {
                if (this._ypSerializer.isPartChanged(newCookieValue, oldCookieValue, changedPart)) return this._saveCookie(newCookieValue); else return Promise.resolve(newCookieValue);
            }
        }, {
            key: "_saveCookie",
            value: function(cookieValue) {
                return this._setCookie(cookieValue).then(function() {
                    return Promise.resolve(cookieValue);
                });
            }
        }, {
            key: "_getFirstCookie",
            value: function(cookies) {
                return (0, _lodashCollectionFind2["default"])(cookies, function(cookie) {
                    return false === cookie.hostOnly;
                }) || cookies[0];
            }
        }, {
            key: "_setCookie",
            value: function(cookieValue) {
                return _thenChrome2["default"].cookies.set({
                    url: this.protocol + "://" + this.domain.replace(/^\./, "") + "/",
                    domain: this.domain,
                    name: this.name,
                    value: cookieValue,
                    expirationDate: this.expirationDate
                });
            }
        } ]);
        return YpCookie;
    }();
    exports["default"] = YpCookie;
    module.exports = exports["default"];
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _slicedToArray = function() {
        function sliceIterator(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = void 0;
            try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"]) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }
            return _arr;
        }
        return function(arr, i) {
            if (Array.isArray(arr)) return arr; else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i); else throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
    }();
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _lodashObjectDefaults = __webpack_require__(92);
    var _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);
    var DEFAULT_OPTIONS = {
        partsDelimiter: "#",
        keyValueDelimiter: "."
    };
    var YpSerializer = function() {
        function YpSerializer(options) {
            _classCallCheck(this, YpSerializer);
            options = (0, _lodashObjectDefaults2["default"])({}, options, DEFAULT_OPTIONS);
            this._partsDelimiter = options.partsDelimiter;
            this._keyValueDelimiter = options.keyValueDelimiter;
        }
        _createClass(YpSerializer, [ {
            key: "getParts",
            value: function(cookieValue) {
                return cookieValue.split(this._partsDelimiter).filter(Boolean);
            }
        }, {
            key: "addPart",
            value: function(cookieValue, key, value, expires) {
                var data = this.getParts(cookieValue);
                data.push(this._createPart(key, value, expires));
                return this._toCookieValue(data);
            }
        }, {
            key: "deletePart",
            value: function(cookieValue, key) {
                var data = this.getParts(cookieValue).filter(function(part) {
                    var _part$split = part.split(this._keyValueDelimiter);
                    var _part$split2 = _slicedToArray(_part$split, 2);
                    var keyPart = _part$split2[1];
                    return key !== keyPart;
                }, this);
                return this._toCookieValue(data);
            }
        }, {
            key: "updatePart",
            value: function(cookieValue, key, value, expires) {
                var _this = this;
                var data = this.getParts(cookieValue).map(function(part) {
                    var _part$split3 = part.split(_this._keyValueDelimiter);
                    var _part$split32 = _slicedToArray(_part$split3, 2);
                    var keyPart = _part$split32[1];
                    if (keyPart === key) return _this._createPart(keyPart, value, expires);
                    return part;
                });
                return this._toCookieValue(data);
            }
        }, {
            key: "upsertPart",
            value: function(cookieValue, key, value, expires) {
                var existingValue = this.getValue(cookieValue, key);
                if (existingValue) return this.updatePart(cookieValue, key, value, expires); else return this.addPart(cookieValue, key, value, expires);
            }
        }, {
            key: "getValue",
            value: function(cookieValue, key) {
                var parts = this.getParts(cookieValue);
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = void 0;
                try {
                    for (var _step, _iterator = parts[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var cookiePart = _step.value;
                        var _cookiePart$split = cookiePart.split(this._keyValueDelimiter);
                        var _cookiePart$split2 = _slicedToArray(_cookiePart$split, 3);
                        var expiresPart = _cookiePart$split2[0];
                        var keyPart = _cookiePart$split2[1];
                        var valuePart = _cookiePart$split2[2];
                        if (keyPart === key) return {
                            value: decodeURIComponent(valuePart),
                            expires: parseInt(expiresPart, 10)
                        };
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) _iterator["return"]();
                    } finally {
                        if (_didIteratorError) throw _iteratorError;
                    }
                }
                return null;
            }
        }, {
            key: "isPartChanged",
            value: function(newCookieValue, oldCookieValue, part) {
                var oldValue = this.getValue(oldCookieValue, part);
                var newValue = this.getValue(newCookieValue, part);
                if (oldValue && newValue) return oldValue.value !== newValue.value || oldValue.expires !== newValue.expires; else return oldValue !== newValue;
            }
        }, {
            key: "_createPart",
            value: function(key, value, expires) {
                return [ expires, key, encodeURIComponent(value) ].join(this._keyValueDelimiter);
            }
        }, {
            key: "_toCookieValue",
            value: function(data) {
                return data.join(this._partsDelimiter);
            }
        } ]);
        return YpSerializer;
    }();
    exports["default"] = YpSerializer;
    module.exports = exports["default"];
}, function(module, exports) {
    "use strict";
    exports.logUpdateResult = function(logger, updatedDomains, notUpdatedDomains) {
        var updatedDomainsCount = updatedDomains.length;
        var notUpdatedDomainsCount = notUpdatedDomains.length;
        if (updatedDomainsCount) logger.info("Positions (%d) were updated for %s", updatedDomainsCount, updatedDomains.join(", "));
        if (notUpdatedDomainsCount) logger.error("Positions (%d) updating were faild for %s", notUpdatedDomainsCount, notUpdatedDomains.join(", "));
        if (!updatedDomainsCount && !notUpdatedDomainsCount) logger.info("Positions were not updated");
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var ys = __webpack_require__(451);
    var buildInfo = __webpack_require__(20);
    var about = __webpack_require__(23);
    var logger = __webpack_require__(5).create("Cookies/yasoft");
    exports.init = function() {
        ys.onChanged.addListener(onChanged);
    };
    exports.set = function() {
        var data = getData();
        logger.info("Setting yasoft = %s, version = %s", data.yasoft, data.version);
        ys.upsert(data.yasoft, data.version);
    };
    function onChanged() {
        var data = getData();
        logger.info("YS changed, trying to re-set yasoft = %s, version = %s", data.yasoft, data.version);
        ys.upsert(data.yasoft, data.version);
    }
    function getData() {
        return {
            version: buildInfo.getVersion().replace(/\./g, "-"),
            yasoft: about.yasoft
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var debounce = __webpack_require__(149);
    var endsWith = __webpack_require__(190);
    var Channel = __webpack_require__(27);
    var logger = __webpack_require__(5).create("Cookies/ys");
    var YsCookie = __webpack_require__(339);
    var _require = __webpack_require__(449), logUpdateResult = _require.logUpdateResult;
    var DOMAINS = [ "yandex.ru", "yandex.kz", "yandex.ua", "yandex.by", "yandex.net", "yandex.com", "yandex.com.tr", "ya.ru" ];
    var COOKIE_NAME = "ys";
    var DISPATCH_ONCHANGED_DELAY_MS = 500;
    var INGONE_ONCHANGED_DELAY_MS = 100;
    exports.init = function() {
        addOnChangedListener();
    };
    exports.upsert = function(key, value) {
        removeOnChangedListener();
        batchUpsert(DOMAINS, key, value).then(addOnChangedListenerDelayed).catch(addOnChangedListenerDelayed);
    };
    exports.onChanged = Channel.create();
    function addOnChangedListener() {
        chrome.cookies.onChanged.addListener(onChanged);
    }
    function removeOnChangedListener() {
        chrome.cookies.onChanged.removeListener(onChanged);
    }
    function batchUpsert(domains, key, value) {
        var updatedDomains = [];
        var notUpdatedDomains = [];
        return Promise.all(domains.map(function(domain) {
            return new YsCookie(domain).upsertPart(key, value).then(function(result) {
                if (result) updatedDomains.push(domain);
            }).catch(function() {
                notUpdatedDomains.push(domain);
            });
        })).then(function() {
            return logUpdateResult(logger, updatedDomains, notUpdatedDomains);
        }).catch(function() {
            return logUpdateResult(logger, updatedDomains, notUpdatedDomains);
        });
    }
    function isYSDomain(domain) {
        return DOMAINS.some(function(d) {
            return d === domain || endsWith(domain, "." + d);
        });
    }
    function onChanged(changeInfo) {
        var cookie = changeInfo.cookie;
        if (cookie.name === COOKIE_NAME && isYSDomain(cookie.domain)) dispatchOnChangedDelayed();
    }
    var addOnChangedListenerDelayed = debounce(addOnChangedListener, INGONE_ONCHANGED_DELAY_MS);
    var dispatchOnChangedDelayed = debounce(function() {
        exports.onChanged.dispatch();
    }, DISPATCH_ONCHANGED_DELAY_MS);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var assign = __webpack_require__(93);
    var find = __webpack_require__(197);
    var alarms = __webpack_require__(3);
    var utils = __webpack_require__(30);
    var logoSaver = __webpack_require__(453);
    var settings = __webpack_require__(216);
    var branding = __webpack_require__(277);
    var logger = __webpack_require__(5).create("CustomLogo");
    var experiments = __webpack_require__(328);
    var EXPERIMENT_NAME = "customLogos";
    var ALARM = {
        name: "customLogo",
        periodInMinutes: 12 * 60,
        delayInMinutes: 1
    };
    var EXPORT_URL = "https://export.yandex.ru/vb/custom-logo/";
    var SETTINGS_KEY = "customLogos";
    exports.init = function() {
        if (isExperimentEnabled()) alarms.register(ALARM, exports.requestInfo);
    };
    exports.getCurrent = function() {
        var customLogos = settings.get(SETTINGS_KEY);
        var logoInfo = selectActualLogo(customLogos);
        if (!logoInfo) return;
        var href = logoInfo.href ? branding.expandUrl(logoInfo.href + "&clid={clid7}") : branding.logo.url;
        return assign({}, logoInfo, {
            href: href
        });
    };
    exports.getAll = function() {
        return settings.get(SETTINGS_KEY);
    };
    exports.requestInfo = function() {
        logger.info("Loading info from %s...", EXPORT_URL);
        utils.xhr({
            url: EXPORT_URL,
            logError: true,
            parse: "json"
        }, handleExportResponse);
    };
    function handleExportResponse(err, response) {
        if (err) {
            logger.error(err.message);
            return;
        }
        if (!response || !Array.isArray(response.data)) {
            logger.error("Invalid custom logo data received from server");
            return;
        }
        logger.info("Got response %j", response);
        saveInfo(response.data);
    }
    function saveInfo(logosInfo) {
        var logoSavers = logosInfo.map(function(logoInfo) {
            return checkDates(logoInfo) ? logoSaver.save(logoInfo.url) : Promise.resolve({});
        });
        Promise.all(logoSavers).then(saveToSettings.bind(null, logosInfo)).catch(logger.error.bind(logger));
    }
    function saveToSettings(logosInfo, localUrls) {
        settings.set(SETTINGS_KEY, logosInfo.map(function(logoInfo, index) {
            return assign(logoInfo, {
                localUrl: localUrls[index].url,
                localPath: localUrls[index].path
            });
        }), {
            log: true
        });
    }
    function selectActualLogo(customLogos) {
        return find(customLogos, function(logoInfo) {
            return Boolean(logoInfo && logoInfo.localUrl && checkDates(logoInfo) && checkDomain(logoInfo));
        });
    }
    function checkDates(logoInfo) {
        if (!logoInfo.from || !logoInfo.till) return false;
        var fromDate = new Date(logoInfo.from).setHours(0, 0, 0, 0);
        var tillDate = new Date(logoInfo.till).setHours(23, 59, 59, 999);
        var now = Date.now();
        return now >= fromDate && now <= tillDate;
    }
    function checkDomain(logoInfo) {
        return branding.vars.regionTld === logoInfo.domain;
    }
    function isExperimentEnabled() {
        var experimentData = experiments.getExperimentData(EXPERIMENT_NAME);
        return Boolean(experimentData && experimentData.enabled);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var FileStorage = __webpack_require__(263);
    var logger = __webpack_require__(5).create("CustomLogo");
    var LOGO_URL = "https://avatars.mds.yandex.net/get-serp/{url}/logo-desk";
    exports.CUSTOM_LOGO_DIR = "custom-logo";
    var storage = {
        get main() {
            return this._main || (this._main = new FileStorage(exports.CUSTOM_LOGO_DIR));
        }
    };
    exports.save = function(urlPart) {
        if (!urlPart) return Promise.reject({
            message: "Custom logo img url is not defined"
        });
        return new Promise(function(resolve, reject) {
            var url = LOGO_URL.replace("{url}", urlPart);
            logger.info("Downloading logo img %s...", url);
            storage.main.download(url, urlPart.replace("/", "_"), function(err, data) {
                if (err) reject(err); else resolve(data);
            });
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var advertisement = __webpack_require__(369);
    var settings = __webpack_require__(216);
    var atom = __webpack_require__(424);
    var events = __webpack_require__(268);
    var SETTING_ADVERTISEMENT_NAME = "showAdvertisement";
    exports.init = function() {
        messaging.on(events.frontend.ADV_REFUSE, function(req) {
            advertisement.refuseByUser(req.id, req.data);
        });
        messaging.on(events.frontend.ADV_ACCEPT, function(req) {
            advertisement.accept(req.id, req.data);
        });
        messaging.on(events.frontend.ADD_THUMB, function() {
            settings.set("hasUserAddedThumb", true);
        });
        advertisement.onShowingChanged.addListener(sendAdvertisement);
        settings.onChanged.addListener(onSettingChanged);
    };
    exports.get = function() {
        if (settings.get(SETTING_ADVERTISEMENT_NAME)) return getBlocks(); else return [];
    };
    exports.sendAtomAd = function(tabId) {
        getAtom().then(function(data) {
            messaging.send(events.backend.ADVERTISEMENT_ATOM, data, tabId);
        });
    };
    exports.isAtomAllowed = function() {
        if (settings.get(SETTING_ADVERTISEMENT_NAME)) return 0 === advertisement.getShowingBlocksForGroup("tutorials").length;
        return false;
    };
    function sendAdvertisement() {
        messaging.send(events.backend.ADVERTISEMENT, exports.get());
    }
    function getBlocks() {
        var showingBlocks = advertisement.getShowingBlocks();
        return showingBlocks.map(function(block) {
            return {
                id: block.getId(),
                data: block.getData()
            };
        });
    }
    function onSettingChanged(info) {
        info = info || {};
        if (info.key === SETTING_ADVERTISEMENT_NAME) {
            sendAdvertisement();
            exports.sendAtomAd();
        }
    }
    function getAtom() {
        if (exports.isAtomAllowed()) return atom.getData(); else return Promise.resolve([]);
    }
}, function(module, exports) {
    "use strict";
    exports.toJSON = function(usersList) {
        return usersList && usersList.hasAuth ? usersList.users.sort(usersSorter.bind(null, usersList)).map(convertUserToFrontend.bind(null, usersList)) : [];
    };
    function usersSorter(usersList, userA, userB) {
        return usersList.isDefault(userB) - usersList.isDefault(userA) || userB.hasAuth - userA.hasAuth || userB.lastAuthTime - userA.lastAuthTime;
    }
    function getUserStatus(usersList, user) {
        return usersList.isDefault(user) ? 2 : user.hasAuth ? 1 : 0;
    }
    function convertUserToFrontend(usersList, user) {
        return {
            id: user.uid,
            displayName: user.displayName,
            state: getUserStatus(usersList, user),
            avatarURL: user.avatarUrl
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var auth = __webpack_require__(429);
    var yauth = __webpack_require__(430);
    var formatter = __webpack_require__(455);
    var events = __webpack_require__(268);
    exports.init = function() {
        messaging.on(events.frontend.AUTH_LOGIN, function(req, sender) {
            auth.login(sender.tab.id, req.userId);
        });
        messaging.on(events.frontend.AUTH_LOGOUT, function(req, sender) {
            auth.logoutDefaultUser(sender.tab.id);
        });
        messaging.on(events.frontend.AUTH_NAVIGATE, function(req, sender) {
            auth.navigate(sender.tab.id, req.type);
        });
        auth.onUsersSave.addListener(sendAuth);
        auth.onPostRequestNeeded.addListener(sendPostRequest);
    };
    exports.getAuth = function() {
        return {
            users: formatter.toJSON(auth.getUsersList())
        };
    };
    exports.getYandexUid = function() {
        return yauth.cookies.yandexUid;
    };
    exports.getYandexLogin = function() {
        return yauth.cookies.yandexLogin;
    };
    function sendAuth() {
        messaging.send(events.backend.AUTH, exports.getAuth());
    }
    function sendPostRequest(url, postData, tabId, iframe) {
        messaging.send(events.backend.POST, {
            iframe: iframe,
            url: url,
            params: postData
        }, tabId);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var browserInfo = __webpack_require__(22);
    var _require = __webpack_require__(23), visbookmarksUrl = _require.visbookmarksUrl;
    var visbookmarksOldUrl = "chrome://yandex-vb/content/fastdial/layout/newtab.html";
    var VISBOOKMARKS_URL_RE = /^moz\-extension:\/\/[^/]+\/layout\/newtab\.html$/;
    exports.init = function() {
        if (!browserInfo.isFirefox()) return;
        setTimeout(reloadTabsIfNeeded, 0);
    };
    function reloadTabsIfNeeded() {
        chrome.windows.getAll({
            populate: true
        }, function(windows) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
                for (var _step, _iterator = windows[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var windowItem = _step.value;
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = void 0;
                    try {
                        for (var _step2, _iterator2 = windowItem.tabs[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var tab = _step2.value;
                            reloadTabIfNeeded(tab);
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) _iterator2.return();
                        } finally {
                            if (_didIteratorError2) throw _iteratorError2;
                        }
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
                } finally {
                    if (_didIteratorError) throw _iteratorError;
                }
            }
        });
    }
    function reloadTabIfNeeded(tab) {
        if (isBrokenTab(tab)) chrome.tabs.update(tab.id, {
            url: visbookmarksUrl
        });
    }
    function isBrokenTab(tab) {
        var url = tab.url;
        if (!url) return false;
        if (url === visbookmarksOldUrl) return true;
        if (url === visbookmarksUrl) {
            if (!tab.discarded && "complete" === tab.status && tab.active && !tab.favIconUrl) return true;
        } else if (VISBOOKMARKS_URL_RE.test(url)) return true;
        return false;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var clicker = __webpack_require__(438);
    var events = __webpack_require__(268);
    var tabsWatcher = __webpack_require__(459);
    exports.init = function() {
        messaging.on(events.frontend.SEND_FRONTEND_STAT, function(req, _ref) {
            var tab = _ref.tab;
            tabsWatcher.waitForComplete(tab.id, function() {
                clicker.send(req.options);
            });
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var values = __webpack_require__(64);
    var utils = __webpack_require__(30);
    var channel = __webpack_require__(27);
    var tabsModule = __webpack_require__(282);
    var logger = __webpack_require__(5).create("TabsWatcher");
    var platformAbout;
    var JS_REDIRECTS_WAIT_MS = 1500;
    var JS_REDIRECTS_WAIT_INACTIVE_MS = 3e3;
    var tabs = {};
    var waitForCompleteHandlers = new Map();
    var watcher = module.exports = {
        COMPLETE_STATUS: "complete",
        LOADING_STATUS: "loading",
        initialized: false,
        init: function(aboutModule) {
            if (!this.initialized) {
                platformAbout = aboutModule;
                addListeners();
                collectExistingTabsData();
                this.initialized = true;
            }
        },
        stop: function() {
            removeListeners();
        },
        log: utils.noop,
        getTabInfo: function(tabId) {
            return tabId ? tabs[tabId] : tabs;
        },
        waitForComplete: function(tabId, callback, context) {
            var tabInfo = this.getTabInfo(tabId);
            if (tabInfo && "complete" === tabInfo.status) callback.apply(context); else {
                if (!waitForCompleteHandlers.has(tabId)) waitForCompleteHandlers.set(tabId, []);
                waitForCompleteHandlers.get(tabId).push({
                    callback: callback,
                    context: context
                });
            }
        },
        onComplete: channel.create(),
        onClosed: channel.create(),
        onActivated: channel.create(),
        onUpdate: channel.create(),
        onBeforeNavigate: channel.create()
    };
    function initEmptyTabObject() {
        return {
            urls: [],
            possibleReferrers: [],
            uuid: utils.misc.guid(),
            navigationId: generateNavigationId()
        };
    }
    function generateNavigationId() {
        return Date.now() + Math.random();
    }
    function collectExistingTabsData() {
        tabsModule.getOpen(function(error, tabList) {
            if (error) logger.error("Can not collect existing tabs data: %j", error); else fillTabMapFromExistingTabs(tabList);
        });
    }
    function fillTabMapFromExistingTabs(tabList) {
        tabList.forEach(function(tab) {
            if (!tab.incognito) {
                var mytab = tabs[tab.id] = initEmptyTabObject();
                mytab.urls = [ tab.url ];
                mytab.status = watcher.COMPLETE_STATUS;
                mytab.windowId = tab.windowId;
                mytab.title = tab.title;
                mytab.favIconUrl = tab.favIconUrl;
            }
        });
    }
    function isBadReferrer(referrer) {
        return referrer === platformAbout.visbookmarksUrl;
    }
    function onBeforeNavigation(details) {
        if (0 === details.frameId) handleLoadingState(details.tabId, {
            url: details.url
        });
        watcher.onBeforeNavigate.dispatch(details);
    }
    function onUpdated(tabId, updateInfo, tabData) {
        if (tabData.incognito) return;
        if (updateInfo.status === watcher.LOADING_STATUS) handleLoadingState(tabId, tabData); else if (updateInfo.status === watcher.COMPLETE_STATUS) handleCompletedState(tabId, tabData);
        var tab = tabs[tabId];
        if (tab) {
            tab.title = tabData.title;
            tab.favIconUrl = tabData.favIconUrl;
        }
        watcher.onUpdate.dispatch(tabId, tab, updateInfo);
    }
    function handleLoadingState(tabId, tabData) {
        tabs[tabId] = tabs[tabId] || initEmptyTabObject();
        var url = tabData.url;
        if (!tabs[tabId].status) {
            tabs[tabId].urls = [ url ];
            tabs[tabId].navigationId = generateNavigationId();
            calcRealRefForNewTab(tabId, tabData);
        } else if (tabs[tabId].status === watcher.COMPLETE_STATUS) {
            calcRealRefForExistingTab(tabId, tabData);
            tabs[tabId].urls = [ url ];
            tabs[tabId].navigationId = generateNavigationId();
            tabs[tabId].possibleReferrers = [];
            tabs[tabId].navInExistingTab = true;
        } else if (tabs[tabId].urls.indexOf(url) === -1) tabs[tabId].urls.push(url);
        tabs[tabId].status = watcher.LOADING_STATUS;
        clearTimeout(tabs[tabId].timeout);
        delete tabs[tabId].timeout;
    }
    function calcRealRefForNewTab(tabId, tabData) {
        var opener = tabs[tabData.openerTabId];
        if (opener) {
            var stackRef = opener.urls[opener.urls.length - 1];
            var possibleRef = opener.possibleReferrers[opener.possibleReferrers.length - 1];
            if (stackRef === possibleRef) {
                opener.possibleReferrers.pop();
                tabs[tabId].realRef = isBadReferrer(stackRef) ? null : stackRef;
            } else tabs[tabId].realRef = null;
        }
    }
    function calcRealRefForExistingTab(tabId) {
        var stackRef = tabs[tabId].urls.pop();
        var possibleRef = tabs[tabId].possibleReferrers.pop();
        if (stackRef === possibleRef && !isBadReferrer(stackRef)) tabs[tabId].realRef = stackRef; else tabs[tabId].realRef = null;
    }
    function handleCompletedState(tabId, tabData) {
        tabs[tabId] = tabs[tabId] || initEmptyTabObject();
        if (tabs[tabId].urls.indexOf(tabData.url) === -1) tabs[tabId].urls.push(tabData.url);
        if (isNewWindow(tabData.windowId)) tabs[tabId].navInNewWindow = true; else delete tabs[tabId].navInNewWindow;
        tabs[tabId].windowId = tabData.windowId;
        tabs[tabId].status = watcher.LOADING_STATUS;
        clearTimeout(tabs[tabId].timeout);
        tabs[tabId].timeout = setTimeout(afterRedirectTimeout.bind(null, tabId), tabData.active ? JS_REDIRECTS_WAIT_MS : JS_REDIRECTS_WAIT_INACTIVE_MS);
    }
    function afterRedirectTimeout(tabId) {
        if (tabs[tabId]) {
            delete tabs[tabId].timeout;
            tabs[tabId].status = watcher.COMPLETE_STATUS;
            tabs[tabId].possibleReferrers = [];
            watcher.onComplete.dispatch(tabId, tabs[tabId]);
            triggerWaitForCompleteHandlers(tabId);
        }
    }
    function onRemoved(tabId, removeInfo) {
        if (!tabs[tabId]) return;
        watcher.onClosed.dispatch(tabId, tabs[tabId], removeInfo);
        delete tabs[tabId];
    }
    function onActivated(activeInfo) {
        var tabId = activeInfo.tabId;
        if (!tabs[tabId]) return;
        if (tabs[tabId].status === watcher.COMPLETE_STATUS) watcher.onActivated.dispatch(tabId, tabs[tabId], activeInfo);
    }
    function onReplaced(addedTabId, removedTabId) {
        tabs[addedTabId] = tabs[removedTabId];
        delete tabs[removedTabId];
    }
    function performActionForChannels(actionName) {
        chrome.tabs.onUpdated[actionName](onUpdated);
        chrome.tabs.onRemoved[actionName](onRemoved);
        chrome.tabs.onReplaced[actionName](onReplaced);
        chrome.tabs.onActivated[actionName](onActivated);
        if (chrome.webNavigation && chrome.webNavigation.onBeforeNavigate) chrome.webNavigation.onBeforeNavigate[actionName](onBeforeNavigation);
    }
    function isNewWindow(windowId) {
        return values(tabs).every(function(tab) {
            return tab.windowId !== windowId;
        });
    }
    function triggerWaitForCompleteHandlers(tabId) {
        var handlers = waitForCompleteHandlers.get(tabId);
        if (Array.isArray(handlers)) handlers.forEach(function(handler) {
            return handler.callback.apply(handler.context);
        });
        waitForCompleteHandlers.delete(tabId);
    }
    var addListeners = performActionForChannels.bind(null, "addListener");
    var removeListeners = performActionForChannels.bind(null, "removeListener");
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var logger = __webpack_require__(5).create("frontend closed-tabs");
    var closedTabs = __webpack_require__(307);
    var debounce = __webpack_require__(149);
    var events = __webpack_require__(268);
    var tabsUtils = __webpack_require__(282);
    var TABS_UPDATE_DEBOUNCE_TIME = 100;
    exports.init = function() {
        messaging.on(events.frontend.REQUEST_CLOSED_PAGES_LIST, handleClosedTabsRequest);
        messaging.on(events.frontend.RESTORE_TAB, handleRestoreTabRequest);
        var onUpdated = debounce(handleTabsUpdatedEvent, TABS_UPDATE_DEBOUNCE_TIME);
        closedTabs.onUpdated.addListener(onUpdated);
    };
    exports.sendUpdate = function() {
        tabsUtils.getFrontendTabs().then(function(tabsGroups) {
            tabsGroups.forEach(function(tabs, windowId) {
                var hasClosed = closedTabs.hasClosed(windowId);
                sendUpdateForTabs(tabs, hasClosed);
            });
        });
    };
    function handleTabsUpdatedEvent() {
        exports.sendUpdate();
    }
    function sendUpdateForTabs(tabs, hasClosed) {
        tabs.forEach(function(tab) {
            messaging.send(events.backend.CLOSED_TABS_LIST_CHANGED, {
                empty: !hasClosed
            }, tab.id);
        });
    }
    function handleClosedTabsRequest(req, sender, sendResponse) {
        if (sender && sender.tab) {
            logger.info("Request for closed pages.");
            logger.info("Tab id: %s, window id: %s", sender.tab.id, sender.tab.windowId);
            sendResponse(closedTabs.getClosedTabs(sender.tab.windowId));
        }
    }
    function handleRestoreTabRequest(req) {
        if (req && req.id) {
            logger.info("Request to restore tab %s", req.id);
            closedTabs.restoreItem(req.id);
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var customLogo = __webpack_require__(452);
    exports.getCurrent = function() {
        var current = customLogo.getCurrent();
        if (current) return {
            title: current.title,
            href: current.href,
            imgUrl: current.localUrl
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.init = function() {
        __webpack_require__(463).init();
        __webpack_require__(464).init();
        __webpack_require__(469).init();
        __webpack_require__(388).init();
        __webpack_require__(392).init();
        __webpack_require__(389).init();
        __webpack_require__(472).init();
        __webpack_require__(473).init();
        __webpack_require__(480).init();
        __webpack_require__(456).init();
        __webpack_require__(458).init();
        __webpack_require__(219).init();
        __webpack_require__(454).init();
        __webpack_require__(460).init();
        __webpack_require__(360).init();
        __webpack_require__(214).init();
        __webpack_require__(481).init();
        __webpack_require__(482).init();
        __webpack_require__(484).init();
        __webpack_require__(485).init();
        __webpack_require__(493).init();
        __webpack_require__(457).init();
        __webpack_require__(494).init();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Frontend Logger");
    var messaging = __webpack_require__(213);
    var events = __webpack_require__(268);
    module.exports.init = function() {
        messaging.on(events.frontend.LOG_FRONTEND_DATA, function(req) {
            if ("function" === typeof logger[req.level]) logger[req.level](req.msg); else logger.error("Unknown logger level %s", req.level);
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var saveThumb = __webpack_require__(465);
    var removeThumb = __webpack_require__(466);
    var moveThumb = __webpack_require__(467);
    var pinner = __webpack_require__(468);
    var collection = __webpack_require__(270);
    var debounce = __webpack_require__(149);
    var thumbSender = __webpack_require__(269);
    var Thumb = __webpack_require__(271);
    var events = __webpack_require__(268);
    var THUMB_CHANGED_DELAY_MS = 200;
    exports.init = function() {
        var sendAllDelayed = debounce(thumbSender.sendAll, THUMB_CHANGED_DELAY_MS);
        collection.onChanged.addListener(sendAllDelayed);
        collection.onUpdateError.addListener(thumbSender.sendAll);
        messaging.on(events.frontend.REQUEST_THUMB_DATA, requestThumbData);
        messaging.on(events.frontend.REMOVE_THUMB, function(req) {
            removeThumb(req.index);
        });
        messaging.on(events.frontend.SAVE_THUMB, function(req) {
            saveThumb(req.index, req.data);
        });
        messaging.on(events.frontend.PIN_THUMB, function(req) {
            pinner.pin(req.index);
        });
        messaging.on(events.frontend.UNPIN_THUMB, function(req) {
            pinner.unpin(req.index);
        });
        messaging.on(events.frontend.SWAP_THUMB, function(req) {
            moveThumb(req.oldIndex, req.newIndex);
        });
    };
    function requestThumbData(req, sender) {
        var thumb = new Thumb(req.url);
        thumb.update(false, function() {
            thumbSender.sendThumbData(thumb, sender.tab.id);
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("ThumbsUI");
    var urlUtils = __webpack_require__(83);
    var Thumb = __webpack_require__(271);
    var collection = __webpack_require__(270);
    var localBlackList = __webpack_require__(349);
    function constructUrl(urlString) {
        var normalUrl = urlUtils.getNormalUrl(urlString);
        normalUrl = urlUtils.deleteTechnicalParam(normalUrl);
        return urlUtils.createURI(normalUrl);
    }
    function processNewThumb(index, data) {
        var thumb = createThumb(index, data);
        localBlackList.deleteOne(urlUtils.getNormalDomain(thumb.url));
        collection.setItem(index, thumb);
        thumb.update();
    }
    function createThumb(index, data) {
        var existingThumb = collection.getItem(index);
        var thumb = existingThumb || new Thumb();
        thumb.url = data.uri.href();
        if (data.title || existingThumb && existingThumb.title) thumb.title = data.title;
        thumb.pinned = 1;
        return thumb;
    }
    module.exports = function(index, data) {
        logger.info("Saving thumb %i, %j", index, data);
        data.uri = constructUrl(data.url);
        if (isUriAcceptable(data.uri)) processNewThumb(index, data); else collection.onUpdateError.dispatch(index);
    };
    function isUriAcceptable(uri) {
        return uri && (uri.is("url") || uri.is("urn"));
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var collection = __webpack_require__(270);
    var logger = __webpack_require__(5).create("RemoveThumb");
    var blackList = __webpack_require__(349);
    var urlUtils = __webpack_require__(83);
    module.exports = function(index) {
        var thumb = collection.getItem(index);
        if (thumb) {
            logger.info("Remove %s", thumb.url);
            removeThumb(thumb, index);
        }
    };
    function removeThumb(thumb, index) {
        collection.removeItem(index);
        var domain = urlUtils.getNormalDomain(thumb.url);
        if (!collection.hasDomain(domain)) blackList.upsertOne(domain);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var collection = __webpack_require__(270);
    module.exports = function(oldIndex, newIndex) {
        var thumb = collection.getItem(oldIndex);
        if (thumb && oldIndex !== newIndex) {
            thumb.pinned = true;
            collection.removeItem(oldIndex).insertItem(newIndex, thumb);
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var collection = __webpack_require__(270);
    var logger = __webpack_require__(5).create("ThumbPinner");
    exports.pin = function(index) {
        doPinAction(true, index);
    };
    exports.unpin = function(index) {
        doPinAction(false, index);
    };
    function doPinAction(pinFlag, index) {
        var thumb = collection.getItem(index);
        if (thumb && Boolean(thumb.pinned) !== pinFlag) {
            logger.info("Thumb %i %s; set pinned state: %s", index, thumb.url, pinFlag);
            thumb.pinned = pinFlag;
        } else logWarning(thumb);
    }
    function logWarning(thumb) {
        if (thumb) logger.warn("Incorrect pin attempt, %s %s", "thumb already in this pinned state:", thumb.pinned); else logger.warn("Incorrect pin attempt, %s", "thumb does not exist");
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var thumbSuggest = __webpack_require__(470);
    var thumbSender = __webpack_require__(269);
    var events = __webpack_require__(268);
    exports.init = function() {
        messaging.on(events.frontend.REQUEST_LAST_VISITED, function(req, sender, sendResponse) {
            thumbSuggest.getLastVisited(req.offset, function(thumbs) {
                sendResponse(formatThumbs(thumbs));
            });
            return true;
        });
        messaging.on(events.frontend.REQUEST_POPULAR_SITES, function(req, sender, sendResponse) {
            thumbSuggest.getPopular(req.offset, function(thumbs) {
                sendResponse(formatThumbs(thumbs));
            });
            return true;
        });
        thumbSuggest.onThumbUpdated.addListener(onSuggestThumbUpdated);
    };
    function formatThumbs(thumbs) {
        return thumbs.map(thumbSender.formatThumbForFrontend);
    }
    function onSuggestThumbUpdated(thumb) {
        thumbSender.sendThumbData(thumb);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asyncLib = __webpack_require__(209);
    var collection = __webpack_require__(270);
    var bookmarks = __webpack_require__(220);
    var tabs = __webpack_require__(282);
    var urlUtils = __webpack_require__(83);
    var createSuggestResults = __webpack_require__(471);
    var topHistory = __webpack_require__(395);
    var sorter = __webpack_require__(402);
    var logger = __webpack_require__(5).create("ThumbSuggest");
    var pickupStorage = __webpack_require__(401);
    var find = __webpack_require__(197);
    var channel = __webpack_require__(27);
    var BOOKMARK_BOOST = 6;
    exports.getLastVisited = function(offset, callback) {
        asyncLib.parallel({
            visibleThumbDomains: getVisibleThumbDomains,
            tabs: getOpenTabs,
            history: getHistory
        }, function(_error, data) {
            data.thumbs = (data.tabs || []).concat(data.history);
            prepareSuggestThumbs(data, offset, callback);
        });
    };
    exports.getPopular = function(offset, callback) {
        asyncLib.parallel({
            visibleThumbDomains: getVisibleThumbDomains,
            bookmarks: getBookmarks,
            pickupCandidates: getPickupCandidates
        }, function(_error, data) {
            data.thumbs = createPopularThumbList(data.bookmarks, data.pickupCandidates);
            prepareSuggestThumbs(data, offset, callback);
        });
    };
    exports.onThumbUpdated = channel.create();
    function prepareSuggestThumbs(data, offset, callback) {
        createSuggestResults(data, offset, function(thumbs) {
            thumbs.forEach(updateThumb);
            callback(thumbs);
        });
    }
    function updateThumb(thumb) {
        if (!thumb.onChanged.hasListener(onThumbUpdated)) thumb.onChanged.addListener(onThumbUpdated);
        thumb.update();
    }
    function onThumbUpdated(thumb) {
        exports.onThumbUpdated.dispatch(thumb);
    }
    function getOpenTabs(callback) {
        tabs.getOpen(function(error, tabs) {
            if (error) logger.info("getOpenTabs error: %j", error);
            callback(null, tabs);
        });
    }
    function getBookmarks(callback) {
        bookmarks.requestAll(function(error, results) {
            if (error) logger.info("getBookmarks error: %j", error);
            callback(null, results);
        });
    }
    function getVisibleThumbDomains(callback) {
        var domains = collection.items.map(function(thumb) {
            return urlUtils.getNormalDomain(thumb.url);
        });
        callback(null, domains);
    }
    function getHistory(callback) {
        topHistory({
            minVisits: 2
        }, function(history) {
            callback(null, sortHistoryList(history));
        });
    }
    function sortHistoryList(list) {
        return list.sort(function(a, b) {
            return b.lastVisitTime - a.lastVisitTime;
        });
    }
    function getPickupCandidates(callback) {
        pickupStorage.get(function(error, result) {
            if (error) logger.info("pickupStorage error: %j", error);
            callback(null, result);
        });
    }
    function createPopularThumbList(bookmarks, pickupCandidates) {
        var thumbs = addBookmarksToThumbList(pickupCandidates, bookmarks);
        return thumbs.sort(sorter);
    }
    function addBookmarksToThumbList(list, bookmarks) {
        var bookmarksToAdd = [];
        for (var i = 0; i < bookmarks.length; i++) {
            var bookmarkThumbData = createThumbDataFromBookmark(bookmarks[i]);
            var thumbData = find(list, "url", bookmarkThumbData.url);
            if (thumbData) thumbData.visits = (thumbData.visits || 0) + BOOKMARK_BOOST; else bookmarksToAdd.push(bookmarkThumbData);
        }
        return list.concat(bookmarksToAdd);
    }
    function createThumbDataFromBookmark(bookmark) {
        return {
            url: bookmark.url,
            title: bookmark.title,
            visits: BOOKMARK_BOOST
        };
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var urlUtils = __webpack_require__(83);
    var Thumb = __webpack_require__(271);
    var blacklist = __webpack_require__(398);
    var MAX_RESULT_COUNT = 40;
    var PAGE_SIZE = 11;
    module.exports = function(data, offset, callback) {
        blacklist.createChecker(function(blacklistChecker) {
            var thumbs = data.thumbs;
            thumbs = filterThumbList(thumbs, data.visibleThumbDomains, blacklistChecker);
            thumbs = paginateList(thumbs, offset);
            thumbs = thumbs.map(Thumb.fromJSON);
            callback(thumbs);
        });
    };
    function filterThumbList(thumbList, visibleThumbDomains, blacklistChecker) {
        var result = [];
        var domainsToExclude = visibleThumbDomains;
        for (var i = 0; i < thumbList.length; i++) {
            if (result.length >= MAX_RESULT_COUNT) break;
            var thumbData = thumbList[i];
            var thumbDomain = urlUtils.getNormalDomain(thumbData.url);
            if (isThumbSuitable(thumbData, thumbDomain, domainsToExclude, blacklistChecker)) {
                domainsToExclude.push(thumbDomain);
                result.push(thumbData);
            }
        }
        return result;
    }
    function isThumbSuitable(thumbData, thumbDomain, domainsToExclude, blacklistChecker) {
        return domainsToExclude.indexOf(thumbDomain) === -1 && !blacklistChecker.contains(thumbData.url, thumbDomain) && urlUtils.isRemote(thumbData.url);
    }
    function paginateList(list, offset) {
        offset = offset || 0;
        return list.splice(offset, PAGE_SIZE);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var platformBrowser = __webpack_require__(377);
    var logger = __webpack_require__(5).create("Panels");
    var events = __webpack_require__(268);
    module.exports = {
        init: function() {
            messaging.on(events.frontend.OPEN_EXTERNAL_WINDOW, function(req) {
                logger.info("Opening %s", req.windowName);
                switch (req.windowName) {
                  case "bookmarks":
                    platformBrowser.openBookmarksWindow();
                    break;

                  case "history":
                    platformBrowser.openHistoryWindow();
                    break;

                  case "downloads":
                    platformBrowser.openDownloadsWindow();
                    break;

                  default:
                    logger.warn("Unknown windowName %s", req.windowName);
                }
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _sources;
    function _defineProperty(obj, key, value) {
        if (key in obj) Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        }); else obj[key] = value;
        return obj;
    }
    var messaging = __webpack_require__(213);
    var urlUtils = __webpack_require__(83);
    var platformAbout = __webpack_require__(23);
    var events = __webpack_require__(268);
    var XB_URL_REG_EXP = /^xb:\/\//;
    var sources = (_sources = {}, _defineProperty(_sources, events.frontend.SEARCH_HISTORY, {
        id: 0,
        fn: __webpack_require__(474)
    }), _defineProperty(_sources, events.frontend.SEARCH_BOOKMARKS, {
        id: 1,
        fn: __webpack_require__(477)
    }), _defineProperty(_sources, events.frontend.SEARCH_OPENED_TABS, {
        id: 2,
        fn: __webpack_require__(478)
    }), _defineProperty(_sources, events.frontend.SEARCH_WEB, {
        id: 3,
        fn: __webpack_require__(479)
    }), _sources);
    module.exports = {
        init: function() {
            Object.keys(sources).forEach(createOnMessageHandler);
        }
    };
    function createOnMessageHandler(msgName) {
        messaging.on(msgName, function(req, sender, sendResponse) {
            var query = req.word || req.query;
            var source = sources[msgName];
            source.fn(query, function(err, items) {
                sendResponse({
                    source: source.id,
                    query: req.query,
                    data: err ? [] : convertItems(items)
                });
            });
            return true;
        });
    }
    function convertItems(items) {
        if (!Array.isArray(items)) return [];
        return items.reduce(function(result, item) {
            if (!isBadUrl(item.url)) {
                item.url = urlUtils.getReadableUrl(item.url);
                result.push(item);
            }
            return result;
        }, []);
    }
    function isBadUrl(url) {
        return urlUtils.isEqualUrls(platformAbout.visbookmarksUrl, url) || urlUtils.isEqualUrls(platformAbout.visbookmarksFakeTabUrl, url) || XB_URL_REG_EXP.test(url);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asyncLib = __webpack_require__(209);
    var flatten = __webpack_require__(475);
    var weights = __webpack_require__(476);
    var isRelease = __webpack_require__(218).git.release;
    var dateUtils = __webpack_require__(4);
    var logger = __webpack_require__(5).create("url-suggest/search-history");
    var browserInfo = __webpack_require__(22);
    var NATIVE_SEARCH_MAX_COUNT = 100;
    var CUSTOM_SEARCH_MAX_COUNT = 4e3;
    var OUTPUT_COUNT = 10;
    module.exports = function(query, callback) {
        historySearch(query, function(err, historyItems) {
            if (err) {
                logger.error("Error in history search: %j", err);
                callback(err);
            } else {
                var items = filterByWeights(query, historyItems);
                printInDebug(query, items);
                callback(null, items);
            }
        });
    };
    function historySearch(query, callback) {
        var tasks = [ nativeHistorySearch.bind(null, query) ];
        if (browserInfo.isChrome()) tasks.push(customHistorySearch.bind(null, query));
        asyncLib.parallel(tasks, function(err, data) {
            callback(err, data ? flatten(data) : []);
        });
    }
    function customHistorySearch(query, callback) {
        chrome.history.search({
            text: "",
            maxResults: CUSTOM_SEARCH_MAX_COUNT,
            startTime: Date.now() - dateUtils.WEEK_MS
        }, function(historyItems) {
            var items = filterUnmatched(historyItems, query);
            callback(null, items);
        });
    }
    function nativeHistorySearch(query, callback) {
        chrome.history.search({
            text: query,
            maxResults: NATIVE_SEARCH_MAX_COUNT
        }, function(historyItems) {
            callback(null, historyItems);
        });
    }
    function filterUnmatched(historyItems, query) {
        return historyItems.filter(function(item) {
            return item.url && item.url.indexOf(query) !== -1 || item.title && item.title.indexOf(query) !== -1;
        });
    }
    function filterByWeights(query, histroryItems) {
        var items = histroryItems.map(convertToItemWithWeight);
        return weights.calc(query, items, OUTPUT_COUNT, true);
    }
    function convertToItemWithWeight(historyItem) {
        return weights.getItem(historyItem.url, historyItem.title, 2 * historyItem.typedCount + historyItem.visitCount);
    }
    function printInDebug(query, items) {
        if (!isRelease) weights.printItems("Search history: " + query, items);
    }
}, function(module, exports, __webpack_require__) {
    var baseFlatten = __webpack_require__(76), isIterateeCall = __webpack_require__(98);
    function flatten(array, isDeep, guard) {
        var length = array ? array.length : 0;
        if (guard && isIterateeCall(array, isDeep, guard)) isDeep = false;
        return length ? baseFlatten(array, isDeep) : [];
    }
    module.exports = flatten;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var urlUtils = __webpack_require__(83);
    function getFoundMap(substrArr, str) {
        return substrArr.reduce(function(res, s) {
            var index = str.indexOf(s);
            if (index >= 0) res[s] = true;
            return res;
        }, {});
    }
    function multiplyWeight(item, koef, comment) {
        var msg = "x " + koef + (comment ? "(" + comment + ")" : "");
        item.log = item.log || [ item.weight ];
        item.log.push(msg);
        item.weight = item.weight * koef;
    }
    function hasUrlSymbols(query) {
        return /[\/\.]/.test(query);
    }
    function multiplyUrlQuery(query, item) {
        if (item.foundInUrl[query]) multiplyWeight(item, 100, "url with full query"); else if (item.foundInTitle[query]) multiplyWeight(item, 50, "title with full query");
        return item;
    }
    function multiplyMultiWords(query, item) {
        var notQuery = function(v) {
            return v !== query;
        };
        var countInUrl = Object.keys(item.foundInUrl).filter(notQuery).length;
        var countInTitle = Object.keys(item.foundInTitle).filter(notQuery).length;
        multiplyWeight(item, 10, "koef");
        multiplyWeight(item, countInUrl + countInTitle, "x word count matched in title / url");
        if (item.foundInUrl[query] || item.foundInTitle[query]) multiplyWeight(item, 100, "full phrase match");
        return item;
    }
    function multiplySingleWord(query, item) {
        var str = (item.url + " " + item.title).replace(/&quot;/g, '"').replace(/&#039;/g, "'");
        var tokens = str.split(/[\.\/\s\-"':,;]+/);
        tokens = tokens.slice(1);
        if ("www" === tokens[0]) tokens = tokens.slice(1);
        tokens.every(function(token, pos) {
            if (token && 0 === token.indexOf(query)) {
                multiplyWeight(item, Math.max(100 - 10 * pos, 1), "token #" + (pos + 1) + " match");
                return false;
            } else return true;
        });
        return item;
    }
    module.exports = {
        getItem: function(url, title, weight) {
            return {
                url: url,
                title: title,
                weight: weight
            };
        },
        calc: function(query, items, count, doFilter) {
            query = query.trim().toLowerCase();
            var words = query.split(/\s+/);
            words = words.length > 1 ? words : [];
            var searches = [ query ].concat(words);
            items = items.filter(function(item) {
                item.uri = urlUtils.createURI(item.url);
                return Boolean(item.uri);
            });
            items = items.map(function(item) {
                var uri = item.uri;
                var readable = item.url;
                try {
                    readable = uri.readable();
                } catch (e) {}
                var title = item.title || "";
                var resItem = {
                    url: readable.toLowerCase(),
                    uri: uri,
                    sourceTitle: title,
                    title: title.toLowerCase(),
                    weight: item.weight
                };
                resItem.foundInUrl = getFoundMap(searches, resItem.url);
                resItem.foundInTitle = getFoundMap(searches, resItem.title);
                return resItem;
            });
            if (false !== doFilter) items = items.filter(function(item) {
                return Object.keys(item.foundInUrl).length || Object.keys(item.foundInTitle).length;
            }).filter(function(item) {
                return Boolean(item.uri.hostname());
            });
            items = items.map(function(item) {
                if (words.length && (item.foundInUrl[query] || item.foundInTitle[query])) multiplyWeight(item, words.length, "words.length");
                if ("/" === item.uri.path() && "" === item.uri.search() && "" === item.uri.hash()) multiplyWeight(item, 2, "canonic url");
                return item;
            });
            if (hasUrlSymbols(query)) items = items.map(multiplyUrlQuery.bind(null, query)); else if (words.length) items = items.map(multiplyMultiWords.bind(null, query)); else items = items.map(multiplySingleWord.bind(null, query));
            var hostnames = items.reduce(function(res, item) {
                var host = item.uri.hostname();
                if (!res[host] || res[host].weight < item.weight) res[host] = item;
                return res;
            }, {});
            items = Object.keys(hostnames).map(function(hostname) {
                var item = hostnames[hostname];
                var resItem = {
                    url: item.uri.toString(),
                    title: item.sourceTitle,
                    domain: hostname,
                    weight: item.weight,
                    log: Array.isArray(item.log) ? item.log.join(" ") : ""
                };
                return resItem;
            });
            items.sort(function(a, b) {
                return b.weight - a.weight;
            });
            if (count) items = items.slice(0, count);
            return items;
        },
        printItems: function(title, items) {
            var console = window.console;
            if (console && console.table) if (items && items.length) {
                console.log(title);
                console.table(items, [ "weight", "url", "title", "log" ]);
            } else console.log(title, "(empty result)");
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var weights = __webpack_require__(476);
    var isRelease = __webpack_require__(218).git.release;
    var INITIAL_WEIGHT = 1;
    var OUTPUT_COUNT = 7;
    module.exports = function(query, callback) {
        chrome.bookmarks.search(query, function(bookmarks) {
            var items = bookmarks.map(convertToItem);
            items = weights.calc(query, items, OUTPUT_COUNT, true);
            callback(null, items);
            printInDebug(query, items);
        });
    };
    function convertToItem(bookmark) {
        return weights.getItem(bookmark.url, bookmark.title, INITIAL_WEIGHT);
    }
    function printInDebug(query, items) {
        if (!isRelease) weights.printItems("Search bookmarks: " + query, items);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var tabsUtils = __webpack_require__(282);
    var weights = __webpack_require__(476);
    var isRelease = __webpack_require__(218).git.release;
    var INITIAL_WEIGHT = 1;
    var OUTPUT_COUNT = 0;
    module.exports = function(query, callback) {
        tabsUtils.getOpen(function(err, tabs) {
            if (err) callback(err); else {
                var items = tabs.map(convertToItem);
                items = weights.calc(query, items, OUTPUT_COUNT, true);
                callback(null, items);
                printInDebug(query, items);
            }
        });
    };
    function convertToItem(tab) {
        return weights.getItem(tab.url, tab.title, INITIAL_WEIGHT);
    }
    function printInDebug(query, items) {
        if (!isRelease) weights.printItems("Search opened tabs: " + query, items);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var branding = __webpack_require__(277);
    var curly = __webpack_require__(207);
    var xhr = __webpack_require__(32);
    var urlUtils = __webpack_require__(83);
    var weights = __webpack_require__(476);
    var isRelease = __webpack_require__(218).git.release;
    var OUTPUT_COUNT = 10;
    module.exports = function(query, callback) {
        xhr({
            url: getUrl(query),
            logError: true,
            parse: "json"
        }, function(err, json) {
            if (err) callback(err); else {
                var items = parseResponse(json).map(convertToItem);
                items = weights.calc(query, items, OUTPUT_COUNT, false);
                callback(null, items);
                printInDebug(query, items);
            }
        });
    };
    function getUrl(query) {
        return curly.insertUrlVars(branding.thumbs.suggestUrl, {
            searchTerms: query
        });
    }
    function parseResponse(arr) {
        var urls = arr[1];
        var titles = arr[2];
        return urls.map(function(url, i) {
            return {
                url: urlUtils.getNormalUrl(url),
                title: titles[i]
            };
        });
    }
    function convertToItem(webItem, i) {
        return weights.getItem(webItem.url, webItem.title, Math.max(.9 - i / 10, .1).toFixed(1));
    }
    function printInDebug(query, items) {
        if (!isRelease) weights.printItems("Search web: " + query, items);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var navigations = __webpack_require__(343);
    var events = __webpack_require__(268);
    exports.init = function() {
        messaging.on(events.frontend.NAVIGATE_URL, function(req, sender) {
            var params = {
                url: req.url,
                tabId: sender.tab && sender.tab.id,
                target: req.target,
                thumbPosition: req.index
            };
            navigations.go(params);
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var events = __webpack_require__(268);
    exports.init = function() {
        messaging.on(events.frontend.SET_SCROLL_STATE, function() {});
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var searchSuggest = __webpack_require__(483);
    var events = __webpack_require__(268);
    exports.init = function() {
        messaging.on(events.frontend.SEARCH_MAIN, function(req, sender, sendResponse) {
            searchSuggest.get(req.query, sendResponse);
            return true;
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("Search Suggest");
    var branding = __webpack_require__(277);
    var xhr = __webpack_require__(32);
    var curly = __webpack_require__(207);
    var searchRequest;
    var SEARCH_MAIN_TIMEOUT_MS = 5e3;
    exports.get = function(queryString, callback) {
        logger.info("Loading suggest for query: %j", queryString);
        var suggestURL = curly.insertUrlVars(branding.search.suggest, {
            searchTerms: queryString
        });
        searchRequest = xhr({
            url: suggestURL,
            timeout: SEARCH_MAIN_TIMEOUT_MS,
            logError: true,
            parse: "text"
        }, function(err, responseText, evt) {
            if (err || searchRequest !== evt.target) callback(""); else callback(responseText);
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var informers = __webpack_require__(302);
    var events = __webpack_require__(268);
    exports.init = function() {
        informers.onUpdated.addListener(exports.send);
        informers.onEnabledChanged.addListener(exports.send);
    };
    exports.send = function() {
        if (informers.isSupported()) {
            if (informers.isEnabled()) return informers.getData().then(function(data) {
                messaging.send(events.backend.INFORMERS, data);
            });
            messaging.send(events.backend.INFORMERS, null);
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(213);
    var logger = __webpack_require__(5).create("Frontend/voice");
    var Voice = __webpack_require__(486);
    var voiceEvents = __webpack_require__(487);
    var events = __webpack_require__(268);
    module.exports = {
        init: function() {
            var voice = void 0;
            messaging.on(events.frontend.VOICE_INIT, function(request, sender) {
                if (voice) voice.finalize();
                voice = Voice.createForWebNavigation(sender.tab.id).record();
            });
            messaging.on(events.frontend.VOICE_STOP, function() {
                if (voice) voice.finalize();
            });
            voiceEvents.onProgress.addListener(function(_ref) {
                var tabId = _ref.tabId, text = _ref.text;
                messaging.send(events.backend.VOICE_PROGRESS, {
                    text: text
                }, tabId);
            });
            voiceEvents.onStart.addListener(function(_ref2) {
                var tabId = _ref2.tabId;
                messaging.send(events.backend.VOICE_START, null, tabId);
            });
            voiceEvents.onError.addListener(function(_ref3) {
                var tabId = _ref3.tabId, reason = _ref3.reason;
                messaging.send(events.backend.VOICE_ERROR, {
                    reason: reason
                }, tabId);
            });
            voiceEvents.onRecordFinished.addListener(function(_ref4) {
                var tabId = _ref4.tabId, text = _ref4.text;
                messaging.send(events.backend.VOICE_FINISH, {
                    text: text
                }, tabId);
            });
            voiceEvents.onClose.addListener(function(_ref5) {
                var tabId = _ref5.tabId;
                messaging.send(events.backend.VOICE_CLOSE, null, tabId);
            });
            logger.info("Initialized");
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var logger = __webpack_require__(5).create("Voice");
    var _require = __webpack_require__(440);
    _require.REJECT_TIMESTAMP;
    var offscreenEvents = __webpack_require__(69);
    var offscreenManager = __webpack_require__(70);
    var events = __webpack_require__(487);
    var SerpNavigator = __webpack_require__(488);
    var SiteNavigator = __webpack_require__(491);
    var Consumer = __webpack_require__(489);
    var thenChrome = __webpack_require__(283);
    var settings = __webpack_require__(216);
    var _require2 = __webpack_require__(410), IS_VOICE_USED = _require2.IS_VOICE_USED, ANIMATION_TIMEOUT_MS = _require2.ANIMATION_TIMEOUT_MS, ERROR_REASON = _require2.ERROR_REASON, SILENCE_TIMEOUT_MS = _require2.SILENCE_TIMEOUT_MS, STATUS = _require2.STATUS;
    var Voice = function() {
        function Voice(tabId) {
            _classCallCheck(this, Voice);
            this.consumers = [];
            this.previousText = "";
            this.tabId = tabId;
            this._tabActivationHandlerBinded = this._tabActivationHandler.bind(this);
            this._updateNavigationHandlerBinded = this._updateNavigationHandler.bind(this);
            this._handleOffscreenMessageBinded = this._handleOffscreenMessage.bind(this);
            this.status = STATUS.READY;
            logger.info("Streamer is ready");
        }
        _createClass(Voice, [ {
            key: "_handleOffscreenMessage",
            value: function(req) {
                if (!req.data) return;
                switch (req.type) {
                  case offscreenEvents.offscreen.SPEECHKIT_DATA:
                    this._dataHandler(req.data);
                    break;

                  case offscreenEvents.offscreen.SPEECHKIT_ERROR:
                    this._throwError(req.data.reason);
                    break;

                  default:
                    return;
                }
            }
        }, {
            key: "_initSpeechkit",
            value: function() {
                var _this = this;
                var callback = function(message) {
                    var errObj = message.errObj;
                    if (errObj) _this._throwError(errObj.message); else _this._initHandler();
                };
                var msgBody = {
                    type: offscreenEvents.backend.SPEECHKIT_INIT,
                    data: {},
                    idle: true
                };
                offscreenManager.sendMessage(msgBody, "Speechkit init timed out", callback);
            }
        }, {
            key: "_stopSpeechkit",
            value: function() {
                var _this2 = this;
                var callback = function(message) {
                    var errObj = message.errObj;
                    if (errObj) _this2._throwError(errObj.message); else offscreenManager.resetTimeout();
                };
                var msgBody = {
                    type: offscreenEvents.backend.SPEECHKIT_STOP,
                    data: {},
                    idle: true
                };
                offscreenManager.sendMessage(msgBody, "Speechkit stop timed out", callback);
            }
        }, {
            key: "addConsumer",
            value: function(consumer) {
                this.consumers.push(consumer);
            }
        }, {
            key: "record",
            value: function() {
                this.status = STATUS.CONNECTING;
                this._initSpeechkit();
                offscreenManager.addOffscreenListener(this._handleOffscreenMessageBinded);
                chrome.tabs.onActivated.addListener(this._tabActivationHandlerBinded);
                chrome.windows.onFocusChanged.addListener(this._tabActivationHandlerBinded);
                chrome.webNavigation.onBeforeNavigate.addListener(this._updateNavigationHandlerBinded);
                chrome.webNavigation.onCommitted.addListener(this._updateNavigationHandlerBinded);
                if (true !== settings.get(IS_VOICE_USED)) settings.set(IS_VOICE_USED, true);
                return this;
            }
        }, {
            key: "stopRecording",
            value: function() {
                if (!this.isRecording) return;
                clearTimeout(this.silenceTimeout);
                this.previousText = "";
                this._stopSpeechkit();
                logger.info("Recording was stopped");
            }
        }, {
            key: "finalize",
            value: function() {
                var status = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : STATUS.FINISHED;
                if (this.isFinished) return;
                this.stopRecording();
                if (this.status === STATUS.PROCESSING) this.consumers.forEach(function(consumer) {
                    return consumer.stop();
                });
                this.status = status;
                offscreenManager.removeOffscreenListener(this._handleOffscreenMessageBinded);
                chrome.tabs.onActivated.removeListener(this._tabActivationHandlerBinded);
                chrome.windows.onFocusChanged.removeListener(this._tabActivationHandlerBinded);
                chrome.webNavigation.onBeforeNavigate.removeListener(this._updateNavigationHandlerBinded);
                chrome.webNavigation.onCommitted.removeListener(this._updateNavigationHandlerBinded);
                logger.info("Finalized");
            }
        }, {
            key: "_initHandler",
            value: function() {
                var _this3 = this;
                this.status = STATUS.RECORD;
                this.silenceTimeout = setTimeout(function() {
                    return _this3._throwError(ERROR_REASON.SILENCE);
                }, SILENCE_TIMEOUT_MS);
                events.onStart.dispatch({
                    tabId: this.tabId
                });
            }
        }, {
            key: "_tabActivationHandler",
            value: function() {
                var _this4 = this;
                var tabId = this.tabId;
                thenChrome.tabs.get(tabId).then(function() {
                    if (_this4.isReady || _this4.isRecording) _this4._interrupt(true);
                }).catch(function() {
                    return _this4._interrupt();
                });
            }
        }, {
            key: "_interrupt",
            value: function() {
                var sendOnClose = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
                this.finalize(STATUS.INTERRUPTED);
                if (sendOnClose) events.onClose.dispatch({
                    tabId: this.tabId
                });
            }
        }, {
            key: "_updateNavigationHandler",
            value: function(_ref) {
                var tabId = _ref.tabId;
                if (tabId === this.tabId) this._interrupt();
            }
        }, {
            key: "_throwError",
            value: function(reason) {
                if (this.inProcess) {
                    this.finalize(STATUS.ERROR);
                    events.onError.dispatch({
                        tabId: this.tabId,
                        reason: reason
                    });
                }
            }
        }, {
            key: "_dataHandler",
            value: function(_ref2) {
                var _this5 = this;
                var text = _ref2.text, done = _ref2.done;
                if (this.status !== STATUS.RECORD) return;
                var isTextChanged = text !== this.previousText;
                var shouldNotify = isTextChanged || done;
                if (!shouldNotify) return;
                clearTimeout(this.silenceTimeout);
                var tabId = this.tabId;
                this.previousText = text;
                events.onProgress.dispatch({
                    tabId: tabId,
                    text: text
                });
                if (done) {
                    this.stopRecording();
                    this.status = STATUS.PROCESSING;
                    events.onRecordFinished.dispatch({
                        tabId: tabId,
                        text: text
                    });
                    this._recognize(text).catch(function(interceptedBy) {
                        if (interceptedBy instanceof Consumer) return Promise.resolve(interceptedBy);
                    }).then(function(interceptBy) {
                        return _this5._callPostRecognizeEvents(text, interceptBy);
                    }).then(function(interceptBy) {
                        return interceptBy.run();
                    }).then(function() {
                        return _this5.finalize();
                    }).catch(function() {
                        return _this5.finalize(STATUS.INTERRUPTED);
                    });
                }
            }
        }, {
            key: "_recognize",
            value: function(text) {
                var _this6 = this;
                return this.consumers.reduce(function(promise, consumer) {
                    return promise.then(function() {
                        return _this6._callConsumer(consumer, text);
                    });
                }, Promise.resolve(null));
            }
        }, {
            key: "_callConsumer",
            value: function(currentConsumer, text) {
                if (this.isFinished) return Promise.reject();
                return currentConsumer.check(text).then(function(isIntercepted) {
                    return isIntercepted ? Promise.reject(currentConsumer) : null;
                });
            }
        }, {
            key: "_callPostRecognizeEvents",
            value: function(text, interceptedBy) {
                if (interceptedBy) events.onRecognized.dispatch({
                    tabId: this.tabId,
                    text: text,
                    consumer: interceptedBy
                }); else events.onNotRecognized.dispatch({
                    tabId: this.tabId,
                    text: text
                });
                return interceptedBy;
            }
        }, {
            key: "isRecording",
            get: function() {
                return !this.isReady && this.status < STATUS.PROCESSING;
            }
        }, {
            key: "inProcess",
            get: function() {
                return !this.isReady || !this.isFinished;
            }
        }, {
            key: "isReady",
            get: function() {
                return this.status === STATUS.READY;
            }
        }, {
            key: "isFinished",
            get: function() {
                return this.status >= STATUS.FINISHED;
            }
        } ], [ {
            key: "createForWebNavigation",
            value: function(tabId) {
                var voice = new Voice(tabId);
                voice.addConsumer(new SiteNavigator(tabId, ANIMATION_TIMEOUT_MS));
                voice.addConsumer(new SerpNavigator(tabId, ANIMATION_TIMEOUT_MS));
                return voice;
            }
        } ]);
        return Voice;
    }();
    module.exports = Voice;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Channel = __webpack_require__(27);
    module.exports = {
        onRecordFinished: new Channel("onRecordFinished"),
        onProgress: new Channel("onProgress"),
        onStart: new Channel("onStart"),
        onClose: new Channel("onClose"),
        onError: new Channel("onError"),
        onNotRecognized: new Channel("onNotRecognized"),
        onRecognized: new Channel("onRecognized")
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return call && ("object" === typeof call || "function" === typeof call) ? call : self;
    }
    function _inherits(subClass, superClass) {
        if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var navigations = __webpack_require__(343);
    var branding = __webpack_require__(277);
    var curly = __webpack_require__(207);
    var Consumer = __webpack_require__(489);
    var PromisedTimer = __webpack_require__(490);
    var SerpNavigator = function(_Consumer) {
        _inherits(SerpNavigator, _Consumer);
        function SerpNavigator(tabId) {
            var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            var target = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : navigations.TARGET.TAB;
            _classCallCheck(this, SerpNavigator);
            var _this = _possibleConstructorReturn(this, (SerpNavigator.__proto__ || Object.getPrototypeOf(SerpNavigator)).call(this));
            _this.delay = delay;
            _this.target = target;
            _this.tabId = tabId;
            return _this;
        }
        _createClass(SerpNavigator, [ {
            key: "check",
            value: function(text) {
                this.checkResult = text;
                return Promise.resolve(true);
            }
        }, {
            key: "run",
            value: function() {
                var _this2 = this;
                var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, text = _ref.text;
                text = text || this.checkResult;
                this.timeout = new PromisedTimer(this.delay);
                return this.timeout.then(function() {
                    return _this2._goToSerp(text);
                }).catch(function() {
                    return Promise.resolve();
                });
            }
        }, {
            key: "stop",
            value: function() {
                if (this.timeout) this.timeout.stop();
            }
        }, {
            key: "_goToSerp",
            value: function(query) {
                var url = curly.insertUrlVars(branding.search.url, {
                    searchTerms: query
                });
                navigations.go({
                    url: url,
                    target: this.target,
                    tabId: this.tabId
                });
            }
        } ]);
        return SerpNavigator;
    }(Consumer);
    module.exports = SerpNavigator;
}, function(module, exports) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Consumer = function() {
        function Consumer() {
            _classCallCheck(this, Consumer);
        }
        _createClass(Consumer, [ {
            key: "check",
            value: function() {
                throw new Error("Not implemented");
            }
        }, {
            key: "run",
            value: function() {
                throw new Error("Not implemented");
            }
        }, {
            key: "stop",
            value: function() {
                throw new Error("Not implemented");
            }
        } ]);
        return Consumer;
    }();
    module.exports = Consumer;
}, function(module, exports) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var PromisedTimer = function() {
        function PromisedTimer(delay) {
            var _this = this;
            _classCallCheck(this, PromisedTimer);
            this.promise = new Promise(function(resolve, reject) {
                _this.timeoutId = setTimeout(resolve, delay);
                _this._onStop = reject;
            });
        }
        _createClass(PromisedTimer, [ {
            key: "stop",
            value: function() {
                clearTimeout(this.timeoutId);
                this._onStop();
            }
        }, {
            key: "then",
            value: function(callback, errback) {
                return this.promise.then(callback, errback);
            }
        }, {
            key: "catch",
            value: function(errback) {
                return this.promise.catch(errback);
            }
        } ]);
        return PromisedTimer;
    }();
    module.exports = PromisedTimer;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self, call) {
        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return call && ("object" === typeof call || "function" === typeof call) ? call : self;
    }
    function _inherits(subClass, superClass) {
        if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Consumer = __webpack_require__(489);
    var SerpNavigator = __webpack_require__(488);
    var vbFetch = __webpack_require__(72);
    var navigations = __webpack_require__(343);
    var intersection = __webpack_require__(492);
    var PromisedTimer = __webpack_require__(490);
    var SiteNavigator = function(_Consumer) {
        _inherits(SiteNavigator, _Consumer);
        function SiteNavigator(tabId) {
            var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            var target = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : navigations.TARGET.TAB;
            _classCallCheck(this, SiteNavigator);
            var _this = _possibleConstructorReturn(this, (SiteNavigator.__proto__ || Object.getPrototypeOf(SiteNavigator)).call(this));
            _this.delay = delay;
            _this.target = target;
            _this.tabId = tabId;
            _this.status = STATUS.READY;
            return _this;
        }
        _createClass(SiteNavigator, [ {
            key: "check",
            value: function(text) {
                var _this2 = this;
                var url = URL_TO_HANDLER + encodeURIComponent(text);
                this.status = STATUS.CHECKING;
                return vbFetch(url, {
                    responseType: "json"
                }).then(function(result) {
                    return _this2._processResult(result);
                }).catch(function() {
                    return false;
                });
            }
        }, {
            key: "run",
            value: function() {
                var _this3 = this;
                this.status = STATUS.NAVIGATING;
                if (this.checkResult.hasOwnProperty("text")) {
                    this.serpNavigator = new SerpNavigator(this.tabId, this.delay, this.target);
                    return this.serpNavigator.run(this.checkResult);
                }
                this.timeout = new PromisedTimer(this.delay);
                return this.timeout.then(function() {
                    return _this3._goToSite(_this3.checkResult.url);
                }).catch(function() {
                    return Promise.resolve();
                });
            }
        }, {
            key: "_processResult",
            value: function(result) {
                if (this.status === STATUS.STOPPED) return false;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = void 0;
                try {
                    for (var _step, _iterator = result.candidates[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _step.value, tags = _step$value.tags, url = _step$value.url, weight = _step$value.weight, text = _step$value.text;
                        if (0 === weight) return false;
                        if (intersection(tags, BAD_TAGS).length) continue;
                        if (!url) {
                            if (text && tags.indexOf(SEARCH_TAG) !== -1) {
                                this.checkResult = {
                                    text: text
                                };
                                return true;
                            }
                            continue;
                        }
                        this.checkResult = {
                            url: url
                        };
                        return true;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
                    } finally {
                        if (_didIteratorError) throw _iteratorError;
                    }
                }
                return false;
            }
        }, {
            key: "stop",
            value: function() {
                if (this.timeout) this.timeout.stop(); else if (this.serpNavigator) this.serpNavigator.stop();
                this.status = STATUS.STOPPED;
            }
        }, {
            key: "_goToSite",
            value: function(url) {
                navigations.go({
                    url: url,
                    target: this.target,
                    tabId: this.tabId
                });
                return true;
            }
        } ]);
        return SiteNavigator;
    }(Consumer);
    var URL_TO_HANDLER = "https://yastroka.yandex.net/speech?user_input=";
    var BAD_TAGS = [ "action", "file", "folder", "local", "off", "soft", "local search" ];
    var SEARCH_TAG = "search";
    var STATUS = {
        READY: 0,
        CHECKING: 1,
        NAVIGATING: 2,
        STOPPED: 3
    };
    module.exports = SiteNavigator;
}, function(module, exports, __webpack_require__) {
    var baseIndexOf = __webpack_require__(130), cacheIndexOf = __webpack_require__(132), createCache = __webpack_require__(133), isArrayLike = __webpack_require__(47), restParam = __webpack_require__(82);
    var intersection = restParam(function(arrays) {
        var othLength = arrays.length, othIndex = othLength, caches = Array(length), indexOf = baseIndexOf, isCommon = true, result = [];
        while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = isCommon && value.length >= 120 ? createCache(othIndex && value) : null;
        }
        var array = arrays[0], index = -1, length = array ? array.length : 0, seen = caches[0];
        outer: while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                var othIndex = othLength;
                while (--othIndex) {
                    var cache = caches[othIndex];
                    if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) continue outer;
                }
                if (seen) seen.push(value);
                result.push(value);
            }
        }
        return result;
    });
    module.exports = intersection;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var navigations = __webpack_require__(343);
    var platformAbout = __webpack_require__(23);
    var messaging = __webpack_require__(213);
    var events = __webpack_require__(268);
    module.exports = {
        init: function() {
            messaging.on(events.frontend.PAGE_VBNAVIGATE, function(request, sender) {
                navigateToVb(sender.tab.id);
            });
        }
    };
    function navigateToVb(tabId) {
        navigations.go({
            url: platformAbout.visbookmarksUrl,
            target: navigations.TARGET.TAB,
            tabId: tabId
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var cookies = __webpack_require__(425);
    var settings = __webpack_require__(216);
    var zen = __webpack_require__(495);
    var platformAbout = __webpack_require__(23);
    var tabs = __webpack_require__(282);
    var messaging = __webpack_require__(213);
    var events = __webpack_require__(268);
    module.exports = {
        init: function() {
            var _this = this;
            settings.onChanged.addListener(function(_ref) {
                var key = _ref.key, newValue = _ref.newValue;
                return "showZen" === key && newValue && _this.sendZenConfig();
            });
        },
        sendZenConfig: function(tabId) {
            Promise.all(cookies.cookiesResolves).then(function() {
                var config = zen.getConfig();
                if (tabId) messaging.send(events.backend.ZEN_CONFIG, config, tabId); else tabs.getOpen(function(err, items) {
                    (items || []).filter(function(tab) {
                        return tab.url === platformAbout.visbookmarksUrl;
                    }).forEach(function(tab) {
                        return messaging.send(events.backend.ZEN_CONFIG, config, tab.id);
                    });
                });
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
            return arr2;
        } else return Array.from(arr);
    }
    var debounce = __webpack_require__(149);
    var parse = __webpack_require__(496);
    var i18n = __webpack_require__(280);
    var browser = __webpack_require__(22);
    var backgrounds = __webpack_require__(389);
    var auth = __webpack_require__(456);
    var cookies = __webpack_require__(425);
    var alarms = __webpack_require__(3);
    var logger = __webpack_require__(5).create("zen");
    var settings = __webpack_require__(216);
    var LOADER_URL = "layout/zen/loader.js";
    var RELOAD_TIMEOUT = 60;
    var DESTROY_TIMEOUT = 5e3;
    var RELOAD_ALARM_NAME = "zen.reload";
    var COOKIE_CHANGE_DEBOUNCE_TIME = 500;
    var ua = parse(navigator.userAgent);
    var loaderScriptTag = null;
    var cookieWatcher = debounce(reloadZen, COOKIE_CHANGE_DEBOUNCE_TIME);
    exports.init = function() {
        settings.onChanged.addListener(function(_ref) {
            var key = _ref.key, newValue = _ref.newValue;
            if ("showZen" !== key) return;
            if (newValue) enable(); else disable();
        });
        if (settings.get("showZen")) enable();
    };
    exports.getConfig = function() {
        return {
            clid: 450,
            lang: i18n.locale || "ru",
            isTeethEnabled: true,
            teethType: "white-image",
            theme: "000000" === backgrounds.getCurrent().color ? "white" : "black",
            notifiersPosition: "top",
            staticHost: "/layout/zen",
            libType: "vb",
            version: "",
            uatraits: {
                isMobile: false,
                isBrowser: true,
                BrowserEngine: ua.engine.name,
                BrowserEngineVersion: ua.engine.version,
                BrowserBase: browser.isChrome() ? "Chromium" : void 0,
                BrowserBaseVersion: browser.isChrome() ? ua.browser.version : void 0,
                BrowserName: ua.browser.name,
                BrowserVersion: ua.browser.version,
                OSFamily: ua.os.name,
                OSVersion: ua.os.version
            },
            useLegacy: false,
            exps: [],
            isVideoDisabled: true,
            initialDisplayedRowsNumber: 3,
            cache: {
                api: {
                    userId: getUserId(),
                    storeId: "yandex-vb"
                }
            },
            userInfo: {
                login: auth.getYandexLogin() || void 0,
                yandexuid: auth.getYandexUid() || void 0
            }
        };
    };
    function disable() {
        logger.info("Disabling zen");
        alarms.clear(RELOAD_ALARM_NAME);
        destroyZenLib();
        cookies.onChanged.removeListener(cookieWatcher);
    }
    function enable() {
        logger.info("Enabling zen");
        Promise.all(cookies.cookiesResolves).then(function() {
            alarms.clear(RELOAD_ALARM_NAME);
            reloadZen();
            cookies.onChanged.addListener(cookieWatcher);
        });
    }
    function reloadZen() {
        logger.info("Reloading zen lib");
        destroyZenLib();
        addloaderScriptTag(createLib);
    }
    function destroyZenLib() {
        deleteLoaderScriptTag();
        deleteLibResources();
        document.querySelector("html").removeAttribute("class");
        delete window.YandexZen;
    }
    function deleteLoaderScriptTag() {
        if (loaderScriptTag) {
            document.body.removeChild(loaderScriptTag);
            loaderScriptTag = null;
        }
    }
    function deleteLibResources() {
        [].concat(_toConsumableArray(document.querySelectorAll("link, script"))).filter(function(tag) {
            return tag && (tag.href || tag.src || "").indexOf("vb-lib/vb-lib") >= 0;
        }).forEach(function(tag) {
            return tag.parentNode.removeChild(tag);
        });
    }
    function addloaderScriptTag(onLoadCallback) {
        loaderScriptTag = document.createElement("script");
        loaderScriptTag.src = LOADER_URL;
        loaderScriptTag.onload = onLoadCallback;
        document.body.appendChild(loaderScriptTag);
    }
    function createLib() {
        var config = exports.getConfig();
        YandexZen.loader.create(config).then(scheduleReload).catch(scheduleReload);
    }
    function scheduleReload() {
        alarms.clear(RELOAD_ALARM_NAME);
        alarms.register({
            name: RELOAD_ALARM_NAME,
            delayInMinutes: RELOAD_TIMEOUT
        }, reloadZen);
        setTimeout(destroyZenLib, DESTROY_TIMEOUT);
    }
    function getUserId() {
        var yandexUid = auth.getYandexUid();
        var yandexLogin = auth.getYandexLogin();
        if (yandexUid || yandexLogin) return [ yandexUid, yandexLogin ].filter(Boolean).join("_");
        return "zen-user";
    }
}, function(module, exports) {
    !function(window, undefined) {
        "use strict";
        var EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet";
        var util = {
            has: function(str1, str2) {
                return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
            },
            lowerize: function(str) {
                return str.toLowerCase();
            }
        };
        var mapper = {
            rgx: function() {
                for (var result, j, k, p, q, matches, match, i = 0, args = arguments; i < args.length; i += 2) {
                    var regex = args[i], props = args[i + 1];
                    if (typeof result === UNDEF_TYPE) {
                        result = {};
                        for (p in props) {
                            q = props[p];
                            if (typeof q === OBJ_TYPE) result[q[0]] = undefined; else result[q] = undefined;
                        }
                    }
                    for (j = k = 0; j < regex.length; j++) {
                        matches = regex[j].exec(this.getUA());
                        if (!!matches) {
                            for (p in props) {
                                match = matches[++k];
                                q = props[p];
                                if (typeof q === OBJ_TYPE && q.length > 0) {
                                    if (2 == q.length) if (typeof q[1] == FUNC_TYPE) result[q[0]] = q[1].call(this, match); else result[q[0]] = q[1]; else if (3 == q.length) if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) result[q[0]] = match ? q[1].call(this, match, q[2]) : undefined; else result[q[0]] = match ? match.replace(q[1], q[2]) : undefined; else if (4 == q.length) result[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                } else result[q] = match ? match : undefined;
                            }
                            break;
                        }
                    }
                    if (!!matches) break;
                }
                return result;
            },
            str: function(str, map) {
                for (var i in map) if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j in map[i]) if (util.has(map[i][j], str)) return i === UNKNOWN ? undefined : i;
                } else if (util.has(map[i], str)) return i === UNKNOWN ? undefined : i;
                return str;
            }
        };
        var maps = {
            browser: {
                oldsafari: {
                    major: {
                        "1": [ "/8", "/1", "/3" ],
                        "2": "/4",
                        "?": "/"
                    },
                    version: {
                        "1.0": "/8",
                        "1.2": "/1",
                        "1.3": "/3",
                        "2.0": "/412",
                        "2.0.2": "/416",
                        "2.0.3": "/417",
                        "2.0.4": "/419",
                        "?": "/"
                    }
                }
            },
            device: {
                sprint: {
                    model: {
                        "Evo Shift 4G": "7373KT"
                    },
                    vendor: {
                        HTC: "APA",
                        Sprint: "Sprint"
                    }
                }
            },
            os: {
                windows: {
                    version: {
                        ME: "4.90",
                        "NT 3.11": "NT3.51",
                        "NT 4.0": "NT4.0",
                        "2000": "NT 5.0",
                        XP: [ "NT 5.1", "NT 5.2" ],
                        Vista: "NT 6.0",
                        "7": "NT 6.1",
                        "8": "NT 6.2",
                        RT: "ARM"
                    }
                }
            }
        };
        var regexes = {
            browser: [ [ /(opera\smini)\/((\d+)?[\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/((\d+)?[\w\.-]+)/i, /(opera).+version\/((\d+)?[\w\.]+)/i, /(opera)[\/\s]+((\d+)?[\w\.]+)/i ], [ NAME, VERSION, MAJOR ], [ /\s(opr)\/((\d+)?[\w\.]+)/i ], [ [ NAME, "Opera" ], VERSION, MAJOR ], [ /(kindle)\/((\d+)?[\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?((\d+)?[\w\.]+)*/i, /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?((\d+)?[\w\.]*)/i, /(?:ms|\()(ie)\s((\d+)?[\w\.]+)/i, /(rekonq)((?:\/)[\w\.]+)*/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt)\/((\d+)?[\w\.-]+)/i ], [ NAME, VERSION, MAJOR ], [ /(yabrowser)\/((\d+)?[\w\.]+)/i ], [ [ NAME, "Yandex" ], VERSION, MAJOR ], [ /(comodo_dragon)\/((\d+)?[\w\.]+)/i ], [ [ NAME, /_/g, " " ], VERSION, MAJOR ], [ /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?((\d+)?[\w\.]+)/i ], [ NAME, VERSION, MAJOR ], [ /(dolfin)\/((\d+)?[\w\.]+)/i ], [ [ NAME, "Dolphin" ], VERSION, MAJOR ], [ /((?:android.+)crmo|crios)\/((\d+)?[\w\.]+)/i ], [ [ NAME, "Chrome" ], VERSION, MAJOR ], [ /version\/((\d+)?[\w\.]+).+?mobile\/\w+\s(safari)/i ], [ VERSION, MAJOR, [ NAME, "Mobile Safari" ] ], [ /version\/((\d+)?[\w\.]+).+?(mobile\s?safari|safari)/i ], [ VERSION, MAJOR, NAME ], [ /webkit.+?(mobile\s?safari|safari)((\/[\w\.]+))/i ], [ NAME, [ MAJOR, mapper.str, maps.browser.oldsafari.major ], [ VERSION, mapper.str, maps.browser.oldsafari.version ] ], [ /(konqueror)\/((\d+)?[\w\.]+)/i, /(webkit|khtml)\/((\d+)?[\w\.]+)/i ], [ NAME, VERSION, MAJOR ], [ /(navigator|netscape)\/((\d+)?[\w\.-]+)/i ], [ [ NAME, "Netscape" ], VERSION, MAJOR ], [ /(swiftfox)/i, /(iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?((\d+)?[\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/((\d+)?[\w\.-]+)/i, /(mozilla)\/((\d+)?[\w\.]+).+rv\:.+gecko\/\d+/i, /(uc\s?browser|polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf)[\/\s]?((\d+)?[\w\.]+)/i, /(links)\s\(((\d+)?[\w\.]+)/i, /(gobrowser)\/?((\d+)?[\w\.]+)*/i, /(ice\s?browser)\/v?((\d+)?[\w\._]+)/i, /(mosaic)[\/\s]((\d+)?[\w\.]+)/i ], [ NAME, VERSION, MAJOR ] ],
            cpu: [ [ /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i ], [ [ ARCHITECTURE, "amd64" ] ], [ /((?:i[346]|x)86)[;\)]/i ], [ [ ARCHITECTURE, "ia32" ] ], [ /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i ], [ [ ARCHITECTURE, /ower/, "", util.lowerize ] ], [ /(sun4\w)[;\)]/i ], [ [ ARCHITECTURE, "sparc" ] ], [ /(ia64(?=;)|68k(?=\))|arm(?=v\d+;)|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i ], [ ARCHITECTURE, util.lowerize ] ],
            device: [ [ /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i ], [ MODEL, VENDOR, [ TYPE, TABLET ] ], [ /(hp).+(touchpad)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i ], [ VENDOR, MODEL, [ TYPE, TABLET ] ], [ /\((ip[honed]+);.+(apple)/i ], [ MODEL, VENDOR, [ TYPE, MOBILE ] ], [ /(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|huawei|meizu|motorola)[\s_-]?([\w-]+)*/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i ], [ VENDOR, MODEL, [ TYPE, MOBILE ] ], [ /\((bb10);\s(\w+)/i ], [ [ VENDOR, "BlackBerry" ], MODEL, [ TYPE, MOBILE ] ], [ /android.+((transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+))/i ], [ [ VENDOR, "Asus" ], MODEL, [ TYPE, TABLET ] ], [ /(sony)\s(tablet\s[ps])/i ], [ VENDOR, MODEL, [ TYPE, TABLET ] ], [ /(nintendo)\s([wids3u]+)/i ], [ VENDOR, MODEL, [ TYPE, CONSOLE ] ], [ /((playstation)\s[3portablevi]+)/i ], [ [ VENDOR, "Sony" ], MODEL, [ TYPE, CONSOLE ] ], [ /(sprint\s(\w+))/i ], [ [ VENDOR, mapper.str, maps.device.sprint.vendor ], [ MODEL, mapper.str, maps.device.sprint.model ], [ TYPE, MOBILE ] ], [ /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i, /(zte)-(\w+)*/i, /(alcatel|geeksphone|huawei|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i ], [ VENDOR, [ MODEL, /_/g, " " ], [ TYPE, MOBILE ] ], [ /\s((milestone|droid[2x]?))[globa\s]*\sbuild\//i, /(mot)[\s-]?(\w+)*/i ], [ [ VENDOR, "Motorola" ], MODEL, [ TYPE, MOBILE ] ], [ /android.+\s((mz60\d|xoom[\s2]{0,2}))\sbuild\//i ], [ [ VENDOR, "Motorola" ], MODEL, [ TYPE, TABLET ] ], [ /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n8000|sgh-t8[56]9))/i ], [ [ VENDOR, "Samsung" ], MODEL, [ TYPE, TABLET ] ], [ /((s[cgp]h-\w+|gt-\w+|galaxy\snexus))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i, /sec-((sgh\w+))/i ], [ [ VENDOR, "Samsung" ], MODEL, [ TYPE, MOBILE ] ], [ /(sie)-(\w+)*/i ], [ [ VENDOR, "Siemens" ], MODEL, [ TYPE, MOBILE ] ], [ /(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]+)*/i ], [ [ VENDOR, "Nokia" ], MODEL, [ TYPE, MOBILE ] ], [ /android\s3\.[\s\w-;]{10}((a\d{3}))/i ], [ [ VENDOR, "Acer" ], MODEL, [ TYPE, TABLET ] ], [ /android\s3\.[\s\w-;]{10}(lg?)-([06cv9]{3,4})/i ], [ [ VENDOR, "LG" ], MODEL, [ TYPE, TABLET ] ], [ /((nexus\s4))/i, /(lg)[e;\s-\/]+(\w+)*/i ], [ [ VENDOR, "LG" ], MODEL, [ TYPE, MOBILE ] ], [ /(mobile|tablet);.+rv\:.+gecko\//i ], [ TYPE, VENDOR, MODEL ] ],
            engine: [ [ /(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i ], [ NAME, VERSION ], [ /rv\:([\w\.]+).*(gecko)/i ], [ VERSION, NAME ] ],
            os: [ [ /(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*|windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i ], [ NAME, [ VERSION, mapper.str, maps.os.windows.version ] ], [ /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i ], [ [ NAME, "Windows" ], [ VERSION, mapper.str, maps.os.windows.version ] ], [ /\((bb)(10);/i ], [ [ NAME, "BlackBerry" ], VERSION ], [ /(blackberry)\w*\/?([\w\.]+)*/i, /(tizen)\/([\w\.]+)/i, /(android|webos|palm\os|qnx|bada|rim\stablet\sos|meego)[\/\s-]?([\w\.]+)*/i ], [ NAME, VERSION ], [ /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i ], [ [ NAME, "Symbian" ], VERSION ], [ /mozilla.+\(mobile;.+gecko.+firefox/i ], [ [ NAME, "Firefox OS" ], VERSION ], [ /(nintendo|playstation)\s([wids3portablevu]+)/i, /(mint)[\/\s\(]?(\w+)*/i, /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk)[\/\s-]?([\w\.-]+)*/i, /(hurd|linux)\s?([\w\.]+)*/i, /(gnu)\s?([\w\.]+)*/i ], [ NAME, VERSION ], [ /(cros)\s[\w]+\s([\w\.]+\w)/i ], [ [ NAME, "Chromium OS" ], VERSION ], [ /(sunos)\s?([\w\.]+\d)*/i ], [ [ NAME, "Solaris" ], VERSION ], [ /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i ], [ NAME, VERSION ], [ /(ip[honead]+)(?:.*os\s*([\w]+)*\slike\smac|;\sopera)/i ], [ [ NAME, "iOS" ], [ VERSION, /_/g, "." ] ], [ /(mac\sos\sx)\s?([\w\s\.]+\w)*/i ], [ NAME, [ VERSION, /_/g, "." ] ], [ /(haiku)\s(\w+)/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i, /(macintosh|mac(?=_powerpc)|plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos)/i, /(unix)\s?([\w\.]+)*/i ], [ NAME, VERSION ] ]
        };
        var UAParser = function UAParser(uastring) {
            if (!(this instanceof UAParser)) return new UAParser(uastring).getResult();
            var ua = uastring || (window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : EMPTY);
            if (!(this instanceof UAParser)) return new UAParser(uastring).getResult();
            this.getBrowser = function() {
                return mapper.rgx.apply(this, regexes.browser);
            };
            this.getCPU = function() {
                return mapper.rgx.apply(this, regexes.cpu);
            };
            this.getDevice = function() {
                return mapper.rgx.apply(this, regexes.device);
            };
            this.getEngine = function() {
                return mapper.rgx.apply(this, regexes.engine);
            };
            this.getOS = function() {
                return mapper.rgx.apply(this, regexes.os);
            };
            this.getResult = function() {
                return {
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                };
            };
            this.getUA = function() {
                return ua;
            };
            this.setUA = function(uastring) {
                ua = uastring;
                return this;
            };
            this.setUA(ua);
        };
        module.exports = UAParser;
    }(this);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var buildData = __webpack_require__(218);
    var logger = __webpack_require__(5).create("Frontend/init-checker");
    var clicker = __webpack_require__(438);
    var FRONTEND_LOADING_TIMEOUT_MS = 3e3;
    var frontends = new Map();
    exports.started = function(tabId) {
        getAndClearExistingItem(tabId);
        var item = {
            tabId: tabId,
            startTime: performance.now(),
            timer: setTimeout(timeoutElapsed.bind(null, tabId), FRONTEND_LOADING_TIMEOUT_MS)
        };
        frontends.set(tabId, item);
    };
    exports.loaded = function(tabId) {
        var item = getAndClearExistingItem(tabId);
        if (item && !buildData.git.release) {
            var loadingTime = performance.now() - item.startTime;
            logger.info("Frontend loading time in tab %i: %i ms", tabId, loadingTime);
        }
    };
    function timeoutElapsed(tabId) {
        var item = getAndClearExistingItem(tabId);
        if (item) {
            logger.error("Frontend loading in tab %i takes more than %i ms", tabId, FRONTEND_LOADING_TIMEOUT_MS);
            clicker.send({
                path: "system.frontdisplayfail"
            });
        }
    }
    function getAndClearExistingItem(tabId) {
        var item = frontends.get(tabId);
        if (item) {
            clearTimeout(item.timer);
            frontends.delete(tabId);
        }
        return item;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var urlUtils = __webpack_require__(83);
    var channel = __webpack_require__(27);
    var URLS = [ {
        domainRegExp: /element\.yandex\.(ru|ua|by|kz|com\.tr)/,
        path: "/vb/guide"
    } ];
    var ACTION_PARAM = "action";
    exports.start = function(navigationChannel) {
        navigationChannel.addListener(handleNavigationEvent);
    };
    exports.stop = function(navigationChannel) {
        navigationChannel.removeListener(handleNavigationEvent);
    };
    exports.onAction = channel.create();
    function handleNavigationEvent(tabId, tab) {
        if (tab && tab.data && tab.data.url && isGuideUrl(tab.data.url)) processNavigation(tab.data.url);
    }
    function isGuideUrl(url) {
        return URLS.some(function(urlData) {
            var domain = urlUtils.getNormalDomain(url);
            var path = urlUtils.getNormalPath(url);
            return urlData.path === path && urlData.domainRegExp.test(domain);
        });
    }
    function processNavigation(url) {
        var query = urlUtils.getQueryObject(url);
        var action = query[ACTION_PARAM];
        if (action) exports.onAction.dispatch({
            action: action
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var tabsWatcher = __webpack_require__(309);
    var actionWatcher = __webpack_require__(498);
    var logger = __webpack_require__(5).create("guide");
    var platformAbout = __webpack_require__(23);
    var ACTION_METHODS = Object.create(null);
    ACTION_METHODS.yes = openNewVisualBookmarksTab;
    exports.init = function() {
        actionWatcher.onAction.addListener(handleActionEvent);
        actionWatcher.start(tabsWatcher.events.onUpdated);
    };
    function handleActionEvent(event) {
        logger.info('"%s" action has been received', event.action);
        var method = ACTION_METHODS[event.action];
        if (method) {
            logger.info('Call method for "%s" action', event.action);
            method();
        }
    }
    function openNewVisualBookmarksTab() {
        chrome.tabs.create({
            url: platformAbout.visbookmarksUrl
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Channel = __webpack_require__(27);
    var REQUIRED_HOST_PERMISSIONS = [ "<all_urls>", "http://*/*", "https://*/*" ];
    exports.onRestrictedByUser = new Channel();
    exports.init = function() {
        if (!chrome.permissions.onRemoved) return;
        chrome.permissions.onRemoved.addListener(handlePermissionsRemoved);
    };
    function handlePermissionsRemoved(permissions) {
        var isRestricted = permissions.origins.some(function(origin) {
            return REQUIRED_HOST_PERMISSIONS.indexOf(origin) >= 0;
        });
        if (isRestricted) exports.onRestrictedByUser.dispatch();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var assign = __webpack_require__(93);
    var hostPermissions = __webpack_require__(500);
    var branding = __webpack_require__(277);
    var NOTICATION_OPTIONS = {
        type: "basic",
        iconUrl: "/icons/128.png"
    };
    exports.init = function() {
        hostPermissions.onRestrictedByUser.addListener(function() {
            chrome.notifications.create(getNotificationOptions());
        });
    };
    function getNotificationOptions() {
        return assign({
            title: branding.info.productName,
            message: chrome.i18n.getMessage("host_permissions_notification")
        }, NOTICATION_OPTIONS);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var parallel = __webpack_require__(209).parallel;
    var series = __webpack_require__(209).series;
    var flatten = __webpack_require__(475);
    var logger = __webpack_require__(5).create("Maintenance");
    var alarms = __webpack_require__(3);
    var fs = __webpack_require__(264);
    var fileUtils = __webpack_require__(266);
    var collection = __webpack_require__(270);
    var screenshots = __webpack_require__(350);
    var cloudLogo = __webpack_require__(274);
    var titleLoader = __webpack_require__(272);
    var faviconLoader = __webpack_require__(222);
    var tableauLoader = __webpack_require__(273);
    var customLogo = __webpack_require__(452);
    var ALARM = {
        name: "maintenance",
        periodInMinutes: 2 * 24 * 60
    };
    var DIRS = [ __webpack_require__(350).SCREENSHOT_DIR, __webpack_require__(275).CLOUD_LOGO_DIR, __webpack_require__(275).CLOUD_LOGO_SUB_DIR, tableauLoader.TABLEAU_DIR, faviconLoader.FAVICON_DIR, __webpack_require__(453).CUSTOM_LOGO_DIR ];
    exports.init = function() {
        alarms.register(ALARM, exports.run);
    };
    exports.run = function(callback) {
        parallel(DIRS.map(function(dir) {
            return getFileList.bind(null, dir);
        }), function(_error, allFiles) {
            clearCaches();
            deleteUnusedFiles(flatten(allFiles), callback);
        });
    };
    function clearCaches() {
        logger.info("Clear caches");
        screenshots.clearCache();
        cloudLogo.clearExpired();
        titleLoader.clearExpired();
        faviconLoader.clearExpired();
        tableauLoader.clearExpired();
    }
    function getFileList(folder, callback) {
        fs.list(fileUtils.wrapSeparator(folder), function(error, files) {
            if (error) logger.error("Error while listing files in folder: %s, error: %j", folder, error);
            callback(null, files || []);
        });
    }
    function deleteUnusedFiles(allFiles, callback) {
        var filesInUse = getFilesInUse();
        logger.info("Going to delete unused files");
        logger.info("All files: %j", allFiles);
        logger.info("Files in use: %j", filesInUse);
        var deleteTasks = createDeleteTasks(filesInUse, allFiles);
        series(deleteTasks, callback);
    }
    function createDeleteTasks(filesInUse, allFiles) {
        return allFiles.reduce(function(deleteTasks, path) {
            var normalizedPath = fileUtils.normalizePath(path);
            if (filesInUse.indexOf(normalizedPath) === -1) deleteTasks.push(deleteFile.bind(null, path));
            return deleteTasks;
        }, []);
    }
    function getFilesInUse() {
        return getThumbsFilesInUse().concat(getCustomLogoFilesInUse()).filter(Boolean).map(fileUtils.normalizePath);
    }
    function getCustomLogoFilesInUse() {
        return customLogo.getAll().reduce(function(filesInUse, customLogo) {
            var tillTimestamp = new Date(customLogo.till).setHours(23, 59, 59, 999);
            if (tillTimestamp >= Date.now()) return filesInUse.concat([ customLogo.localPath ]);
            return filesInUse;
        }, []);
    }
    function getThumbsFilesInUse() {
        return collection.items.reduce(function(filesInUse, thumb) {
            return filesInUse.concat([ thumb.cloudImageFsPath, thumb.cloudImageSubFsPath, thumb.tableauFsPath, thumb.faviconFsPath, thumb.screenshotFsPath ]);
        }, []);
    }
    function deleteFile(path, callback) {
        logger.info("Delete file: %s", path);
        fs.remove(path, function(error) {
            if (error) logger.error("Error while deleting file: %s, error: %j", path, error);
            callback();
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("migration-2.26.0");
    exports.VERSION = "2.26.0";
    exports.run = function(options, callback) {
        logger.info("Starting...");
        var settingsToRemove = [ "settings.logLevelConsole", "settings.logLevelFile", "settings.experimentConfigs", "settings.advertisementConfig", "settings.showStatModal" ];
        try {
            chrome.storage.local.remove(settingsToRemove, handleRemoveEvent.bind(null, callback));
        } catch (e) {
            logger.error("Problem with chrome.storage.local api: %o", e);
            callback();
        }
    };
    function handleRemoveEvent(callback) {
        if (chrome.runtime.lastError) logger.error("runtime.lastError in handleRemoveEvent: %o", chrome.runtime.lastError); else logger.info("Settings have been removed");
        callback();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.VERSION = "2.27.0";
    var logger = __webpack_require__(5).create("Migration " + exports.VERSION);
    var settings = __webpack_require__(216);
    var bgSelector = __webpack_require__(384);
    exports.run = function(options, callback) {
        logger.info("Starting...");
        updateBackgroundImagePath();
        callback();
    };
    function updateBackgroundImagePath() {
        var path = settings.get("backgroundImagePath");
        if (isBrandingPath(path)) {
            logger.info("Replace background branded path %s to local path", path);
            var id = settings.get("backgroundImage");
            bgSelector.selectBackground(id);
        }
    }
    function isBrandingPath(path) {
        return path && 0 === path.indexOf("chrome-extension://");
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.VERSION = "2.28.0";
    var logger = __webpack_require__(5).create("Migration " + exports.VERSION);
    var cloudBackgrounds = __webpack_require__(382);
    var fontColors = __webpack_require__(355);
    exports.run = function(options, callback) {
        logger.info("Starting...");
        updateBgFontColors();
        callback();
    };
    function updateBgFontColors() {
        var fontColorsMap = fontColors.getAll();
        var cloud = cloudBackgrounds.getBackgrounds();
        var hasChanges = false;
        Object.keys(fontColorsMap).forEach(function(bgId) {
            if (cloud[bgId] && cloud[bgId].color !== fontColorsMap[bgId]) {
                logger.info("Update cached font color for bg: %s %s --> %s", bgId, fontColorsMap[bgId], cloud[bgId].color);
                fontColorsMap[bgId] = cloud[bgId].color;
                hasChanges = true;
            }
        });
        if (hasChanges) fontColors.setAll(fontColorsMap);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var asyncLib = __webpack_require__(209);
    var utils = __webpack_require__(30);
    var logger = __webpack_require__(5).create("Migration");
    var migrations = [ __webpack_require__(348), __webpack_require__(503), __webpack_require__(504), __webpack_require__(505) ];
    module.exports = {
        run: function(options, callback) {
            var actualMigrations = migrations.filter(function(migration) {
                return utils.versionCompare(migration.VERSION, options.previousVersion, {
                    zeroExtend: true
                }) > 0 && utils.versionCompare(migration.VERSION, options.currentVersion, {
                    zeroExtend: true
                }) <= 0;
            });
            var tasks = actualMigrations.map(function(migration) {
                return function(callback) {
                    migration.run(options, callback);
                };
            });
            asyncLib.series(tasks, function(err) {
                logger.info("All migrations passed");
                callback(err);
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var colorUtils = __webpack_require__(259);
    var events = __webpack_require__(69);
    var ColorsHandler = function() {
        function ColorsHandler() {
            _classCallCheck(this, ColorsHandler);
        }
        _createClass(ColorsHandler, [ {
            key: "_calculateDominantColorByUrl",
            value: function(_ref) {
                var imgUrl = _ref.imgUrl, options = _ref.options, sendResponse = _ref.sendResponse;
                colorUtils.calculateDominantColorByUrlOriginal(imgUrl, options, function(color) {
                    sendResponse({
                        color: color
                    });
                });
            }
        }, {
            key: "_calculateFontColorByUrl",
            value: function(_ref2) {
                var imgUrl = _ref2.imgUrl, sendResponse = _ref2.sendResponse;
                colorUtils.calculateFontColorByUrlOriginal(imgUrl, function(color) {
                    sendResponse({
                        color: color
                    });
                });
            }
        }, {
            key: "handle",
            value: function(req, _sender) {
                switch (req.type) {
                  case events.backend.COLORS_DOMINANT_COLOR_BY_URL:
                    this._calculateDominantColorByUrl(req.data);
                    break;

                  case events.backend.COLORS_FONT_COLOR_BY_URL:
                    this._calculateFontColorByUrl(req.data);
                    break;

                  default:
                    return;
                }
                return true;
            }
        } ]);
        return ColorsHandler;
    }();
    module.exports = new ColorsHandler();
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Filer = __webpack_require__(509);
    var events = __webpack_require__(69);
    var DATA_URI_REG_EXP = /^data:/;
    var FilerHandler = function() {
        function FilerHandler() {
            _classCallCheck(this, FilerHandler);
            this.filer = new Filer();
        }
        _createClass(FilerHandler, [ {
            key: "_isDataUri",
            value: function(url) {
                return "string" === typeof url && DATA_URI_REG_EXP.test(url);
            }
        }, {
            key: "_getErrorHandler",
            value: function(sendResponse) {
                return function(err) {
                    sendResponse({
                        errObj: {
                            name: err.name,
                            message: err.message
                        }
                    });
                };
            }
        }, {
            key: "_init",
            value: function(_ref) {
                var opt_initObj = _ref.opt_initObj, sendResponse = _ref.sendResponse;
                this.filer.init(opt_initObj, function() {
                    sendResponse({});
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_ls",
            value: function(_ref2) {
                var dirEntryOrPath = _ref2.dirEntryOrPath, sendResponse = _ref2.sendResponse;
                this.filer.ls(dirEntryOrPath, function(entries) {
                    sendResponse({
                        entries: entries.map(function(entry) {
                            return {
                                fullPath: entry.fullPath,
                                name: entry.name
                            };
                        })
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_mkdir",
            value: function(_ref3) {
                var path = _ref3.path, opt_exclusive = _ref3.opt_exclusive, sendResponse = _ref3.sendResponse;
                this.filer.mkdir(path, opt_exclusive, function(entry) {
                    sendResponse({
                        entry: {
                            fullPath: entry.fullPath,
                            name: entry.name
                        }
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_open",
            value: function(_ref4) {
                var entryOrPath = _ref4.entryOrPath, sendResponse = _ref4.sendResponse;
                this.filer.open(entryOrPath, function(file) {
                    sendResponse({
                        file: Filer.fileToObjectURL(file)
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_pathToFilesystemURL",
            value: function(_ref5) {
                var path = _ref5.path, sendResponse = _ref5.sendResponse;
                this.filer.pathToFilesystemURL(path, function(path) {
                    sendResponse({
                        path: path
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_create",
            value: function(_ref6) {
                var path = _ref6.path, opt_exclusive = _ref6.opt_exclusive, sendResponse = _ref6.sendResponse;
                this.filer.create(path, opt_exclusive, function() {
                    sendResponse({});
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_mv",
            value: function(_ref7) {
                var src = _ref7.src, dest = _ref7.dest, opt_newName = _ref7.opt_newName, sendResponse = _ref7.sendResponse;
                this.filer.mv(src, dest, opt_newName, function(entry) {
                    sendResponse({
                        entry: {
                            fullPath: entry.fullPath,
                            name: entry.name
                        }
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_rm",
            value: function(_ref8) {
                var entryOrPath = _ref8.entryOrPath, sendResponse = _ref8.sendResponse;
                this.filer.rm(entryOrPath, function() {
                    sendResponse({});
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_cd",
            value: function(_ref9) {
                var dirEntryOrPath = _ref9.dirEntryOrPath, sendResponse = _ref9.sendResponse;
                this.filer.cd(dirEntryOrPath, function(entry) {
                    sendResponse({
                        entry: {
                            fullPath: entry.fullPath,
                            name: entry.name
                        }
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_cp",
            value: function(_ref10) {
                var src = _ref10.src, dest = _ref10.dest, opt_newName = _ref10.opt_newName, sendResponse = _ref10.sendResponse;
                this.filer.cp(src, dest, opt_newName, function(entry) {
                    sendResponse({
                        entry: {
                            fullPath: entry.fullPath,
                            name: entry.name
                        }
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_write",
            value: function(_ref11) {
                var entryOrPath = _ref11.entryOrPath, writeData = _ref11.writeData, sendResponse = _ref11.sendResponse;
                if (this._isDataUri(writeData)) writeData = Filer.dataURLToBlob(writeData);
                this.filer.write(entryOrPath, writeData, function(entry) {
                    sendResponse({
                        entry: {
                            name: entry.name,
                            path: entry.fullPath
                        }
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_df",
            value: function(_ref12) {
                var sendResponse = _ref12.sendResponse;
                this.filer.df(function(byteUsed, byteLeft, byteCap) {
                    sendResponse({
                        data: {
                            byteUsed: byteUsed,
                            byteLeft: byteLeft,
                            byteCap: byteCap
                        }
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "_getEntry",
            value: function(_ref13) {
                var fileName = _ref13.fileName, sendResponse = _ref13.sendResponse;
                this.filer.getEntry(fileName, function(entry) {
                    sendResponse({
                        entry: entry.toURL()
                    });
                }, this._getErrorHandler(sendResponse));
            }
        }, {
            key: "handle",
            value: function(req, _sender) {
                var _this = this;
                if (!this.isFilerInitializing) this.isFilerInitializing = new Promise(function(resolve) {
                    _this.filer.init({
                        persistent: true,
                        size: 0
                    }, function() {
                        resolve();
                    });
                });
                var handler = null;
                switch (req.type) {
                  case events.backend.FILER_CD:
                    handler = this._cd;
                    break;

                  case events.backend.FILER_CP:
                    handler = this._cp;
                    break;

                  case events.backend.FILER_CREATE:
                    handler = this._create;
                    break;

                  case events.backend.FILER_DF:
                    handler = this._df;
                    break;

                  case events.backend.FILER_GET_ENTRY:
                    handler = this._getEntry;
                    break;

                  case events.backend.FILER_INIT:
                    handler = this._init;
                    break;

                  case events.backend.FILER_LS:
                    handler = this._ls;
                    break;

                  case events.backend.FILER_MKDIR:
                    handler = this._mkdir;
                    break;

                  case events.backend.FILER_MV:
                    handler = this._mv;
                    break;

                  case events.backend.FILER_OPEN:
                    handler = this._open;
                    break;

                  case events.backend.FILER_PATH_TO_FILESYSTEM_URL:
                    handler = this._pathToFilesystemURL;
                    break;

                  case events.backend.FILER_RM:
                    handler = this._rm;
                    break;

                  case events.backend.FILER_WRITE:
                    handler = this._write;
                    break;

                  default:
                    return;
                }
                handler = handler.bind(this);
                this.isFilerInitializing.then(function() {
                    handler(req.data);
                });
                return true;
            }
        } ]);
        return FilerHandler;
    }();
    module.exports = new FilerHandler();
}, function(module, exports) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var self = window;
    self.requestFileSystem = self.requestFileSystem || self.webkitRequestFileSystem;
    self.resolveLocalFileSystemURL = self.resolveLocalFileSystemURL || self.webkitResolveLocalFileSystemURL;
    navigator.temporaryStorage = navigator.temporaryStorage || navigator.webkitTemporaryStorage;
    navigator.persistentStorage = navigator.persistentStorage || navigator.webkitPersistentStorage;
    self.BlobBuilder = self.BlobBuilder || self.MozBlobBuilder || self.WebKitBlobBuilder;
    if (void 0 === self.FileError) {
        var FileError = function() {};
        FileError.prototype.prototype = Error.prototype;
    } else FileError = self.FileError;
    var Util = {
        toArray: function(list) {
            return Array.prototype.slice.call(list || [], 0);
        },
        strToDataURL: function(str, contentType, opt_isBinary) {
            var isBinary = void 0 != opt_isBinary ? opt_isBinary : true;
            if (isBinary) return "data:" + contentType + ";base64," + self.btoa(str); else return "data:" + contentType + "," + str;
        },
        strToObjectURL: function(binStr, opt_contentType) {
            var ui8a = new Uint8Array(binStr.length);
            for (var i = 0; i < ui8a.length; ++i) ui8a[i] = binStr.charCodeAt(i);
            var blob = new Blob([ ui8a ], opt_contentType ? {
                type: opt_contentType
            } : {});
            return self.URL.createObjectURL(blob);
        },
        fileToObjectURL: function(blob) {
            return self.URL.createObjectURL(blob);
        },
        fileToArrayBuffer: function(blob, callback, opt_errorCallback) {
            var reader = new FileReader();
            reader.onload = function(e) {
                callback(e.target.result);
            };
            reader.onerror = function(e) {
                if (opt_errorCallback) opt_errorCallback(e);
            };
            reader.readAsArrayBuffer(blob);
        },
        dataURLToBlob: function(dataURL) {
            var BASE64_MARKER = ";base64,";
            if (dataURL.indexOf(BASE64_MARKER) == -1) {
                var parts = dataURL.split(",");
                var contentType = parts[0].split(":")[1];
                var raw = decodeURIComponent(parts[1]);
                return new Blob([ raw ], {
                    type: contentType
                });
            }
            var parts = dataURL.split(BASE64_MARKER);
            var contentType = parts[0].split(":")[1];
            var raw = window.atob(parts[1]);
            var rawLength = raw.length;
            var uInt8Array = new Uint8Array(rawLength);
            for (var i = 0; i < rawLength; ++i) uInt8Array[i] = raw.charCodeAt(i);
            return new Blob([ uInt8Array ], {
                type: contentType
            });
        },
        arrayBufferToBlob: function(buffer, opt_contentType) {
            var uInt8Array = new Uint8Array(buffer);
            return new Blob([ uInt8Array ], opt_contentType ? {
                type: opt_contentType
            } : {});
        },
        arrayBufferToBinaryString: function(buffer, callback, opt_errorCallback) {
            var reader = new FileReader();
            reader.onload = function(e) {
                callback(e.target.result);
            };
            reader.onerror = function(e) {
                if (opt_errorCallback) opt_errorCallback(e);
            };
            var uInt8Array = new Uint8Array(buffer);
            reader.readAsBinaryString(new Blob([ uInt8Array ]));
        },
        arrayToBinaryString: function(bytes) {
            if (("undefined" === typeof bytes ? "undefined" : _typeof(bytes)) != _typeof([])) return null;
            var i = bytes.length;
            var bstr = new Array(i);
            while (i--) bstr[i] = String.fromCharCode(bytes[i]);
            return bstr.join("");
        },
        getFileExtension: function(filename) {
            var idx = filename.lastIndexOf(".");
            return idx != -1 ? filename.substring(idx) : "";
        }
    };
    var MyFileError = function(obj) {
        this.prototype = FileError.prototype;
        this.code = obj.code;
        this.name = obj.name;
    };
    FileError.BROWSER_NOT_SUPPORTED = 1e3;
    FileError.prototype.__defineGetter__("name", function() {
        var keys = Object.keys(FileError);
        for (var key, i = 0; key = keys[i]; ++i) if (FileError[key] == this.code) return key;
        return "Unknown Error";
    });
    var Filer = new function() {
        var FS_INIT_ERROR_MSG = "Filesystem has not been initialized.";
        var NOT_IMPLEMENTED_MSG = "Not implemented.";
        var NOT_A_DIRECTORY = "Path was not a directory.";
        var INCORRECT_ARGS = "These method arguments are not supported.";
        var FS_URL_SCHEME = "filesystem:";
        var DEFAULT_FS_SIZE = 1024 * 1024;
        var fs_ = null;
        var cwd_ = null;
        var isOpen_ = false;
        var isFsURL_ = function(path) {
            return 0 == path.indexOf(FS_URL_SCHEME);
        };
        var pathToFsURL_ = function(path) {
            if (!isFsURL_(path)) if ("/" == path[0]) path = fs_.root.toURL() + path.substring(1); else if (0 == path.indexOf("./") || 0 == path.indexOf("../")) if ("../" == path && cwd_ != fs_.root) path = cwd_.toURL() + "/" + path; else path = cwd_.toURL() + path; else path = cwd_.toURL() + "/" + path;
            return path;
        };
        var getEntry_ = function(srcStr, destStr, callback, errback) {
            var onError = function(e) {
                if (errback) errback(e);
            };
            var src = pathToFsURL_(srcStr);
            if (srcStr && destStr) {
                var dest = pathToFsURL_(destStr);
                self.resolveLocalFileSystemURL(src, function(srcEntry) {
                    self.resolveLocalFileSystemURL(dest, function(destEntry) {
                        callback(srcEntry, destEntry);
                    }, onError);
                }, onError);
            } else self.resolveLocalFileSystemURL(src, callback, onError);
        };
        var copyOrMove_ = function(src, dest, opt_newName, opt_successCallback, opt_errorHandler, opt_deleteOrig) {
            if (!fs_) throw new Error(FS_INIT_ERROR_MSG);
            if (("undefined" === typeof src ? "undefined" : _typeof(src)) != ("undefined" === typeof dest ? "undefined" : _typeof(dest))) throw new Error(INCORRECT_ARGS);
            var newName = opt_newName || null;
            var deleteOrig = void 0 != opt_deleteOrig ? opt_deleteOrig : false;
            if ((src.isFile || dest.isDirectory) && dest.isDirectory) if (deleteOrig) src.moveTo(dest, newName, opt_successCallback, opt_errorHandler); else src.copyTo(dest, newName, opt_successCallback, opt_errorHandler); else getEntry_(src, dest, function(srcEntry, destDir) {
                if (!destDir.isDirectory) {
                    var e = new Error('Oops! "' + destDir.name + " is not a directory!");
                    if (opt_errorHandler) opt_errorHandler(e); else throw e;
                    return;
                }
                if (deleteOrig) srcEntry.moveTo(destDir, newName, opt_successCallback, opt_errorHandler); else srcEntry.copyTo(destDir, newName, opt_successCallback, opt_errorHandler);
            }, opt_errorHandler);
        };
        function Filer(fs) {
            fs_ = fs || null;
            if (fs_) {
                cwd_ = fs_.root;
                isOpen_ = true;
            }
        }
        Filer.DEFAULT_FS_SIZE = DEFAULT_FS_SIZE;
        Filer.version = "0.4.3";
        Filer.prototype = {
            get fs() {
                return fs_;
            },
            get isOpen() {
                return isOpen_;
            },
            get cwd() {
                return cwd_;
            }
        };
        Filer.prototype.pathToFilesystemURL = function(path) {
            return pathToFsURL_(path);
        };
        Filer.prototype.init = function(opt_initObj, opt_successCallback, opt_errorHandler) {
            if (!self.requestFileSystem) throw new MyFileError({
                code: FileError.BROWSER_NOT_SUPPORTED,
                name: "BROWSER_NOT_SUPPORTED"
            });
            var initObj = opt_initObj ? opt_initObj : {};
            var size = initObj.size || DEFAULT_FS_SIZE;
            this.type = self.TEMPORARY;
            if ("persistent" in initObj && initObj.persistent) this.type = self.PERSISTENT;
            var init = function(fs) {
                this.size = size;
                fs_ = fs;
                cwd_ = fs_.root;
                isOpen_ = true;
                opt_successCallback && opt_successCallback(fs);
            };
            if (this.type == self.PERSISTENT && !!navigator.persistentStorage) navigator.persistentStorage.requestQuota(size, function(grantedBytes) {
                self.requestFileSystem(this.type, grantedBytes, init.bind(this), opt_errorHandler);
            }.bind(this), opt_errorHandler); else self.requestFileSystem(this.type, size, init.bind(this), opt_errorHandler);
        };
        Filer.prototype.ls = function(dirEntryOrPath, successCallback, opt_errorHandler) {
            if (!fs_) throw new Error(FS_INIT_ERROR_MSG);
            var callback = function(dirEntry) {
                var entries_ = [];
                var reader = dirEntry.createReader();
                var readEntries = function readEntries() {
                    reader.readEntries(function(results) {
                        if (!results.length) {
                            entries_.sort(function(a, b) {
                                return a.name < b.name ? -1 : b.name < a.name ? 1 : 0;
                            });
                            successCallback(entries_);
                        } else {
                            entries_ = entries_.concat(Util.toArray(results));
                            readEntries();
                        }
                    }, opt_errorHandler);
                };
                readEntries();
            };
            if (dirEntryOrPath.isDirectory) callback(dirEntryOrPath); else if (isFsURL_(dirEntryOrPath)) getEntry_(dirEntryOrPath, null, callback, opt_errorHandler); else cwd_.getDirectory(dirEntryOrPath, {}, callback, opt_errorHandler);
        };
        Filer.prototype.mkdir = function(path, opt_exclusive, opt_successCallback, opt_errorHandler) {
            if (!fs_) throw new Error(FS_INIT_ERROR_MSG);
            var exclusive = null != opt_exclusive ? opt_exclusive : false;
            var folderParts = path.split("/");
            var createDir = function createDir(rootDir, folders) {
                if ("." == folders[0] || "" == folders[0]) folders = folders.slice(1);
                rootDir.getDirectory(folders[0], {
                    create: true,
                    exclusive: exclusive
                }, function(dirEntry) {
                    if (dirEntry.isDirectory) {
                        if (folders.length && 1 != folderParts.length) createDir(dirEntry, folders.slice(1)); else if (opt_successCallback) opt_successCallback(dirEntry);
                    } else {
                        var e = new Error(path + " is not a directory");
                        if (opt_errorHandler) opt_errorHandler(e); else throw e;
                    }
                }, function(e) {
                    if (e.code == FileError.INVALID_MODIFICATION_ERR) {
                        e.message = "'" + path + "' already exists";
                        if (opt_errorHandler) opt_errorHandler(e); else throw e;
                    }
                });
            };
            createDir(cwd_, folderParts);
        };
        Filer.prototype.open = function(entryOrPath, successCallback, opt_errorHandler) {
            if (!fs_) throw new Error(FS_INIT_ERROR_MSG);
            if (entryOrPath.isFile) entryOrPath.file(successCallback, opt_errorHandler); else getEntry_(pathToFsURL_(entryOrPath), null, function(fileEntry) {
                fileEntry.file(successCallback, opt_errorHandler);
            }, opt_errorHandler);
        };
        Filer.prototype.create = function(path, opt_exclusive, successCallback, opt_errorHandler) {
            if (!fs_) throw new Error(FS_INIT_ERROR_MSG);
            var exclusive = null != opt_exclusive ? opt_exclusive : true;
            cwd_.getFile(path, {
                create: true,
                exclusive: exclusive
            }, successCallback, function(e) {
                if (e.code == FileError.INVALID_MODIFICATION_ERR) e.message = "'" + path + "' already exists";
                if (opt_errorHandler) opt_errorHandler(e); else throw e;
            });
        };
        Filer.prototype.mv = function(src, dest, opt_newName, opt_successCallback, opt_errorHandler) {
            copyOrMove_.bind(this, src, dest, opt_newName, opt_successCallback, opt_errorHandler, true)();
        };
        Filer.prototype.rm = function(entryOrPath, successCallback, opt_errorHandler) {
            if (!fs_) throw new Error(FS_INIT_ERROR_MSG);
            var removeIt = function(entry) {
                if (entry.isFile) entry.remove(successCallback, opt_errorHandler); else if (entry.isDirectory) entry.removeRecursively(successCallback, opt_errorHandler);
            };
            if (entryOrPath.isFile || entryOrPath.isDirectory) removeIt(entryOrPath); else getEntry_(entryOrPath, null, removeIt, opt_errorHandler);
        };
        Filer.prototype.cd = function(dirEntryOrPath, opt_successCallback, opt_errorHandler) {
            if (!fs_) throw new Error(FS_INIT_ERROR_MSG);
            if (dirEntryOrPath.isDirectory) {
                cwd_ = dirEntryOrPath;
                opt_successCallback && opt_successCallback(cwd_);
            } else {
                dirEntryOrPath = pathToFsURL_(dirEntryOrPath);
                getEntry_(dirEntryOrPath, null, function(dirEntry) {
                    if (dirEntry.isDirectory) {
                        cwd_ = dirEntry;
                        opt_successCallback && opt_successCallback(cwd_);
                    } else {
                        var e = new Error(NOT_A_DIRECTORY);
                        if (opt_errorHandler) opt_errorHandler(e); else throw e;
                    }
                }, opt_errorHandler);
            }
        };
        Filer.prototype.cp = function(src, dest, opt_newName, opt_successCallback, opt_errorHandler) {
            copyOrMove_.bind(this, src, dest, opt_newName, opt_successCallback, opt_errorHandler)();
        };
        Filer.prototype.write = function(entryOrPath, dataObj, opt_successCallback, opt_errorHandler) {
            if (!fs_) throw new Error(FS_INIT_ERROR_MSG);
            var writeFile_ = function(fileEntry) {
                fileEntry.createWriter(function(fileWriter) {
                    fileWriter.onerror = opt_errorHandler;
                    if (dataObj.append) {
                        fileWriter.onwriteend = function(e) {
                            if (opt_successCallback) opt_successCallback(fileEntry, this);
                        };
                        fileWriter.seek(fileWriter.length);
                    } else {
                        var truncated = false;
                        fileWriter.onwriteend = function(e) {
                            if (!truncated) {
                                truncated = true;
                                this.truncate(this.position);
                                return;
                            }
                            if (opt_successCallback) opt_successCallback(fileEntry, this);
                        };
                    }
                    if (dataObj instanceof Blob) fileWriter.write(dataObj); else {
                        if (dataObj.data.__proto__ == ArrayBuffer.prototype) dataObj.data = new Uint8Array(dataObj.data);
                        var blob = new Blob([ dataObj.data ], dataObj.type ? {
                            type: dataObj.type
                        } : {});
                        fileWriter.write(blob);
                    }
                }, opt_errorHandler);
            };
            if (entryOrPath.isFile) writeFile_(entryOrPath); else if (isFsURL_(entryOrPath)) getEntry_(entryOrPath, null, writeFile_, opt_errorHandler); else cwd_.getFile(entryOrPath, {
                create: true,
                exclusive: false
            }, writeFile_, opt_errorHandler);
        };
        Filer.prototype.df = function(successCallback, opt_errorHandler) {
            var queryCallback = function(byteUsed, byteCap) {
                successCallback(byteUsed, byteCap - byteUsed, byteCap);
            };
            if (!(navigator.temporaryStorage.queryUsageAndQuota && navigator.persistentStorage.queryUsageAndQuota)) throw new Error(NOT_IMPLEMENTED_MSG);
            if (self.TEMPORARY == this.type) navigator.temporaryStorage.queryUsageAndQuota(queryCallback, opt_errorHandler); else if (self.PERSISTENT == this.type) navigator.persistentStorage.queryUsageAndQuota(queryCallback, opt_errorHandler);
        };
        Filer.prototype.getEntry = function(fileName, callback, errback) {
            getEntry_(fileName, null, callback, errback);
        };
        return Filer;
    }();
    module.exports = Filer;
    module.exports.dataURLToBlob = Util.dataURLToBlob.bind({});
    module.exports.fileToObjectURL = Util.fileToObjectURL.bind({});
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var colorsHandler = __webpack_require__(507);
    var filerHandler = __webpack_require__(508);
    var speechkitHandler = __webpack_require__(511);
    var xmlHandler = __webpack_require__(513);
    var handlers = [ colorsHandler, filerHandler, speechkitHandler, xmlHandler ];
    var Messaging = function() {
        function Messaging() {
            _classCallCheck(this, Messaging);
        }
        _createClass(Messaging, [ {
            key: "init",
            value: function() {
                this._handleConnection = this._getConnectionHandler().bind(this);
                chrome.runtime.onConnect.addListener(this._handleConnection);
            }
        }, {
            key: "_getConnectionHandler",
            value: function() {
                return function(port) {
                    if ("offscreen" === port.name) port.onMessage.addListener(function(req) {
                        if (req.data) {
                            req.data.sendResponse = function(message) {
                                if ("object" === ("undefined" === typeof message ? "undefined" : _typeof(message))) message.id = req.id;
                                port.postMessage(message);
                            };
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = void 0;
                            try {
                                for (var _step, _iterator = handlers[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var handler = _step.value;
                                    if (handler.handle(req, port.sender)) return;
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
                                } finally {
                                    if (_didIteratorError) throw _iteratorError;
                                }
                            }
                        }
                    });
                };
            }
        } ]);
        return Messaging;
    }();
    module.exports = new Messaging();
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var speechkit = __webpack_require__(512).ya.speechkit;
    var _require = __webpack_require__(410), UTTERANCE_SILENCE = _require.UTTERANCE_SILENCE, API_KEY = _require.API_KEY;
    var events = __webpack_require__(69);
    var SpeechkitHandler = function() {
        function SpeechkitHandler() {
            _classCallCheck(this, SpeechkitHandler);
        }
        _createClass(SpeechkitHandler, [ {
            key: "_init",
            value: function(_ref) {
                var sendResponse = _ref.sendResponse;
                this.streamer = new speechkit.SpeechRecognition();
                this.streamer.start({
                    apiKey: API_KEY,
                    initCallback: function() {
                        return sendResponse({});
                    },
                    errorCallback: function(error) {
                        sendResponse({
                            type: events.offscreen.SPEECHKIT_ERROR,
                            data: {
                                reason: error.message
                            }
                        });
                    },
                    dataCallback: function(text, done) {
                        sendResponse({
                            type: events.offscreen.SPEECHKIT_DATA,
                            data: {
                                text: text,
                                done: done
                            }
                        });
                    },
                    utteranceSilence: UTTERANCE_SILENCE,
                    particialResults: true
                });
            }
        }, {
            key: "_stop",
            value: function(_ref2) {
                var sendResponse = _ref2.sendResponse;
                try {
                    if (this.streamer) this.streamer.stop();
                } catch (e) {} finally {
                    sendResponse({});
                }
            }
        }, {
            key: "handle",
            value: function(req, _sender) {
                switch (req.type) {
                  case events.backend.SPEECHKIT_INIT:
                    this._init(req.data);
                    break;

                  case events.backend.SPEECHKIT_STOP:
                    this._stop(req.data);
                    break;

                  default:
                    return;
                }
                return true;
            }
        } ]);
        return SpeechkitHandler;
    }();
    module.exports = new SpeechkitHandler();
}, function(module, exports) {
    var speechkitNamespace = {
        ya: {
            speechkit: {}
        }
    };
    !function(namespace) {
        "use strict";
        namespace.ya.speechkit.AudioContext = window.AudioContext || window.webkitAudioContext;
        namespace.ya.speechkit.FORMAT = {
            PCM8: {
                format: "pcm",
                sampleRate: 8e3,
                mime: "audio/x-pcm;bit=16;rate=8000",
                bufferSize: 1024
            },
            PCM16: {
                format: "pcm",
                sampleRate: 16e3,
                mime: "audio/x-pcm;bit=16;rate=16000",
                bufferSize: 2048
            },
            PCM44: {
                format: "pcm",
                sampleRate: 44100,
                mime: "audio/x-pcm;bit=16;rate=44100",
                bufferSize: 4096
            }
        };
        namespace.ya.speechkit._stream = null;
        namespace.ya.speechkit._extend = function(to, from) {
            var i;
            var toStr = Object.prototype.toString;
            var astr = "[object Array]";
            to = to || {};
            for (i in from) if (from.hasOwnProperty(i)) if ("object" === typeof from[i]) {
                to[i] = toStr.call(from[i]) === astr ? [] : {};
                namespace.ya.speechkit._extend(to[i], from[i]);
            } else if ("undefined" !== typeof from[i] || "undefined" === typeof to[i]) to[i] = from[i];
            return to;
        };
        var Recorder = function() {
            if (!namespace.ya.speechkit._stream) return null;
            if (!(this instanceof Recorder)) return new Recorder();
            this.worker = namespace.ya.speechkit.newWorker();
            this.recording = false;
            this.paused = false;
            this.lastDataOnPause = 0;
            this.nullsArray = [];
            this.currCallback = null;
            this.buffCallback = null;
            this.startCallback = null;
            this.worker.onmessage = function(e) {
                if ("int16stream" == e.data.command) {
                    var data = e.data.buffer;
                    if (this.startCallback) this.startCallback(data);
                } else if ("getBuffers" == e.data.command && this.buffCallback) this.buffCallback(e.data.blob); else if ("clear" == e.data.command && this.currCallback) this.currCallback(); else if (this.currCallback) this.currCallback(e.data.blob);
            }.bind(this);
        };
        Recorder.prototype = {
            _createNode: function(format) {
                if (!namespace.ya.speechkit.audiocontext) namespace.ya.speechkit.audiocontext = new namespace.ya.speechkit.AudioContext();
                this.audioInput = namespace.ya.speechkit.audiocontext.createMediaStreamSource(namespace.ya.speechkit._stream);
                if (!namespace.ya.speechkit.audiocontext.createScriptProcessor) this.node = namespace.ya.speechkit.audiocontext.createJavaScriptNode(format.bufferSize, 2, 2); else this.node = namespace.ya.speechkit.audiocontext.createScriptProcessor(format.bufferSize, 2, 2);
                this.audioInput.connect(this.node);
                this.node.onaudioprocess = function(e) {
                    if (!this.recording) return;
                    if (this.paused) {
                        if (Number(new Date()) - this.lastDataOnPause > 2e3) {
                            this.lastDataOnPause = Number(new Date());
                            this.worker.postMessage({
                                command: "record",
                                buffer: [ this.nullsArray, this.nullsArray ]
                            });
                        }
                    } else this.worker.postMessage({
                        command: "record",
                        buffer: [ e.inputBuffer.getChannelData(0), e.inputBuffer.getChannelData(1) ]
                    });
                }.bind(this);
                this.node.connect(namespace.ya.speechkit.audiocontext.destination);
            },
            pause: function() {
                this.paused = true;
                this.lastDataOnPause = Number(new Date());
            },
            getAudioContext: function() {
                return namespace.ya.speechkit.audiocontext;
            },
            getAnalyserNode: function() {
                if (!namespace.ya.speechkit.audiocontext) namespace.ya.speechkit.audiocontext = new namespace.ya.speechkit.AudioContext();
                var analyserNode = namespace.ya.speechkit.audiocontext.createAnalyser();
                analyserNode.fftSize = 2048;
                this.audioInput.connect(analyserNode);
                return analyserNode;
            },
            isPaused: function() {
                return this.paused;
            },
            start: function(cb, format) {
                var backref = this;
                if (!namespace.ya.speechkit._stream) return namespace.ya.speechkit.initRecorder(function() {
                    backref.start(cb, format);
                }, console.log);
                if (!this.node) this._createNode(format);
                if (this.isPaused()) {
                    this.paused = false;
                    return;
                }
                if ("undefined" !== typeof cb) this.startCallback = cb; else this.startCallback = null;
                this.worker.postMessage({
                    command: "init",
                    config: {
                        sampleRate: namespace.ya.speechkit.audiocontext.sampleRate,
                        format: format || namespace.ya.speechkit.FORMAT.PCM16,
                        channels: this.channelCount
                    }
                });
                this.nullsArray = [];
                var bufferLen = (format || namespace.ya.speechkit.FORMAT.PCM16).bufferSize;
                for (var i = 0; i < bufferLen; i++) this.nullsArray.push(0);
                this.clear(function() {
                    this.recording = true;
                }.bind(this));
            },
            stop: function(cb, channelCount) {
                this.recording = false;
                if (this.node) this.node.disconnect();
                this.node = null;
                this.startCallback = null;
                if (namespace.ya.speechkit._stream && namespace.ya.speechkit._stream.getAudioTracks) namespace.ya.speechkit._stream.getAudioTracks()[0].stop(); else if (namespace.ya.speechkit._stream && "undefined" !== typeof namespace.ya.speechkit._stream.stop) namespace.ya.speechkit._stream.stop();
                namespace.ya.speechkit._stream = null;
                if ("undefined" !== typeof namespace.ya.speechkit.audiocontext && null !== namespace.ya.speechkit.audiocontext && "undefined" !== typeof namespace.ya.speechkit.audiocontext.close) {
                    namespace.ya.speechkit.audiocontext.close();
                    namespace.ya.speechkit.audiocontext = null;
                }
                if ("undefined" !== typeof cb) this.exportWav(function(blob) {
                    cb(blob);
                }, channelCount || 2);
            },
            isRecording: function() {
                return this.recording;
            },
            clear: function(cb) {
                if ("undefined" !== typeof cb) this.currCallback = cb; else this.currCallback = null;
                this.worker.postMessage({
                    command: "clear"
                });
            },
            getBuffers: function(cb) {
                if ("undefined" !== typeof cb) this.buffCallback = cb; else this.buffCallback = null;
                this.worker.postMessage({
                    command: "getBuffers"
                });
            },
            exportWav: function(cb, channelCount) {
                if ("undefined" !== typeof cb) this.currCallback = cb; else this.currCallback = null;
                var type = "audio/wav";
                if (!this.currCallback) throw new Error("Callback not set");
                var exportCommand = "export" + (2 != channelCount && "Mono" || "") + "WAV";
                this.worker.postMessage({
                    command: exportCommand,
                    type: type
                });
            }
        };
        namespace.ya.speechkit.Recorder = Recorder;
        namespace.ya.speechkit.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.webkitGetUserMedia;
        namespace.ya.speechkit.mediaDevices = navigator.mediaDevices && navigator.mediaDevices.getUserMedia ? navigator.mediaDevices : namespace.ya.speechkit.getUserMedia ? {
            getUserMedia: function(c) {
                return new Promise(function(y, n) {
                    namespace.ya.speechkit.getUserMedia.call(navigator, c, y, n);
                });
            }
        } : null;
        namespace.ya.speechkit._stream = null;
        namespace.ya.speechkit.audiocontext = null;
        namespace.ya.speechkit.initRecorder = function(initSuccess, initFail) {
            var badInitialization = function(err) {
                namespace.ya.speechkit._stream = null;
                if ("undefined" !== typeof initFail) initFail(err);
            };
            if (namespace.ya.speechkit.mediaDevices) namespace.ya.speechkit.mediaDevices.getUserMedia({
                audio: true
            }).then(function(stream) {
                namespace.ya.speechkit._stream = stream;
                if ("undefined" !== typeof initSuccess) initSuccess();
            }).catch(function(err) {
                badInitialization(err.message || err.name || err);
            }); else badInitialization("Your browser doesn't support Web Audio API. " + "Please, use Yandex.Browser: https://browser.yandex.ru");
        };
        namespace.ya.speechkit.isLanguageSupported = function(lang) {
            if (namespace.ya.speechkit.settings.langWhitelist.indexOf(lang) >= 0) return namespace.ya.speechkit.isSupported(); else return namespace.ya.speechkit.isWebAudioSupported();
        };
        namespace.ya.speechkit.isSupported = function() {
            var userAgent = navigator.userAgent.toLowerCase();
            return null !== namespace.ya.speechkit.mediaDevices && (/mozilla|firefox/.test(userAgent) && !/yabrowser/.test(userAgent) || !/iphone|ipod|ipad|android|blackberry/.test(userAgent));
        };
        namespace.ya.speechkit.isWebAudioSupported = function() {
            var userAgent = navigator.userAgent.toLowerCase();
            var SpeechRecognition = namespace.SpeechRecognition || namespace.webkitSpeechRecognition;
            return "undefined" !== typeof SpeechRecognition && !/yabrowser|opera|opr/.test(userAgent);
        };
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        function _makeWorker(script) {
            var URL = window.URL || window.webkitURL;
            var Blob = window.Blob;
            var Worker = window.Worker;
            if (!URL || !Blob || !Worker || !script) return null;
            var blob = new Blob([ script ], {
                type: "application/javascript"
            });
            var worker = new Worker(URL.createObjectURL(blob));
            return worker;
        }
        var inline_worker = "function iirFilter (sampleRate, cutoff, resonance, type) {" + "" + "    var\tself\t= this," + "            f\t= [0.0, 0.0, 0.0, 0.0]," + "            freq, damp," + "            prevCut, prevReso," + "            sin\t= Math.sin," + "            min\t= Math.min," + "            pow\t= Math.pow;" + "    self.cutoff = cutoff || 20000;" + "    self.resonance = resonance || 0.1;" + "    self.samplerate = sampleRate || 44100;" + "    self.type = type || 0;" + "    function calcCoeff () {" + "            freq = 2 * sin(Math.PI * min(0.25, self.cutoff / (self.samplerate * 2)));" + "            damp = min(2 * (1 - pow(self.resonance, 0.25)), min(2, 2 / freq - freq * 0.5));" + "    }" + "    self.pushSample = function (sample) {" + "            if (prevCut !== self.cutoff || prevReso !== self.resonance){" + "                    calcCoeff();" + "                    prevCut = self.cutoff;" + "                    prevReso = self.resonance;" + "            }" + "            f[3] = sample - damp * f[2];" + "            f[0] = f[0] + freq * f[2];" + "            f[1] = f[3] - f[0];" + "            f[2] = freq * f[1] + f[2];" + "            f[3] = sample - damp * f[2];" + "            f[0] = f[0] + freq * f[2];" + "            f[1] = f[3] - f[0];" + "            f[2] = freq * f[1] + f[2];" + "            return f[self.type];" + "    };" + "    self.getMix = function (type) {" + "            return f[type || self.type];" + "    };" + "}" + "var speex_loaded = false;" + "var recLength = 0;" + "var recBuffersL = [];" + "var recBuffersR = [];" + "var sampleRate;" + "var outSampleRate;" + "var tmp_buf = 0;" + "var need_buf_size = 4096;" + "var speex_converter = null;" + "    " + "this.onmessage = function (e) {" + "    switch (e.data.command) {" + "    case 'init':" + "        init(e.data.config);" + "        break;" + "    case 'record':" + "        record(e.data.buffer);" + "        break;" + "    case 'exportWAV':" + "        exportWAV(e.data.type);" + "        break;" + "    case 'exportMonoWAV':" + "        exportMonoWAV(e.data.type);" + "        break;" + "    case 'getBuffers':" + "        getBuffers();" + "        break;" + "    case 'clear':" + "        clear();" + "        break;" + "    }" + "};" + "    " + "function init(config) {" + "    sampleRate = config.sampleRate;" + "    outSampleRate = config.format.sampleRate || sampleRate;" + "    need_buf_size = config.format.bufferSize || 4096;" + "    speex_converter = null;" + "    /*if (config.format.format == 'speex') {" + "        if (!speex_loaded) {" + "            importScripts('./speex.min.js');" + "            speex_loaded = true;" + "        }" + "        need_buf_size /= 16;" + "        speex_converter = new SpeexConverter(outSampleRate);" + "    }*/" + "}" + "var resample = function (inbuf) {" + "    var speed = 1.0 * sampleRate / outSampleRate;" + "    var l = Math.ceil(inbuf.length / speed);" + "    var result = new Float32Array(l);" + "    var bin = 0;" + "    var num = 0;" + "    var indexIn = 0;" + "    var indexOut = 0;" + "    for (indexOut = 1, indexIn = speed; indexOut < l - 1; indexIn += speed, indexOut++) {" + "        var pos = Math.floor(indexIn);" + "        var dt = indexIn - pos;" + "        var second = (pos + 1 < inbuf.length) ? pos + 1 : inbuf.length - 1; " + "        result[indexOut] = inbuf[pos] * (1 - dt) + inbuf[second] * dt;" + "    }" + "    result[0] = inbuf[0];" + "    result[l - 1] = inbuf[inbuf.length - 1];" + "    return result;" + "};" + "    " + "function record(inputBuffer) {" + "    if (outSampleRate == sampleRate) {" + "        recBuffersL.push(inputBuffer[0]);" + "        recBuffersR.push(inputBuffer[1]);" + "        recLength += inputBuffer[0].length;" + "    " + "        var samples = inputBuffer[0];" + "        var buffer = new ArrayBuffer(samples.length * 2);" + "        var view = new DataView(buffer);" + "        floatTo16BitPCM(view, 0, samples);" + "        this.postMessage({command: 'int16stream', buffer: buffer});" + "    } else {" + "        var filter0 = new iirFilter(outSampleRate, outSampleRate * 0.125, 0.0); " + "        var filter1 = new iirFilter(outSampleRate, outSampleRate * 0.125, 0.0); " + "        for (var i =0; i < inputBuffer[0].length; i++) { " + "            inputBuffer[0][i] = filter0.pushSample(inputBuffer[0][i]); " + "            inputBuffer[1][i] = filter1.pushSample(inputBuffer[1][i]); " + "        }" + "        var resin0 = resample(inputBuffer[0], outSampleRate, sampleRate);" + "        var resin1 = resample(inputBuffer[1], outSampleRate, sampleRate);" + "    " + "        recBuffersL.push(resin0);" + "        recBuffersR.push(resin1);" + "        recLength += resin0.length;" + "    " + "        var result = new Int16Array(resin0.length);" + "    " + "        for (var i = 0 ; i < resin0.length ; i++) {" + "            result[i] = Math.floor(Math.min(Math.max((resin0[i] + resin1[i]) * 0.5, -1.0), 1.0) * 16383);" + "        }" + "    " + "        if (speex_converter) {" + "            result = speex_converter.convert(result);" + "        } else {" + "            result = result.buffer;" + "        }" + "    " + "        if (!tmp_buf) {" + "            tmp_buf = result;" + "        } else {" + "            var tmp = new DataView(new ArrayBuffer(tmp_buf.byteLength + result.byteLength));" + "            tmp_buf = new DataView(tmp_buf);" + "            result = new DataView(result);" + "    " + "            for (i = 0; i < tmp_buf.byteLength; i++) {" + "                tmp.setUint8(i, tmp_buf.getUint8(i));" + "            }" + "    " + "            for (i = 0; i < result.byteLength; i++) {" + "                tmp.setUint8(i + tmp_buf.byteLength, result.getUint8(i));" + "            }" + "    " + "            tmp_buf = tmp.buffer;" + "        }" + "    " + "        if (tmp_buf.byteLength >= need_buf_size) {" + "            this.postMessage({command: 'int16stream', buffer: tmp_buf});" + "            tmp_buf = false;" + "        }" + "    }" + "}" + "    " + "function exportWAV(type) {" + "    var bufferL = mergeBuffers(recBuffersL, recLength);" + "    var bufferR = mergeBuffers(recBuffersR, recLength);" + "    var interleaved = interleave(bufferL, bufferR);" + "    var dataview = encodeWAV(interleaved);" + "    var audioBlob = new Blob([dataview], {type: type});" + "    " + "    this.postMessage({command: 'exportWAV', blob: audioBlob});" + "}" + "    " + "function exportMonoWAV(type) {" + "    var bufferL = mergeBuffers(recBuffersL, recLength);" + "    var dataview = encodeWAV(bufferL, true);" + "    var audioBlob = new Blob([dataview], {type: type});" + "    " + "    this.postMessage({command: 'exportMonoWAV', blob: audioBlob});" + "}" + "    " + "function getBuffers() {" + "    var buffers = [];" + "    buffers.push(mergeBuffers(recBuffersL, recLength));" + "    buffers.push(mergeBuffers(recBuffersR, recLength));" + "    this.postMessage({command: 'getBuffers', blob: buffers});" + "}" + "    " + "function clear() {" + "    recLength = 0;" + "    recBuffersL = [];" + "    recBuffersR = [];" + "    if (speex_converter) {" + "        speex_converter.clear();" + "    }" + "    this.postMessage({command: 'clear'});" + "}" + "    " + "function mergeBuffers(recBuffers, recLength) {" + "    var result = new Float32Array(recLength);" + "    var offset = 0;" + "    for (var i = 0; i < recBuffers.length; i++){" + "        result.set(recBuffers[i], offset);" + "        offset += recBuffers[i].length;" + "    }" + "    return result;" + "}" + "    " + "function interleave(inputL, inputR) {" + "    var length = inputL.length + inputR.length;" + "    var result = new Float32Array(length);" + "    " + "    var index = 0;" + "    var inputIndex = 0;" + "    " + "    while (index < length){" + "        result[index++] = inputL[inputIndex];" + "        result[index++] = inputR[inputIndex];" + "        inputIndex++;" + "    }" + "    return result;" + "}" + "    " + "function floatTo16BitPCM(output, offset, input) {" + "    for (var i = 0; i < input.length; i++, offset += 2){" + "        var s = Math.max(-1, Math.min(1, input[i]));" + "        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);" + "    }" + "}" + "    " + "function writeString(view, offset, string) {" + "    for (var i = 0; i < string.length; i++){" + "        view.setUint8(offset + i, string.charCodeAt(i));" + "    }" + "}" + "    " + "function encodeWAV(samples, mono) {" + "    var buffer = new ArrayBuffer(44 + samples.length * 2);" + "    var view = new DataView(buffer);" + "    " + "    /* RIFF identifier */" + "    writeString(view, 0, 'RIFF');" + "    /* file length */" + "    view.setUint32(4, 32 + samples.length * 2, true);" + "    /* RIFF type */" + "    writeString(view, 8, 'WAVE');" + "    /* format chunk identifier */" + "    writeString(view, 12, 'fmt ');" + "    /* format chunk length */" + "    view.setUint32(16, 16, true);" + "    /* sample format (raw) */" + "    view.setUint16(20, 1, true);" + "    /* channel count */" + "    view.setUint16(22, mono ? 1 : 2, true);" + "    /* sample rate */" + "    view.setUint32(24, outSampleRate, true);" + "    /* block align (channel count * bytes per sample) */" + "    var block_align = mono ? 2 : 4;" + "    /* byte rate (sample rate * block align) */" + "    view.setUint32(28, outSampleRate * block_align, true);" + "    /* block align (channel count * bytes per sample) */" + "    view.setUint16(32, block_align, true);" + "    /* bits per sample */" + "    view.setUint16(34, 16, true);" + "    /* data chunk identifier */" + "    writeString(view, 36, 'data');" + "    /* data chunk length */" + "    view.setUint32(40, samples.length * 2, true);" + "    " + "    floatTo16BitPCM(view, 44, samples);" + "    " + "    return view;" + "}" + " ";
        namespace.ya.speechkit.newWorker = function() {
            return _makeWorker(inline_worker);
        };
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        var SOCKET_CLOSED_ABNORMALLY = 1e3;
        var ERROR_MESSAGE_WAS_RECEIVED = 1001;
        var SOCKET_CLOSED_WITH_ERROR = 1002;
        var CANT_CREATE_SOCKET = 1003;
        var Recognizer = function(options) {
            if (!(this instanceof namespace.ya.speechkit.Recognizer)) return new namespace.ya.speechkit.Recognizer(options);
            this.options = namespace.ya.speechkit._extend({
                apikey: namespace.ya.speechkit.settings.apikey,
                uuid: namespace.ya.speechkit.settings.uuid,
                applicationName: namespace.ya.speechkit.settings.applicationName,
                url: namespace.ya.speechkit.settings.websocketProtocol + namespace.ya.speechkit.settings.asrUrl,
                onInit: function() {},
                onResult: function() {},
                onError: function() {},
                punctuation: true,
                allowStrongLanguage: false
            }, options);
            this.options.key = this.options.apikey;
            this.options.format = this.options.format.mime;
            this.sessionId = null;
            this.socket = null;
            this.closed = false;
            this.buffered = [];
            this.totaldata = 0;
        };
        Recognizer.prototype = {
            _sendRaw: function(data) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) try {
                    this.socket.send(data);
                } catch (e) {
                    this.options.onError("Can't send data", SOCKET_CLOSED_ABNORMALLY);
                    this.close();
                } else console.warn("Attempting to send message while socket is not open");
            },
            _sendJson: function(json) {
                this._sendRaw(JSON.stringify({
                    type: "message",
                    data: json
                }));
            },
            start: function() {
                this.sessionId = null;
                try {
                    this.socket = new WebSocket(this.options.url);
                } catch (e) {
                    this.options.onError("Error on socket creation: " + e, CANT_CREATE_SOCKET);
                    this.options.stopCallback();
                    return;
                }
                this.socket.onopen = function() {
                    this._sendJson(this.options);
                }.bind(this);
                this.socket.onmessage = function(e) {
                    var message = JSON.parse(e.data);
                    if ("InitResponse" == message.type) {
                        this.sessionId = message.data.sessionId;
                        this.options.onInit(message.data.sessionId, message.data.code);
                    } else if ("AddDataResponse" == message.type) {
                        this.options.onResult(message.data.text, message.data.uttr, message.data.merge, message.data.words);
                        if ("undefined" !== typeof message.data.close && message.data.close) this.close();
                    } else if ("Error" == message.type) {
                        this.options.onError("Session " + this.sessionId + ": " + message.data, ERROR_MESSAGE_WAS_RECEIVED);
                        this.close();
                    } else {
                        this.options.onError("Session " + this.sessionId + ": " + message, ERROR_MESSAGE_WAS_RECEIVED);
                        this.close();
                    }
                }.bind(this);
                this.socket.onerror = function(error) {
                    this.options.onError("Socket error: " + error.message, SOCKET_CLOSED_WITH_ERROR);
                    this.close();
                }.bind(this);
                this.socket.onclose = function(event) {
                    if (!event.wasClean) {
                        this.options.onError("Socket closed abnormally", SOCKET_CLOSED_ABNORMALLY);
                        this.close();
                    }
                }.bind(this);
            },
            addData: function(data) {
                this.totaldata += data.byteLength;
                if (!this.sessionId) {
                    this.buffered.push(data);
                    return;
                }
                for (var i = 0; i < this.buffered.length; i++) {
                    this._sendRaw(new Blob([ this.buffered[i] ], {
                        type: this.options.format
                    }));
                    this.totaldata += this.buffered[i].byteLength;
                }
                this.buffered = [];
                this._sendRaw(new Blob([ data ], {
                    type: this.options.format
                }));
            },
            finish: function() {
                this._sendJson({
                    command: "finish"
                });
            },
            close: function() {
                if (this.closed) return;
                this.closed = true;
                this.options.onInit = function() {};
                this.options.onResult = function() {};
                this.options.onError = function() {};
                if (this.isSocketAlive()) this.socket.close();
                this.socket = null;
                this.options.stopCallback();
            },
            isSocketAlive: function() {
                if (!this.socket) return false;
                var readyState = this.socket.readyState;
                return readyState === WebSocket.OPEN || readyState === WebSocket.CONNECTING;
            }
        };
        namespace.ya.speechkit.Recognizer = Recognizer;
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        function noop() {}
        namespace.ya.speechkit._defaultOptions = function() {
            return {
                initCallback: noop,
                errorCallback: noop,
                dataCallback: noop,
                infoCallback: noop,
                stopCallback: noop,
                punctuation: false,
                allowStrongLanguage: false,
                model: namespace.ya.speechkit.settings.model,
                applicationName: namespace.ya.speechkit.settings.applicationName,
                lang: namespace.ya.speechkit.settings.lang,
                format: namespace.ya.speechkit.FORMAT.PCM16,
                url: namespace.ya.speechkit.settings.websocketProtocol + namespace.ya.speechkit.settings.asrUrl,
                vad: false,
                speechStart: noop,
                speechEnd: noop
            };
        };
        var SpeechRecognition = function() {
            if (!(this instanceof namespace.ya.speechkit.SpeechRecognition)) return new namespace.ya.speechkit.SpeechRecognition();
            this.send = 0;
            this.send_bytes = 0;
            this.proc = 0;
            this.recorder = null;
            this.recognizer = null;
            this.vad = null;
        };
        SpeechRecognition.prototype = {
            start: function(options) {
                this.options = namespace.ya.speechkit._extend(namespace.ya.speechkit._extend({}, namespace.ya.speechkit._defaultOptions()), options);
                if (namespace.ya.speechkit.settings.langWhitelist.indexOf(this.options.lang) >= 0) if (null !== namespace.ya.speechkit._stream) this._onstart(); else namespace.ya.speechkit.initRecorder(this._onstart.bind(this), this.options.errorCallback); else {
                    var old_error_callback = this.options.errorCallback;
                    this.recorder = namespace.ya.speechkit.WebAudioRecognition(namespace.ya.speechkit._extend(this.options, {
                        errorCallback: function(e) {
                            this.recorder = null;
                            old_error_callback(e);
                        }.bind(this)
                    }));
                    this.recorder.start();
                }
            },
            _onstart: function() {
                if (this.recorder && this.recorder.isPaused()) this.recorder.start();
                if (this.recognizer) return;
                this.send = 0;
                this.send_bytes = 0;
                this.proc = 0;
                if (!this.recorder) {
                    this.recorder = new namespace.ya.speechkit.Recorder();
                    if (this.options.vad) this.vad = new namespace.ya.speechkit.Vad({
                        recorder: this.recorder,
                        speechStart: this.options.speechStart,
                        speechEnd: this.options.speechEnd
                    });
                }
                this.recognizer = new namespace.ya.speechkit.Recognizer(namespace.ya.speechkit._extend(this.options, {
                    onInit: function(sessionId, code) {
                        if (!this.recorder) return;
                        this.recorder.start(function(data) {
                            if (this.options.vad && this.vad) this.vad.update();
                            this.send++;
                            this.send_bytes += data.byteLength;
                            this.options.infoCallback({
                                send_bytes: this.send_bytes,
                                format: this.options.format,
                                send_packages: this.send,
                                processed: this.proc
                            });
                            this.recognizer.addData(data);
                        }.bind(this), this.options.format);
                        this.options.initCallback(sessionId, code, "yandex");
                    }.bind(this),
                    onResult: function(text, uttr, merge, words) {
                        this.proc += merge;
                        this.options.infoCallback({
                            send_bytes: this.send_bytes,
                            format: this.options.format,
                            send_packages: this.send,
                            processed: this.proc
                        });
                        this.options.dataCallback(text, uttr, merge, words);
                    }.bind(this),
                    onError: function(msg, code) {
                        if (this.recorder) this.recorder.stop(function() {
                            this.recorder = null;
                        }.bind(this));
                        if (this.recognizer) {
                            this.recognizer.close();
                            this.recognizer = null;
                        }
                        this.options.errorCallback(msg, code);
                    }.bind(this)
                }));
                this.recognizer.start();
            },
            stop: function() {
                this.options.initCallback = noop;
                this.options.dataCallback = noop;
                this.options.errorCallback = noop;
                if (this.recognizer) this.recognizer.finish();
                if (this.recorder) this.recorder.stop(function() {
                    this.recognizer = null;
                    this.recorder = null;
                }.bind(this));
            },
            abort: function() {
                this.options.initCallback = noop;
                this.options.dataCallback = noop;
                this.options.errorCallback = noop;
                if (this.recognizer) this.recognizer.close();
                if (this.recorder) this.recorder.stop(function() {
                    this.recognizer = null;
                    this.recorder = null;
                }.bind(this));
            },
            pause: function() {
                if (this.recorder) this.recorder.pause();
            },
            isPaused: function() {
                return !this.recorder || this.recorder.isPaused();
            }
        };
        namespace.ya.speechkit.SpeechRecognition = SpeechRecognition;
        namespace.ya.speechkit.recognize = function(options) {
            var dict = new namespace.ya.speechkit.SpeechRecognition();
            var opts = namespace.ya.speechkit._extend(namespace.ya.speechkit._extend({}, namespace.ya.speechkit._defaultOptions()), options);
            opts.doneCallback = options.doneCallback;
            opts.dataCallback = function(text, uttr, merge) {
                if (uttr) {
                    if (opts.doneCallback) opts.doneCallback(text);
                    dict.stop();
                }
            };
            opts.stopCallback = function() {
                dict = null;
            };
            dict.start(opts);
        };
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        var speakersCache = null;
        namespace.ya.speechkit.play = function(url, cb) {
            var audio = new Audio(url);
            audio.volume = 1;
            audio.onended = cb || function() {};
            audio.play();
        };
        var Tts = function(options) {
            if (!(this instanceof namespace.ya.speechkit.Tts)) return new namespace.ya.speechkit.Tts(options);
            this.options = namespace.ya.speechkit._extend({
                apikey: namespace.ya.speechkit.settings.apikey,
                uuid: namespace.ya.speechkit.settings.uuid,
                url: namespace.ya.speechkit.settings.websocketProtocol + namespace.ya.speechkit.settings.ttsStreamUrl,
                infoCallback: function() {},
                errorCallback: function(msg) {
                    console.log(msg);
                }
            }, options);
            this.sessionId = null;
            this.socket = null;
            this.buffered = [];
        };
        Tts.prototype = {
            _sendRaw: function(data) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) this.socket.send(data); else console.warn("Attempting to send message while socket is not open");
            },
            _sendJson: function(json) {
                this._sendRaw(JSON.stringify({
                    type: "message",
                    data: json
                }));
            },
            say: function(text, cb, options) {
                this.speak(text, namespace.ya.speechkit._extend(this.options, namespace.ya.speechkit._extend({
                    dataCallback: function(blob) {
                        var url = URL.createObjectURL(blob);
                        namespace.ya.speechkit.play(url, cb);
                    }
                }, options)));
            },
            speak: function(text, options) {
                var opts = namespace.ya.speechkit._extend(namespace.ya.speechkit._extend({
                    text: text
                }, this.options), options);
                try {
                    this.socket = new WebSocket(opts.url);
                } catch (e) {
                    opts.errorCallback("Error on socket creation: " + e);
                    return;
                }
                var context = namespace.ya.speechkit.audiocontext || new namespace.ya.speechkit.AudioContext();
                namespace.ya.speechkit.audiocontext = context;
                this.socket.onopen = function() {
                    this._sendJson(opts);
                }.bind(this);
                var play_queue = [];
                this.socket.binaryType = "arraybuffer";
                this.socket.onmessage = function(e) {
                    var message = {};
                    if (e.data && "{" == e.data[0]) try {
                        message = JSON.parse(e.data);
                    } catch (ex) {
                        message = {
                            type: "Audio",
                            data: e.data
                        };
                    } else message = {
                        type: "Audio",
                        data: e.data
                    };
                    if ("InitResponse" == message.type) this.sessionId = message.data.sessionId; else if ("Error" == message.type) {
                        opts.errorCallback("Session " + this.sessionId + ": " + message.data);
                        this.socket.onclose = function() {};
                        this.socket.close();
                    } else if ("Phonemes" == message.type) opts.infoCallback(message.data); else if ("Audio" == message.type) play_queue.push(message.data); else {
                        opts.errorCallback("Session " + this.sessionId + ": " + message);
                        this.socket.onclose = function() {};
                        this.socket.close();
                    }
                }.bind(this);
                this.socket.onerror = function(error) {
                    opts.errorCallback("Socket error: " + error.message);
                }.bind(this);
                this.socket.onclose = function(event) {
                    var res = Array.prototype.concat.apply([], play_queue);
                    var blob = new Blob(res, {
                        type: "audio/x-wav"
                    });
                    if ("undefined" !== typeof opts.dataCallback) opts.dataCallback(blob); else {
                        var url = URL.createObjectURL(blob);
                        namespace.ya.speechkit.play(url, opts.stopCallback);
                    }
                }.bind(this);
            },
            speakers: function(lang) {
                return new Promise(function(resolve, reject) {
                    if (speakersCache) resolve(speakersCache); else {
                        var xhr = new XMLHttpRequest();
                        xhr.open("GET", this.options.url.replace("wss://", "https://").replace("ws://", "http://").replace("ttssocket.ws", "speakers?engine=ytcp&lang=" + (lang || "")));
                        xhr.onreadystatechange = function() {
                            if (4 == this.readyState) if (200 == this.status) try {
                                speakersCache = JSON.parse(this.responseText);
                                resolve(speakersCache);
                            } catch (ex) {
                                reject(ex.message);
                            } else reject("Can't get speakers list!");
                        };
                        xhr.send();
                    }
                }.bind(this));
            }
        };
        namespace.ya.speechkit.Tts = Tts;
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        var WebAudioRecognition = function(options) {
            if (!(this instanceof namespace.ya.speechkit.WebAudioRecognition)) return new namespace.ya.speechkit.WebAudioRecognition(options);
            this.recognition = null;
            this.recorder = null;
            this.options = namespace.ya.speechkit._extend(namespace.ya.speechkit._extend(namespace.ya.speechkit._defaultOptions(), options), {
                format: namespace.ya.speechkit.FORMAT.PCM44
            });
        };
        WebAudioRecognition.prototype = {
            _onstart: function() {
                this.send = 0;
                this.send_bytes = 0;
                this.recognition = namespace.ya.speechkit._extend(this.recognition, {
                    interim_transcript: "",
                    lang: this.options.lang,
                    onend: this.stop.bind(this),
                    onresult: function(event) {
                        this.interim_transcript = "";
                        var arr = [];
                        for (var i = event.resultIndex; i < event.results.length; ++i) if (event.results[i].isFinal) {
                            arr.push({
                                0: {
                                    transcript: event.results[i][0].transcript,
                                    confidence: event.results[i][0].confidence
                                }
                            });
                            this.backref.options.dataCallback(event.results[i][0].transcript, true, 1);
                            this.interim_transcript = "";
                        } else this.interim_transcript += event.results[i][0].transcript;
                        if (arr.length) this.backref.recognizer._sendJson(arr);
                        this.backref.options.dataCallback(this.interim_transcript, false, 1);
                    },
                    continuous: true,
                    interimResults: true,
                    maxAlternatives: 5,
                    errorCallback: this.options.errorCallback,
                    onerror: function(e) {
                        this.errorCallback(e.error);
                    }
                });
                this.recognition.backref = this;
                this.recorder = new namespace.ya.speechkit.Recorder();
                this.recognizer = new namespace.ya.speechkit.Recognizer(namespace.ya.speechkit._extend(this.options, {
                    url: this.options.url.replace("asrsocket.ws", "logsocket.ws"),
                    samplerate: this.options.format.sampleRate,
                    onInit: function(sessionId, code) {
                        this.recorder.start(function(data) {
                            if (this.options.vad && this.vad) this.vad.update();
                            this.send++;
                            this.send_bytes += data.byteLength;
                            this.options.infoCallback({
                                send_bytes: this.send_bytes,
                                format: this.options.format,
                                send_packages: this.send,
                                processed: this.proc
                            });
                            this.recognizer.addData(data);
                        }.bind(this), this.options.format);
                        this.recognition.onstart = this.options.initCallback.bind(this, sessionId, code, "native");
                        this.recognition.start();
                    }.bind(this),
                    onResult: function() {},
                    onError: function(msg) {
                        this.recorder.stop(function() {});
                        this.recognizer.close();
                        this.recognizer = null;
                        this.options.errorCallback(msg);
                    }.bind(this)
                }));
                this.recognizer.start();
            },
            start: function() {
                if ("undefined" !== typeof namespace.webkitSpeechRecognition) {
                    this.recognition = new namespace.webkitSpeechRecognition();
                    if (null !== namespace.ya.speechkit._stream) this._onstart(); else namespace.ya.speechkit.initRecorder(this._onstart.bind(this), this.options.errorCallback);
                } else this.options.errorCallback("Your browser doesn't implement Web Speech API");
            },
            stop: function(cb) {
                if (this.recognition) {
                    this.recognition.onend = function() {};
                    this.recognition.stop();
                }
                if (this.recorder) this.recorder.stop();
                if (this.recognizer) this.recognizer.close();
                this.options.stopCallback();
                if ("undefined" !== typeof cb) if ("[object Function]" == Object.prototype.toString.call(cb)) cb();
            },
            pause: function() {},
            isPaused: function() {
                return false;
            },
            getAnalyserNode: function() {
                if (this.recorder) return this.recorder.getAnalyserNode();
            }
        };
        namespace.ya.speechkit.WebAudioRecognition = WebAudioRecognition;
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        namespace.ya.speechkit.SpeakerId = function() {
            if (!(this instanceof namespace.ya.speechkit.SpeakerId)) return new namespace.ya.speechkit.SpeakerId();
            if (!namespace.ya.speechkit._recorderInited) namespace.ya.speechkit.initRecorder(this.onInited.bind(this), function(error) {
                alert("Failed to init recorder: " + error);
            });
        };
        namespace.ya.speechkit.SpeakerId.prototype = {
            onInited: function() {
                this.recorder = new namespace.ya.speechkit.Recorder();
            },
            startRecord: function() {
                console.log("Start recording...");
                this.recorder.start(function(data) {
                    console.log("Recorder callback, recorded data length: " + data.byteLength);
                }, namespace.ya.speechkit.FORMAT.PCM8);
            },
            completeRecordAndRegister: function(userid, keepPrev, text, onRegister) {
                console.log("completeRecordAndRegister");
                this.recorder.stop(function(wav) {
                    console.log("Wav is ready:");
                    console.log(wav);
                    var fd = new FormData();
                    fd.append("name", userid);
                    fd.append("text", text);
                    fd.append("audio", wav);
                    fd.append("keepPrev", keepPrev ? "true" : "false");
                    var xhr = new XMLHttpRequest();
                    xhr.open("POST", namespace.ya.speechkit.settings.voicelabUrl + "register_voice");
                    xhr.onreadystatechange = function() {
                        if (4 == this.readyState) if (200 == this.status) {
                            console.log(this.responseText);
                            onRegister(this.responseText);
                        } else onRegister("Failed to register data, could not access " + namespace.ya.speechkit.settings.voicelabUrl + " Check out developer tools -> console for more details.");
                    };
                    xhr.send(fd);
                });
            },
            completeRecordAndIdentify: function(onFoundUser) {
                console.log("Indentify");
                this.recorder.stop(function(wav) {
                    console.log("Wav is ready:");
                    console.log(wav);
                    var fd = new FormData();
                    fd.append("audio", wav);
                    var xhr = new XMLHttpRequest();
                    xhr.open("POST", namespace.ya.speechkit.settings.voicelabUrl + "detect_voice");
                    xhr.onreadystatechange = function() {
                        if (4 == this.readyState) if (200 == this.status) {
                            console.log(this.responseText);
                            var data = {};
                            try {
                                data = JSON.parse(this.responseText);
                            } catch (e) {
                                onFoundUser(false, "Failed to find user, internal server error: " + e);
                                return;
                            }
                            onFoundUser(true, data);
                        } else onFoundUser(false, "Failed to find user, could not access " + namespace.ya.speechkit.settings.voicelabUrl + " Check out developer tools -> console for more details.");
                    };
                    xhr.send(fd);
                }, 1);
            },
            feedback: function(requestId, feedback) {
                console.log("Post feedback");
                var fd = new FormData();
                fd.append("requestId", requestId);
                fd.append("feedback", feedback);
                var xhr = new XMLHttpRequest();
                xhr.open("POST", namespace.ya.speechkit.settings.voicelabUrl + "postFeedback");
                xhr.onreadystatechange = function() {
                    if (4 == this.readyState) console.log(this.responseText);
                };
                xhr.send(fd);
            }
        };
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        namespace.ya.speechkit.Equalizer = function(target, recorder) {
            this.recorder = recorder;
            this.element = document.getElementById(target);
            this.element.style.textAlign = "center";
            this.element.innerText = "";
            this.graf = document.createElement("canvas");
            this.graf.style.width = "100%";
            this.graf.style.height = "100%";
            this.graf.width = 1e3;
            this.element.appendChild(this.graf);
            if (!navigator.cancelAnimationFrame) navigator.cancelAnimationFrame = navigator.webkitCancelAnimationFrame || navigator.mozCancelAnimationFrame;
            if (!navigator.requestAnimationFrame) navigator.requestAnimationFrame = navigator.webkitRequestAnimationFrame || navigator.mozRequestAnimationFrame;
            this.refID = null;
            this.startDrawRealtime();
        };
        namespace.ya.speechkit.Equalizer.prototype = {
            destroy: function() {
                this.stopDrawRealtime();
                this.element.removeChild(this.graf);
            },
            stopDrawRealtime: function() {
                window.cancelAnimationFrame(this.rafID);
                this.rafID = null;
            },
            startDrawRealtime: function() {
                var _this = this;
                function updateAnalysers(time) {
                    if (!_this.analyserNode) if (_this.recorder) {
                        _this.analyserNode = _this.recorder.getAnalyserNode();
                        _this.context = _this.recorder.context;
                    } else return;
                    var canvasWidth = _this.graf.width;
                    var canvasHeight = _this.graf.height;
                    var analyserContext = _this.graf.getContext("2d");
                    var SPACING = 2;
                    var BAR_WIDTH = 1;
                    var numBars = Math.round(canvasWidth / SPACING);
                    var freqByteData = new Uint8Array(_this.analyserNode.frequencyBinCount);
                    _this.analyserNode.getByteFrequencyData(freqByteData);
                    analyserContext.clearRect(0, 0, canvasWidth, canvasHeight);
                    analyserContext.fillStyle = "#F6D565";
                    analyserContext.lineCap = "round";
                    var multiplier = _this.analyserNode.frequencyBinCount / numBars;
                    for (var i = 0; i < numBars; ++i) {
                        var magnitude = 0;
                        var offset = Math.floor(i * multiplier);
                        for (var j = 0; j < multiplier; j++) magnitude += freqByteData[offset + j];
                        magnitude = magnitude / multiplier / 2;
                        analyserContext.fillStyle = "hsl( " + Math.round(60 * i / numBars) + ", 100%, 50%)";
                        analyserContext.fillRect(i * SPACING, canvasHeight, BAR_WIDTH, -magnitude);
                    }
                    _this.rafID = window.requestAnimationFrame(updateAnalysers);
                }
                this.rafID = window.requestAnimationFrame(updateAnalysers);
            }
        };
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        namespace.ya.speechkit._mic_on = '<svg version="1.1" id="Layer_1" ' + ' xmlns:sketch="http://www.bohemiancoding.com/sketch/ns"' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' + ' x="0px" y="0px" viewBox="0 0 112 112"' + ' enable-background="new 0 0 112 112" xml:space="preserve">' + ' <g id="tuts" sketch:type="MSPage">' + ' <g id="mic_ff" sketch:type="MSLayerGroup">' + ' <g sketch:type="MSShapeGroup">' + ' <circle id="path-1" fill="rgb(255, 204, 0)" cx="56" cy="56" r="56"/>' + " </g>" + ' <g id="speechkit_vector-9" transform="translate(39.000000, 32.000000)" ' + ' sketch:type="MSShapeGroup" opacity="0.9">' + ' <path id="Shape" d="M17,4c2.8,0,5,2.3,5,5.2v15.6c0,2.9-2.2,5.2-5,5.2s-5-2.3-5-5.2V9.2C12,6.3,14.2,4,17,4 M17,0' + ' c-5,0-9,4.1-9,9.2v15.6c0,5.1,4,9.2,9,9.2s9-4.1,9-9.2V9.2C26,4.1,22,0,17,0L17,0z"/>' + ' <path id="Shape_1_" ' + ' d="M34,23v1.1C34,34,26.4,42,17,42S0,34,0,24.1V23h4v0.1C4,31.3,9.8,38,17,38s13-6.7,13-14.9V23H34z"/>' + ' <rect id="Rectangle-311" x="15" y="41" width="4" height="10"/>' + " </g>" + " </g>" + " </g>" + " </svg>";
        namespace.ya.speechkit._mic_off = '<svg version="1.1" id="Layer_1" ' + ' xmlns:sketch="http://www.bohemiancoding.com/sketch/ns"' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' + ' x="0px" y="0px" viewBox="0 0 112 112"' + ' enable-background="new 0 0 112 112" xml:space="preserve">' + ' <g id="tuts" sketch:type="MSPage">' + ' <g id="mic_ff" sketch:type="MSLayerGroup">' + ' <g id="speechkit_vector-9" transform="translate(39.000000, 32.000000)" ' + ' sketch:type="MSShapeGroup" opacity="0.9">' + ' <path id="Shape" d="M17,4c2.8,0,5,2.3,5,5.2v15.6c0,2.9-2.2,5.2-5,5.2s-5-2.3-5-5.2V9.2C12,6.3,14.2,4,17,4 M17,0' + ' c-5,0-9,4.1-9,9.2v15.6c0,5.1,4,9.2,9,9.2s9-4.1,9-9.2V9.2C26,4.1,22,0,17,0L17,0z"/>' + ' <path id="Shape_1_" ' + ' d="M34,23v1.1C34,34,26.4,42,17,42S0,34,0,24.1V23h4v0.1C4,31.3,9.8,38,17,38s13-6.7,13-14.9V23H34z"/>' + ' <rect id="Rectangle-311" x="15" y="41" width="4" height="10"/>' + " </g>" + " </g>" + " </g>" + " </svg>";
        namespace.ya.speechkit.Textline = function(target, options) {
            if (!(this instanceof namespace.ya.speechkit.Textline)) return new namespace.ya.speechkit.Textline(target, options);
            var el = document.getElementById(target);
            if ("INPUT" != el.tagName) {
                this.element = el;
                this.textinput = document.createElement("input");
                this.textinput.style.height = "100%";
                this.textinput.style.width = "100%";
            } else {
                this.textinput = el;
                this.element = null;
            }
            this.textinput.style.backgroundImage = "url('data:image/svg+xml;utf8," + namespace.ya.speechkit._mic_off + "')";
            this.textinput.style.backgroundRepeat = "no-repeat";
            this.textinput.style.backgroundPosition = "right center";
            if (this.element) this.element.appendChild(this.textinput);
            this.dict = null;
            this.final_result = "";
            var _this = this;
            this.textinput.onmousemove = function(event) {
                var rect = _this.textinput.getBoundingClientRect();
                if (event.clientX - rect.x > rect.width - rect.height) _this.textinput.style.cursor = "pointer"; else _this.textinput.style.cursor = "text";
            };
            options = options || {};
            options.dataCallback = function(text, uttr, merge) {
                _this.textinput.value = text;
                if (uttr) {
                    if (options.onInputFinished) {
                        _this.final_result = text;
                        options.onInputFinished(text);
                    }
                    _this.dict.abort();
                }
            };
            options.initCallback = function() {
                _this.textinput.style.backgroundImage = "url('data:image/svg+xml;utf8," + ya.speechkit._mic_on + "')";
            };
            options.stopCallback = function() {
                _this.textinput.style.backgroundImage = "url('data:image/svg+xml;utf8," + ya.speechkit._mic_off + "')";
                _this.dict = null;
            };
            this.textinput.onmousedown = function(event) {
                var rect = _this.textinput.getBoundingClientRect();
                if (event.clientX <= rect.width - rect.height) return;
                if (!_this.dict) _this.dict = new ya.speechkit.SpeechRecognition();
                if (_this.dict.isPaused()) _this.dict.start(options); else _this.dict.stop();
            };
            return {
                destroy: function() {
                    if (_this.dict) _this.dict.stop();
                    _this.textinput.style.backgroundImage = "";
                    _this.textinput.onmousedown = function() {};
                    _this.textinput.onmousemove = function() {};
                    if (_this.element) _this.element.removeChild(_this.textinput);
                },
                value: function() {
                    return _this.final_result;
                }
            };
        };
    }(speechkitNamespace);
    !function(namespace) {
        "use strict";
        if ("undefined" === typeof namespace.ya) namespace.ya = {};
        if ("undefined" === typeof namespace.ya.speechkit) namespace.ya.speechkit = {};
        var settings = {
            websocketProtocol: "wss://",
            asrUrl: "webasr.yandex.net/asrsocket.ws",
            ttsUrl: "https://tts.voicetech.yandex.net",
            ttsStreamUrl: "webasr.yandex.net/ttssocket.ws",
            lang: "ru-RU",
            langWhitelist: [ "ru-RU", "tr-TR", "en-US", "en-GB", "uk-UA", "ru", "tr", "en", "uk", "en-EN" ],
            model: "notes",
            applicationName: "jsapi",
            apikey: "",
            uuid: "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
                var r = 16 * Math.random() | 0;
                var v = "x" == c ? r : 3 & r | 8;
                return v.toString(16);
            })
        };
        if ("undefined" === typeof namespace.ya.speechkit._extend) namespace.ya.speechkit.settings = settings; else namespace.ya.speechkit.settings = namespace.ya.speechkit._extend(settings, namespace.ya.speechkit.settings);
    }(speechkitNamespace);
    module.exports = speechkitNamespace;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var xml = __webpack_require__(61);
    var events = __webpack_require__(69);
    var XMLHandler = function() {
        function XMLHandler() {
            _classCallCheck(this, XMLHandler);
        }
        _createClass(XMLHandler, [ {
            key: "_toXML",
            value: function(string) {
                return xml.fromStringOriginal(string);
            }
        }, {
            key: "_getAttr",
            value: function(_ref) {
                var xmlString = _ref.xmlString, selector = _ref.selector, attr = _ref.attr, sendResponse = _ref.sendResponse;
                if ("string" === typeof xmlString) {
                    var xmlDoc = this._toXML(xmlString);
                    sendResponse({
                        attr: xml.getAttrOriginal(xmlDoc, selector, attr)
                    });
                } else {
                    var errObj = {
                        message: "No serialized xml found."
                    };
                    sendResponse({
                        errObj: errObj
                    });
                }
            }
        }, {
            key: "_getText",
            value: function(_ref2) {
                var xmlString = _ref2.xmlString, selector = _ref2.selector, sendResponse = _ref2.sendResponse;
                if ("string" === typeof xmlString) {
                    var xmlDoc = this._toXML(xmlString);
                    sendResponse({
                        text: xml.getTextOriginal(xmlDoc, selector)
                    });
                } else {
                    var errObj = {
                        message: "No serialized xml found."
                    };
                    sendResponse({
                        errObj: errObj
                    });
                }
            }
        }, {
            key: "_selectAll",
            value: function(_ref3) {
                var selector = _ref3.selector, parent = _ref3.parent, sendResponse = _ref3.sendResponse;
                if ("string" === typeof parent) {
                    var xmlDoc = this._toXML(parent);
                    sendResponse({
                        selection: xml.selectAllOriginal(selector, xmlDoc)
                    });
                } else {
                    var errObj = {
                        message: "No serialized xml found."
                    };
                    sendResponse({
                        errObj: errObj
                    });
                }
            }
        }, {
            key: "handle",
            value: function(req, _sender) {
                switch (req.type) {
                  case events.backend.XML_FROM_STRING:
                    this._fromString(req.data);
                    break;

                  case events.backend.XML_GET_ATTR:
                    this._getAttr(req.data);
                    break;

                  case events.backend.XML_GET_TEXT:
                    this._getText(req.data);
                    break;

                  case events.backend.XML_SELECT_ALL:
                    this._selectAll(req.data);
                    break;

                  default:
                    return;
                }
                return true;
            }
        } ]);
        return XMLHandler;
    }();
    module.exports = new XMLHandler();
}, function(module, exports, __webpack_require__) {
    "use strict";
    var alarms = __webpack_require__(3);
    var channel = __webpack_require__(27);
    var ALARM = {
        name: "refreshSearchExamples",
        periodInMinutes: 24 * 60
    };
    exports.init = function() {
        alarms.register(ALARM, function() {
            exports.onRefreshExamples.dispatch();
        });
    };
    exports.onRefreshExamples = channel.create();
}, function(module, exports, __webpack_require__) {
    "use strict";
    var alarms = __webpack_require__(514);
    var logger = __webpack_require__(5).create("search examples");
    var loader = __webpack_require__(516);
    var state = __webpack_require__(517);
    exports.init = function() {
        logger.info("Initializing search examples");
        alarms.onRefreshExamples.addListener(exports.refreshExamples);
        alarms.init();
    };
    exports.getExample = function() {
        var currentExample = state.getExample();
        return currentExample ? currentExample.text : "";
    };
    exports.refreshExamples = function() {
        loader.load(function(error, examples) {
            if (error) logger.error("Error while loading examples: %j", error); else {
                logger.info("Examples have been loaded");
                state.refreshExamples(examples);
            }
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var xhr = __webpack_require__(32);
    var curly = __webpack_require__(207);
    var i18n = __webpack_require__(280);
    var branding = __webpack_require__(277);
    var REQUEST_TIMEOUT_MS = 5e3;
    var REQUEST_TYPE = "json";
    exports.load = function(callback) {
        sendRequest(function(error, json) {
            callback(error, json ? json.data : []);
        });
    };
    function sendRequest(callback) {
        xhr({
            url: createUrl(),
            timeout: REQUEST_TIMEOUT_MS,
            parse: REQUEST_TYPE
        }, callback);
    }
    function createUrl() {
        return curly.insertUrlVars(branding.search.examplesUrl, {
            locale: i18n.locale
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var sort = __webpack_require__(518);
    var storage = __webpack_require__(523);
    var sum = __webpack_require__(524);
    var EXAMPLE_WEIGHT_FIELD = "weight";
    exports.refreshExamples = function(examples) {
        var sortedList = sortExamples(examples);
        storage.setExamples(sortedList);
    };
    exports.getExample = function() {
        var examples = storage.getExamples();
        return getRandomItem(examples);
    };
    function sortExamples(list) {
        return sort(list, [ "weight" ], [ "desc" ]);
    }
    function getRandomItem(list) {
        var normalWeights = getNormalizedItems(list, EXAMPLE_WEIGHT_FIELD);
        var randomNumber = Math.random();
        var item = findRandomItem(normalWeights, randomNumber);
        if (!item) return list[Math.floor(randomNumber * list.length)]; else return list[item.index];
    }
    function getNormalizedItems(list, field) {
        var totalSum = sum(list, field);
        if (!totalSum) return [];
        return list.map(function(item, index) {
            return {
                value: item[field] / totalSum,
                index: index
            };
        });
    }
    function findRandomItem(list, number) {
        var item = null;
        var currentLength = 0;
        for (var i = 0; i < list.length; i++) {
            item = list[i];
            currentLength += item.value;
            if (currentLength >= number) return item;
        }
        return item;
    }
}, function(module, exports, __webpack_require__) {
    var baseSortByOrder = __webpack_require__(519), isArray = __webpack_require__(52), isIterateeCall = __webpack_require__(98);
    function sortByOrder(collection, iteratees, orders, guard) {
        if (null == collection) return [];
        if (guard && isIterateeCall(iteratees, orders, guard)) orders = void 0;
        if (!isArray(iteratees)) iteratees = null == iteratees ? [] : [ iteratees ];
        if (!isArray(orders)) orders = null == orders ? [] : [ orders ];
        return baseSortByOrder(collection, iteratees, orders);
    }
    module.exports = sortByOrder;
}, function(module, exports, __webpack_require__) {
    var arrayMap = __webpack_require__(141), baseCallback = __webpack_require__(103), baseMap = __webpack_require__(142), baseSortBy = __webpack_require__(520), compareMultiple = __webpack_require__(521);
    function baseSortByOrder(collection, iteratees, orders) {
        var index = -1;
        iteratees = arrayMap(iteratees, function(iteratee) {
            return baseCallback(iteratee);
        });
        var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) {
                return iteratee(value);
            });
            return {
                criteria: criteria,
                index: ++index,
                value: value
            };
        });
        return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
        });
    }
    module.exports = baseSortByOrder;
}, function(module, exports) {
    function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) array[length] = array[length].value;
        return array;
    }
    module.exports = baseSortBy;
}, function(module, exports, __webpack_require__) {
    var baseCompareAscending = __webpack_require__(522);
    function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
            var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
                if (index >= ordersLength) return result;
                var order = orders[index];
                return result * ("asc" === order || true === order ? 1 : -1);
            }
        }
        return object.index - other.index;
    }
    module.exports = compareMultiple;
}, function(module, exports) {
    function baseCompareAscending(value, other) {
        if (value !== other) {
            var valIsNull = null === value, valIsUndef = void 0 === value, valIsReflexive = value === value;
            var othIsNull = null === other, othIsUndef = void 0 === other, othIsReflexive = other === other;
            if (value > other && !othIsNull || !valIsReflexive || valIsNull && !othIsUndef && othIsReflexive || valIsUndef && othIsReflexive) return 1;
            if (value < other && !valIsNull || !othIsReflexive || othIsNull && !valIsUndef && valIsReflexive || othIsUndef && valIsReflexive) return -1;
        }
        return 0;
    }
    module.exports = baseCompareAscending;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    var EXAMPLES_PREF = "searchExamples";
    exports.setExamples = function(examples) {
        if (examples) settings.set(EXAMPLES_PREF, examples);
    };
    exports.getExamples = function() {
        return settings.get(EXAMPLES_PREF) || [];
    };
}, function(module, exports, __webpack_require__) {
    var arraySum = __webpack_require__(525), baseCallback = __webpack_require__(103), baseSum = __webpack_require__(526), isArray = __webpack_require__(52), isIterateeCall = __webpack_require__(98), toIterable = __webpack_require__(147);
    function sum(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) iteratee = void 0;
        iteratee = baseCallback(iteratee, thisArg, 3);
        return 1 == iteratee.length ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) : baseSum(collection, iteratee);
    }
    module.exports = sum;
}, function(module, exports) {
    function arraySum(array, iteratee) {
        var length = array.length, result = 0;
        while (length--) result += +iteratee(array[length]) || 0;
        return result;
    }
    module.exports = arraySum;
}, function(module, exports, __webpack_require__) {
    var baseEach = __webpack_require__(125);
    function baseSum(collection, iteratee) {
        var result = 0;
        baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
        });
        return result;
    }
    module.exports = baseSum;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var coreLogger = __webpack_require__(5);
    var settings = __webpack_require__(216);
    var defaults = __webpack_require__(217);
    var CONSOLE_LEVEL = "consoleLogLevels";
    var PLATFORM_LEVEL = "platformLogLevels";
    exports.prepare = function() {
        coreLogger.setLevels("console", defaults[CONSOLE_LEVEL]);
        coreLogger.setLevels("platform", defaults[PLATFORM_LEVEL]);
    };
    exports.init = function() {
        coreLogger.setLevels("console", settings.get(CONSOLE_LEVEL));
        coreLogger.setLevels("platform", settings.get(PLATFORM_LEVEL));
        settings.onChanged.addListener(onSettingChanged);
    };
    function onSettingChanged(data) {
        if (data.key === CONSOLE_LEVEL) setLevels("console", data); else if (data.key === PLATFORM_LEVEL) setLevels("platform", data);
    }
    function setLevels(writerName, levelsData) {
        coreLogger.info("Change %s log levels, old: %o, new: %o", writerName, levelsData.oldValue, levelsData.newValue);
        coreLogger.setLevels(writerName, levelsData.newValue);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(30);
    var settings = __webpack_require__(216);
    var platformSettings = __webpack_require__(529);
    var OBSERVED_SETTINGS = [ "sendUsageStat" ];
    exports.init = function(callback) {
        callback = callback || utils.noop;
        setSettingsFromPlatform();
        settings.onChanged.addListener(onSettingChanged);
        platformSettings.onChanged.addListener(onPlatformSettingChanged);
        callback();
    };
    function setSettingsFromPlatform() {
        OBSERVED_SETTINGS.forEach(function(name) {
            var value = platformSettings.get(name);
            if ("undefined" !== typeof value) settings.set(name, value);
        });
    }
    function onSettingChanged(info) {
        if (isObservedSetting(info.key)) platformSettings.set(info.key, info.newValue);
    }
    function onPlatformSettingChanged(info) {
        if (isObservedSetting(info.key)) settings.set(info.key, info.newValue);
    }
    function isObservedSetting(name) {
        return OBSERVED_SETTINGS.indexOf(name) !== -1;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var channel = __webpack_require__(27);
    exports.get = function() {};
    exports.set = function() {};
    exports.onChanged = channel.create();
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.init = function() {
        __webpack_require__(226).init();
        __webpack_require__(273).init();
        __webpack_require__(272).init();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var settings = __webpack_require__(216);
    exports.get = function() {
        return 1e3 * (settings.get("appInstallTime") || 0);
    };
    exports.setCurrent = function() {
        settings.set("appInstallTime", Math.round(Date.now() / 1e3));
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var backgrounds = __webpack_require__(390);
    var remoteConfig = __webpack_require__(372);
    var advertisement = __webpack_require__(369);
    var experimentActualConfigs = __webpack_require__(357);
    var alarms = __webpack_require__(3);
    exports.preInit = function(callback) {
        experimentActualConfigs.tryForceTestId(callback);
    };
    exports.run = function() {
        backgrounds.sync();
        remoteConfig.check();
        advertisement.checkGroups();
        alarms.trigger("informers");
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var versions = __webpack_require__(345);
    var installDate = __webpack_require__(531);
    var utils = __webpack_require__(30);
    var platform = __webpack_require__(334);
    var waterfall = __webpack_require__(209).waterfall;
    var platformConfigure = __webpack_require__(331);
    var backup = __webpack_require__(411);
    var backgroundSelector = __webpack_require__(384);
    var bannerid = __webpack_require__(337);
    var pickup = __webpack_require__(435);
    var installUpgrade = __webpack_require__(532);
    var logger = __webpack_require__(5).create("Startup/install");
    var brandingRemoteLoader = __webpack_require__(439);
    exports.preInit = function(callback) {
        installUpgrade.preInit(callback);
    };
    exports.run = function(callback) {
        logger.info("Clean install of version %s", versions.getCurrent());
        logger.info("Guid: %s", platform.guid);
        installDate.setCurrent();
        waterfall([ function(callback) {
            bannerid.processCookie().then(function(banneridValue) {
                callback(null, banneridValue);
            }).catch(utils.noargs(callback));
        }, function(banneridValue, callback) {
            if (banneridValue) brandingRemoteLoader.tryLoad({
                attempt: 0
            }).then(utils.noargs(callback)).catch(utils.noargs(callback)); else callback();
        }, function(callback) {
            backup.tryRestoreFromCookies().then(function(success) {
                callback(null, success);
            }).catch(function(e) {
                logger.error(e.stack);
                callback(null, false);
            });
        }, function(restoreSuccess, callback) {
            if (restoreSuccess) {
                pickup.run({
                    dryRun: true
                });
                callback();
            } else pickup.run({
                fast: true
            }, utils.noargs(callback));
        } ], function() {
            backgroundSelector.selectDefaultBackground();
            platformConfigure({
                softExport: "send"
            });
            versions.addToHistory(versions.getCurrent());
            installUpgrade.run();
            callback();
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var collection = __webpack_require__(270);
    var pickup = __webpack_require__(435);
    var versions = __webpack_require__(345);
    var logger = __webpack_require__(5).create("Startup/normalStart");
    exports.preInit = function(callback) {
        callback();
    };
    exports.run = function(callback) {
        logger.info("Normal start of version %s", versions.getCurrent());
        collection.loadFromDB(function(err) {
            if (err || 0 === collection.length) {
                logger.warn("Re run pickup as collection empty");
                pickup.run({
                    fast: true
                }, callback);
            } else callback();
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var messaging = __webpack_require__(510);
    exports.run = function() {
        messaging.init();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var database = __webpack_require__(295);
    var platformConfigure = __webpack_require__(331);
    var logger = __webpack_require__(5).create("Startup/uninstall");
    exports.setup = function() {
        logger.info("Setup..");
        platformConfigure({
            onUninstall: onUninstall
        });
        platformConfigure({
            softExport: "setUninstallURL"
        });
    };
    function onUninstall() {
        database.deleteDatabase();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var versions = __webpack_require__(345);
    var collection = __webpack_require__(270);
    var runstate = __webpack_require__(344);
    var migration = __webpack_require__(506);
    var pickup = __webpack_require__(435);
    var installUpgrade = __webpack_require__(532);
    var logger = __webpack_require__(5).create("Startup/upgrade");
    exports.preInit = function(callback) {
        installUpgrade.preInit(callback);
    };
    exports.run = function(callback) {
        logger.info("Upgrading from %s to %s", versions.getPrevious(), versions.getCurrent());
        migration.run({
            previousVersion: versions.getPrevious(),
            currentVersion: versions.getCurrent(),
            migrationData: runstate.getMigrationDataCommonBackend()
        }, function(err) {
            if (err) logger.error("Error during migration %j", err); else versions.addToHistory(versions.getCurrent());
            collection.loadFromDB(function() {
                pickup.run({
                    dryRun: true
                });
                collection.loadMissingData({
                    force: true
                });
                installUpgrade.run();
                callback();
            });
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var clicker = __webpack_require__(438);
    var advertisement = __webpack_require__(369);
    var Block = __webpack_require__(374);
    var platformAbout = __webpack_require__(23);
    var logger = __webpack_require__(5).create("Statistics/advertisement");
    var CID = 72582;
    exports.init = function() {
        var blocks = advertisement.getAllBlocks();
        if (!blocks.length) throw new Error("Blocks not initialized!");
        blocks.forEach(function(block) {
            block.onStartShowing.addListener(onStartShowing);
            block.onRefuse.addListener(onRefuse);
        });
    };
    function onStartShowing(block) {
        send(block, "show");
    }
    function onRefuse(block, reason) {
        send(block, getParamByRefuseReason(reason));
    }
    function send(block, param) {
        if (param) {
            var path = [ platformAbout.id, clicker.getPlatformVersion(), block.getId(), param ];
            clicker.send({
                path: path,
                cid: CID
            });
        } else logger.warn("Empty param for block %s", block.getId());
    }
    function getParamByRefuseReason(reason) {
        switch (reason) {
          case Block.REFUSE_REASON.ACCEPT:
            return "accept";

          case Block.REFUSE_REASON.USERCLOSE:
            return "close";

          case Block.REFUSE_REASON.DURATION:
            return "timeoutclose";

          case Block.REFUSE_REASON.EXTERNAL:
            return "externalclose";
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var clicker = __webpack_require__(438);
    var auth = __webpack_require__(429);
    exports.init = function() {
        auth.onAction.addListener(function(type) {
            switch (type) {
              case "retpath.login":
                clicker.send({
                    path: "auth.done.vb"
                });
            }
        });
        auth.onUsersChanged.addListener(function(type) {
            switch (type) {
              case "add":
              case "login":
                clicker.send({
                    path: "auth.done.total"
                });
                break;

              case "logout":
                clicker.send({
                    path: "auth.exit.total"
                });
            }
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var clicker = __webpack_require__(438);
    var brandingLoader = __webpack_require__(439);
    exports.init = function() {
        brandingLoader.onLoadError.addListener(function(bannerId) {
            clicker.send({
                path: "system.custombridloadfail." + bannerId
            });
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var clicker = __webpack_require__(438);
    var hostsPermissions = __webpack_require__(500);
    exports.init = function() {
        hostsPermissions.onRestrictedByUser.addListener(sendStat);
    };
    function sendStat() {
        clicker.send({
            path: "system.hostPermissions.restrictedByUser",
            transport: "img"
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var backup = __webpack_require__(405);
    var clicker = __webpack_require__(438);
    var SYSTEM_FILEBACKUP_SAVED = "system.filebackup.saved";
    var SYSTEM_FILEBACKUP_LOADED = "system.filebackup.loaded";
    module.exports = {
        init: function() {
            backup.onLoaded.addListener(function() {
                return send(SYSTEM_FILEBACKUP_LOADED);
            });
            backup.onMade.addListener(function() {
                return send(SYSTEM_FILEBACKUP_SAVED);
            });
        }
    };
    function send(path) {
        clicker.send({
            path: path
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var clicker = __webpack_require__(438);
    var tabs = __webpack_require__(282);
    var tabsWatcher = __webpack_require__(459);
    var urlUtils = __webpack_require__(83);
    var platfromAbout = __webpack_require__(23);
    exports.init = function() {
        tabsWatcher.init(platfromAbout);
        tabsWatcher.onComplete.addListener(handleCompletedEvent);
        forEachVBTab(sendStat);
    };
    function handleCompletedEvent(tabId, tabData) {
        if (tabData && urlUtils.isUrlInList(platfromAbout.visbookmarksUrl, tabData.urls)) sendStat();
    }
    function forEachVBTab(callback) {
        tabs.getOpen(function(err, items) {
            if (Array.isArray(items)) items.filter(function(tab) {
                return urlUtils.isEqualUrls(tab.url, platfromAbout.visbookmarksUrl) && "complete" === tab.status;
            }).forEach(callback);
        });
    }
    function sendStat() {
        clicker.send({
            path: "system.show"
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("clicker-sync");
    var clicker = __webpack_require__(438);
    var sync = __webpack_require__(545);
    var SYNC_STAT_NAME = "system.chromesync";
    exports.init = function() {
        sync.onRemoteUpdated.addListener(checkRemote);
    };
    function checkRemote() {
        sync.checkRemote().then(sendStat).catch(logReject);
    }
    function sendStat() {
        clicker.send({
            path: SYNC_STAT_NAME
        });
    }
    function logReject(reason) {
        if (reason) logger.info("sync.checkRemote rejected with reason: %s", reason.message);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var logger = __webpack_require__(5).create("sync");
    var channel = __webpack_require__(27);
    var browserInfo = __webpack_require__(22);
    var syncAPI = __webpack_require__(546);
    var syncState = __webpack_require__(547);
    exports.init = function() {
        if (!browserInfo.isChrome()) return;
        syncAPI.init();
        initialSync();
        syncAPI.onChanged.addListener(handleRemoteChangedEvent);
    };
    exports.checkRemote = function() {
        return syncAPI.get().then(tryMarkRemote);
    };
    exports.onRemoteUpdated = channel.create();
    exports.onRemoteUpdatedError = channel.create();
    exports.onInitialSync = channel.create();
    exports.onInitialSyncError = channel.create();
    function initialSync() {
        return syncAPI.get().then(initialUpdateLocalData).then(dispatchInitialSync).catch(dispatchInitialSyncError);
    }
    function initialUpdateLocalData(remoteSnapshot) {
        if (syncState.isEmptySnapshot(remoteSnapshot)) {
            logger.info("Initial sync: empty remote snapshot");
            return updateRemoteWithLocal();
        }
        logger.info("Initial sync: remote data exist: %o", remoteSnapshot);
        return tryUpdateLocalData(remoteSnapshot);
    }
    function updateRemoteWithLocal() {
        logger.info("Update remote with local data");
        return syncAPI.set(syncState.getLocalSnapshot()).then(dispatchRemoteUpdated).catch(dispatchRemoteUpdatedError);
    }
    function tryUpdateLocalData(remoteSnapshot) {
        logger.info("Applying remote data: %o", remoteSnapshot);
        try {
            syncState.updateLocalData(remoteSnapshot);
            return updateRemoteWithLocal();
        } catch (e) {
            return Promise.reject(e);
        }
    }
    function handleRemoteChangedEvent(remoteSnapshot) {
        logger.info("Remote-changed event has been received, checking changes");
        if (syncState.isRemoteChanged(remoteSnapshot)) {
            logger.info("Changes in remote data have been found");
            tryUpdateLocalData(remoteSnapshot);
        }
    }
    function tryMarkRemote(remoteSnapshot) {
        if (!syncState.isMultipleGUIDs(remoteSnapshot)) return Promise.reject(new Error("Remote is not exist"));
        if (syncState.isMarked(remoteSnapshot)) return Promise.reject(new Error("Remote has been already marked"));
        var newSnapshot = syncState.getLocalSnapshot();
        newSnapshot = syncState.setMark(newSnapshot);
        return syncAPI.set(newSnapshot);
    }
    function dispatchInitialSync() {
        logger.info("Dispatch initial sync completed event");
        exports.onInitialSync.dispatch();
    }
    function dispatchInitialSyncError(error) {
        logger.error("Problem in initial-sync process: %o", error);
        exports.onInitialSyncError.dispatch(error);
    }
    function dispatchRemoteUpdated() {
        logger.info("Dispatch remote updated event");
        exports.onRemoteUpdated.dispatch();
    }
    function dispatchRemoteUpdatedError(error) {
        logger.info("Problem in update-remote process: %o", error);
        exports.onRemoteUpdatedError.dispatch();
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var channel = __webpack_require__(27);
    var logger = __webpack_require__(5).create("sync-api");
    var isEmpty = __webpack_require__(73);
    var thenChrome = __webpack_require__(283);
    var AREA_NAME = "sync";
    var RANDOM_ID_KEY = "_randomID_";
    var randomIDValue = Math.random();
    exports.init = function() {
        chrome.storage.onChanged.addListener(handleOnChangedEvent);
    };
    exports.get = function() {
        return thenChrome.storage.sync.get(null);
    };
    exports.set = function(snapshot) {
        assertTimestamp(snapshot, "set");
        snapshot[RANDOM_ID_KEY] = randomIDValue;
        return thenChrome.storage.sync.set(snapshot);
    };
    exports.onChanged = channel.create();
    function handleOnChangedEvent(changes, areaName) {
        if (changes && areaName === AREA_NAME && !isLocalChange(changes)) {
            var data = getNewData(changes);
            if (!isEmpty(data)) exports.onChanged.dispatch(data);
        }
    }
    function getNewData(changes) {
        return Object.keys(changes).reduce(function(result, key) {
            if (key !== RANDOM_ID_KEY) result[key] = changes[key].newValue;
            return result;
        }, {});
    }
    function isLocalChange(changes) {
        return changes[RANDOM_ID_KEY] && changes[RANDOM_ID_KEY].newValue === randomIDValue;
    }
    function assertTimestamp(snapshot, method) {
        if (!snapshot.timestamp) logger.error("%s; You must specify timestamp in passed data", method);
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var merge = __webpack_require__(157);
    var omit = __webpack_require__(548);
    var isEqual = __webpack_require__(549);
    var settings = __webpack_require__(216);
    var guid = __webpack_require__(550);
    var REMOTE_TIMESTAMP = "remoteSyncTimestamp";
    var LOCAL_SNAPSHOT = "localSyncSnapshot";
    var MARK = "__mark__";
    var synchronizers = [ guid ];
    exports.getLocalSnapshot = function() {
        var currentSnapshot = settings.get(LOCAL_SNAPSHOT);
        var newSnapshot = createNewSnapshot(currentSnapshot);
        settings.set(LOCAL_SNAPSHOT, newSnapshot);
        return newSnapshot;
    };
    exports.updateLocalData = function(remoteSnapshot) {
        updateRemoteTimestamp(remoteSnapshot);
        updateSynchronizers(remoteSnapshot);
    };
    exports.isEmptySnapshot = function(snapshot) {
        return !snapshot || 0 === Object.keys(snapshot).length;
    };
    exports.isRemoteChanged = function(remoteSnapshot) {
        return remoteSnapshot.timestamp > settings.get(REMOTE_TIMESTAMP);
    };
    exports.isMultipleGUIDs = function(remoteSnapshot) {
        return guid.getGUIDs(remoteSnapshot).length > 1;
    };
    exports.isMarked = function(snapshot) {
        return void 0 !== snapshot[MARK];
    };
    exports.setMark = function(snapshot) {
        snapshot[MARK] = true;
        return snapshot;
    };
    function updateRemoteTimestamp(remoteSnapshot) {
        if (remoteSnapshot.timestamp) settings.set(REMOTE_TIMESTAMP, remoteSnapshot.timestamp);
    }
    function createNewSnapshot(currentSnapshot) {
        var newSnapshot = mergeSynchronizers();
        newSnapshot.timestamp = isSnapshotsEqual(currentSnapshot, newSnapshot) ? currentSnapshot.timestamp : Date.now();
        return newSnapshot;
    }
    function updateSynchronizers(remoteSnapshot) {
        synchronizers.forEach(function(synchronizer) {
            synchronizer.update(remoteSnapshot);
        });
    }
    function mergeSynchronizers() {
        return synchronizers.reduce(function(result, synchronizer) {
            return merge(result, synchronizer.snapshot());
        }, {});
    }
    function isSnapshotsEqual(currentSnapshot, newSnapshot) {
        return isEqual(omit(currentSnapshot, [ "timestamp" ]), omit(newSnapshot, [ "timestamp" ]));
    }
}, function(module, exports, __webpack_require__) {
    var arrayMap = __webpack_require__(141), baseDifference = __webpack_require__(129), baseFlatten = __webpack_require__(76), bindCallback = __webpack_require__(78), keysIn = __webpack_require__(45), pickByArray = __webpack_require__(80), pickByCallback = __webpack_require__(81), restParam = __webpack_require__(82);
    var omit = restParam(function(object, props) {
        if (null == object) return {};
        if ("function" != typeof props[0]) {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
        }
        var predicate = bindCallback(props[0], props[1], 3);
        return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
        });
    });
    module.exports = omit;
}, function(module, exports, __webpack_require__) {
    var baseIsEqual = __webpack_require__(106), bindCallback = __webpack_require__(78);
    function isEqual(value, other, customizer, thisArg) {
        customizer = "function" == typeof customizer ? bindCallback(customizer, thisArg, 3) : void 0;
        var result = customizer ? customizer(value, other) : void 0;
        return void 0 === result ? baseIsEqual(value, other, customizer) : !!result;
    }
    module.exports = isEqual;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var platform = __webpack_require__(334);
    var UI_PREFIX = "__guid__";
    exports.snapshot = function() {
        var data = {};
        data[UI_PREFIX + platform.guid] = true;
        return data;
    };
    exports.update = function() {};
    exports.getGUIDs = function(snapshot) {
        return Object.keys(snapshot).reduce(function(result, key) {
            if (key.startsWith(UI_PREFIX)) result.push(key.replace(UI_PREFIX, ""));
            return result;
        }, []);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var clicker = __webpack_require__(438);
    var navigations = __webpack_require__(343);
    exports.init = function() {
        navigations.onThumbNavigated.addListener(onThumbNavigated);
    };
    function onThumbNavigated(data) {
        clicker.send({
            path: "thumb.click." + data.thumbPosition
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var voiceEvents = __webpack_require__(487);
    var clicker = __webpack_require__(438);
    var SerpNavigator = __webpack_require__(488);
    var SiteNavigator = __webpack_require__(491);
    exports.init = function() {
        voiceEvents.onRecognized.addListener(function(_ref) {
            var consumer = _ref.consumer;
            if (consumer instanceof SiteNavigator) clicker.send({
                path: "system.voice.navigsuccess"
            });
            if (consumer instanceof SerpNavigator) clicker.send({
                path: "system.voice.success"
            });
        });
        voiceEvents.onError.addListener(function() {
            clicker.send({
                path: "system.voice.error"
            });
        });
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var defaults = __webpack_require__(554);
    var experiments = __webpack_require__(328);
    var bannerId = __webpack_require__(337);
    var settings = __webpack_require__(216);
    var platform = __webpack_require__(334);
    var platformAbout = __webpack_require__(23);
    var platformBuildInfo = __webpack_require__(20);
    var platformClids = __webpack_require__(288);
    var dayuseHelper = __webpack_require__(336);
    var DayusePoller = __webpack_require__(335);
    var xhr = __webpack_require__(32);
    var curly = __webpack_require__(207);
    var branding = __webpack_require__(277);
    var logger = __webpack_require__(5).create("Statistics/dayuse-url");
    var STAT_URL_TEMPLATE = "https://yandex.{regionTld}/clck/click/";
    var LAST_SENDING_TIME_SETTING = "lastDayUseExpSendTime";
    var poller;
    exports.init = function() {
        poller = new DayusePoller(LAST_SENDING_TIME_SETTING);
        poller.onTrigger.addListener(sendStat);
    };
    function getDefautConfig() {
        return {
            dtype: "elduse",
            path: "tech.yaelements.dayuse",
            slots: [ 0, 0, 0 ],
            vars: {
                ui: "",
                bro: platformAbout.browserName,
                clid1: "",
                dayuse: 0,
                productname: platformAbout.yasoft,
                gchid: platformAbout.extensionId,
                ver: platformBuildInfo.getVersion().replace(/\./g, "-")
            }
        };
    }
    function sendStat() {
        if ("fx" === platformAbout.id && !settings.get("sendUsageStat")) return;
        var configForUrl = getConfigForUrl();
        var url = createStatUrl(configForUrl);
        logger.info("Send to %s", url);
        xhr({
            url: url
        }, onStatResponse);
    }
    function getConfigForUrl() {
        var config = {
            slots: getSlots(),
            vars: getVars()
        };
        return defaults(config, getDefautConfig());
    }
    function getSlots() {
        var expList = experiments.getExperimentsList();
        var currentExp = expList[0];
        var slot = currentExp ? currentExp.testId : 0;
        var bucket = currentExp ? currentExp.bucket : 0;
        return [ slot, slot, bucket ];
    }
    function getVars() {
        var vars = {
            dayuse: dayuseHelper.getDayuseCount(),
            clid1: platformClids.getByNumber(1),
            ui: platform.guid
        };
        var bannerIdValue = bannerId.getBannerId();
        if (bannerIdValue) vars.bnrd = bannerIdValue;
        return vars;
    }
    function createStatUrl(config) {
        return Object.keys(config).reduce(function(result, configKey) {
            return result + processConfigParam(configKey, config[configKey]) + "/";
        }, getBaseUrl()) + "*";
    }
    function getBaseUrl() {
        return curly.insertUrlVars(STAT_URL_TEMPLATE, {
            regionTld: branding.vars.regionTld
        });
    }
    function processConfigParam(name, value) {
        var resultPart = name + "=";
        if (Array.isArray(value)) return resultPart + processArrayValue(value); else if ("object" === ("undefined" === typeof value ? "undefined" : _typeof(value)) && null !== value) return resultPart + processObjectValue(value);
        return resultPart + value;
    }
    function processArrayValue(array) {
        return array.join(",");
    }
    function processObjectValue(object) {
        return Object.keys(object).map(function(key) {
            return "-" + key + "=" + object[key];
        }).join(",");
    }
    function onStatResponse(error) {
        if (error) logger.error("Error while sending statistics: %j", error); else poller.updateLastSendTime();
    }
}, function(module, exports, __webpack_require__) {
    var createDefaults = __webpack_require__(100), merge = __webpack_require__(157), mergeDefaults = __webpack_require__(555);
    var defaultsDeep = createDefaults(merge, mergeDefaults);
    module.exports = defaultsDeep;
}, function(module, exports, __webpack_require__) {
    var merge = __webpack_require__(157);
    function mergeDefaults(objectValue, sourceValue) {
        return void 0 === objectValue ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }
    module.exports = mergeDefaults;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var alarms = __webpack_require__(3);
    var clicker = __webpack_require__(438);
    var bgRotation = __webpack_require__(381);
    var informers = __webpack_require__(302);
    var ALARM = {
        name: "dayuseSimple",
        periodInMinutes: 24 * 60,
        delayInMinutes: 1
    };
    exports.init = function() {
        alarms.register(ALARM, onAlarm);
    };
    function onAlarm() {
        sendRotationStat();
        sendInformersStat();
    }
    function sendRotationStat() {
        if (bgRotation.isSelected()) clicker.send({
            path: "system.dailyback.dayuse"
        });
    }
    function sendInformersStat() {
        if (informers.isSupported() && informers.isEnabled()) clicker.send({
            path: "system.informers.dayuse"
        });
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.init = function() {
        __webpack_require__(335).init();
        __webpack_require__(553).init();
        __webpack_require__(556).init();
        __webpack_require__(539).init();
        __webpack_require__(538).init();
        __webpack_require__(551).init();
        __webpack_require__(544).init();
        __webpack_require__(543).init();
        __webpack_require__(540).init();
        __webpack_require__(542).init();
        __webpack_require__(552).init();
        __webpack_require__(541).init();
    };
}, function(module, exports, __webpack_require__) {
    var map = {
        "./alarms.js": 3,
        "./assert.js": 293,
        "./blob-utils.js": 267,
        "./browser-info.js": 22,
        "./channel-cacher.js": 26,
        "./channel.js": 27,
        "./collection-differ.js": 298,
        "./color-names.js": 261,
        "./colors.js": 259,
        "./curly.js": 207,
        "./date.js": 4,
        "./error-booster.js": 25,
        "./fetch.js": 72,
        "./file-storage.js": 263,
        "./file-utils.js": 266,
        "./format-message.js": 58,
        "./generic-module.js": 84,
        "./load-image.js": 224,
        "./lodash.js": 91,
        "./log-utils.js": 24,
        "./logger.js": 5,
        "./methods-table.js": 85,
        "./misc.js": 31,
        "./noop.js": 28,
        "./object.js": 90,
        "./offscreen/load-image.js": 260,
        "./offscreen/offscreen-manager.js": 70,
        "./overrides_v3/colors.js": 262,
        "./overrides_v3/xhr.js": 71,
        "./overrides_v3/xml.js": 68,
        "./promised-timer.js": 490,
        "./resource-loader-item.js": 257,
        "./resource-loader.js": 256,
        "./sax-parser.js": 227,
        "./tabs-watcher-2.js": 309,
        "./tabs-watcher.js": 459,
        "./tabs.js": 282,
        "./url/create-uri.js": 87,
        "./url/index.js": 83,
        "./url/url-impl.js": 86,
        "./url/urn-impl.js": 89,
        "./url/yandex-domains.js": 88,
        "./utils.js": 30,
        "./xhr-parsers.js": 60,
        "./xhr-utils.js": 38,
        "./xhr.js": 32,
        "./xml.js": 61
    };
    function webpackContext(req) {
        return __webpack_require__(webpackContextResolve(req));
    }
    function webpackContextResolve(req) {
        return map[req] || function() {
            throw new Error("Cannot find module '" + req + "'.");
        }();
    }
    webpackContext.keys = function() {
        return Object.keys(map);
    };
    webpackContext.resolve = webpackContextResolve;
    module.exports = webpackContext;
    webpackContext.id = 558;
} ]);